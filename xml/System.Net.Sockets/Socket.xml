<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="771bc63ed8e74a35e152dfca4c416071c5963605" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57962606" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Реализует интерфейс сокетов Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Класс предоставляет набор методов и свойств для сетевых подключений. <xref:System.Net.Sockets.Socket> Класс позволяет выполнять оба синхронной и асинхронную передачу данных с помощью любой из протоколов обмена данными в списке в <xref:System.Net.Sockets.ProtocolType> перечисления.  
  
 <xref:System.Net.Sockets.Socket> Класс использует шаблон именования платформы .NET Framework для асинхронных методов. Например, синхронный <xref:System.Net.Sockets.Socket.Receive%2A> метод соответствует асинхронным <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A> методы.  
  
 Если приложению требуется только один поток во время выполнения, используйте следующие методы, которые предназначены для работы в синхронном режиме.  
  
-   Если вы используете протокол с установлением соединения, таких как протокол TCP, сервер может ожидать передачи данных для подключений с помощью <xref:System.Net.Sockets.Socket.Listen%2A> метод. <xref:System.Net.Sockets.Socket.Accept%2A> Метод процессов все входящие подключения, запросы и возвращает <xref:System.Net.Sockets.Socket> , можно использовать для обмена данными с удаленным узлом. Используйте этот возвращенный <xref:System.Net.Sockets.Socket> для вызова <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A> метод. Вызовите <xref:System.Net.Sockets.Socket.Bind%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.Listen%2A> метод, если вы хотите указать локальный IP-адрес и порт номер. Используйте номер порта 0, если требуется, чтобы у основного поставщика услуг, чтобы назначить свободный порт для вас. Если вы хотите подключиться к узлу прослушивания, вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод. Для обмена данными, вызовите <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A> метод.  
  
-   Если вы используете протокол без установления соединения, например UDP, прослушивать подключения вообще не нужно. Вызовите <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод для приема входящих датаграмм. Используйте <xref:System.Net.Sockets.Socket.SendTo%2A> метод для отправки датаграмм к удаленному узлу.  
  
 Для обработки взаимодействия с помощью отдельных потоков во время выполнения, используйте следующие методы, которые предназначены для работы в асинхронном режиме.  
  
-   Если вы используете протокол с установлением соединения, таких как протокол TCP, используйте <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, и <xref:System.Net.Sockets.Socket.EndConnect%2A> методы для подключения к узлу прослушивания. Используйте <xref:System.Net.Sockets.Socket.BeginSend%2A> и <xref:System.Net.Sockets.Socket.EndSend%2A> или <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A> методы для асинхронного обмена данными. Входящие запросы на подключение могут быть обработаны с помощью <xref:System.Net.Sockets.Socket.BeginAccept%2A> и <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Если вы используете протокол без установления соединения, например UDP, можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.EndSendTo%2A> для отправки датаграмм, и <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> и <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> для приема датаграмм.  
  
 Если выполнить несколько асинхронных операций на сокете, они не обязательно должны завершаться в том порядке, в котором они запускаются.  
  
 При завершении отправки и получения данных, использования <xref:System.Net.Sockets.Socket.Shutdown%2A> метод, чтобы отключить <xref:System.Net.Sockets.Socket>. После вызова метода <xref:System.Net.Sockets.Socket.Shutdown%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод для освобождения всех ресурсов, связанных с <xref:System.Net.Sockets.Socket>.  
  
 <xref:System.Net.Sockets.Socket> Позволяет настроить ваши <xref:System.Net.Sockets.Socket> с помощью <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод. Извлечь эти параметры, с использованием <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
> [!NOTE]
>  Если вы создаете приложения настолько просты и не требуют максимальной производительности, рассмотрите возможность использования <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, и <xref:System.Net.Sockets.UdpClient>. Эти классы предоставляют простой и удобный интерфейс для <xref:System.Net.Sockets.Socket> связи.  
  
   
  
## Examples  
 В следующем примере кода показано как <xref:System.Net.Sockets.Socket> класс может использоваться для отправки данных на HTTP-сервер и получения ответа. В этом примере блокируется, пока не будет получен всей страницы.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Чтобы установить исходящее подключение, или принять входящий запрос.</permission>
    <threadsafe>Экземпляры этого класса являются потокобезопасными.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Сетевое программирование в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Рекомендации по использованию классов System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Управление кэшем для сетевых приложений</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">протокол IP версии 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Примеры сетевого программирования</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Трассировка сети в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Безопасность в сетевом программировании</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Улучшения производительности сокетов в версии 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Информация сокета, возвращенная объектом <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" /> с помощью указанного значения, возвращенного из объекта <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове метода <xref:System.Net.Sockets.Socket.%23ctor%2A> конструктор несколько раз с один и тот же байтовый массив в качестве аргумента для каждого вызова, вы создадите несколько управляемых <xref:System.Net.Sockets.Socket>s с тем же базовым сокетом. Этот подход не приветствуется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя указанный тип сокетов и протокол.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType` Параметр указывает тип <xref:System.Net.Sockets.Socket> класс и `protocolType` параметр указывает протокол, используемый <xref:System.Net.Sockets.Socket>. Два параметра не являются независимыми. Часто <xref:System.Net.Sockets.Socket> измеряется в протоколе. Если сочетание <xref:System.Net.Sockets.Socket> протокола для типов и типов результатов в недопустимом <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если этот конструктор вызывает <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Сочетание параметров <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к недопустимому сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Одно из значений <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя заданные семейство адресов, тип сокета и протокол.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` Параметр задает схему адресации, которую <xref:System.Net.Sockets.Socket> классом, `socketType` параметр указывает тип <xref:System.Net.Sockets.Socket> класса и `protocolType` параметр указывает протокол, используемый <xref:System.Net.Sockets.Socket>. Три параметра не являются независимыми. Некоторые семейства адресов ограничивать, какие протоколы можно использовать с ними и часто <xref:System.Net.Sockets.Socket> измеряется в протоколе. Если сочетание семейство адресов <xref:System.Net.Sockets.Socket> типа и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если этот конструктор вызывает <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется создание экземпляра <xref:System.Net.Sockets.Socket> класса.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Сочетание параметров <paramref name="addressFamily" />, <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к неработоспособному сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> синхронно извлекает первый ожидающий запрос подключения из очереди запросов подключения прослушивания сокета, а затем создает и возвращает новый <xref:System.Net.Sockets.Socket>. Нельзя использовать этот возвращенный <xref:System.Net.Sockets.Socket> для принятия любых дополнительных подключений из очереди на подключение. Тем не менее, можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> метод возвращаемого <xref:System.Net.Sockets.Socket> для идентификации удаленный узел сети адрес и номер порта.  
  
 В режиме блокировки <xref:System.Net.Sockets.Socket.Accept%2A> блокирует работу до попытку входящего подключения помещается в очередь. После принятия соединения исходное <xref:System.Net.Sockets.Socket> продолжает очереди входящие запросы на соединение только после закрытия его.  
  
 При вызове этого метода, с помощью неблокирующий <xref:System.Net.Sockets.Socket>и отсутствию подключения, запросы ставятся в очередь, <xref:System.Net.Sockets.Socket.Accept%2A> вызывает <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.Accept%2A> метод, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.Listen%2A> метод для прослушивания и очередь входящих запросов на подключение.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимает простой <xref:System.Net.Sockets.Socket> подключения.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. Событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не произойдет и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать протоколы, использующие подключения <xref:System.Net.Sockets.Socket.AcceptAsync%2A> попыток метод для асинхронной обработки входящего подключения. Асинхронно принимает подключения дает возможность отправлять и получать данные в отдельном потоке. Перед вызовом <xref:System.Net.Sockets.Socket.AcceptAsync%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Listen%2A> метод для прослушивания и очередь входящих запросов на подключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик событий\<SocketAsyncEventArgs > делегировать и подключить его к <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событий.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект, при необходимости можно задать существующий <xref:System.Net.Sockets.Socket> использования для входящего подключения путем указания <xref:System.Net.Sockets.Socket> для использования с <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> свойство.  
  
 Если <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> свойство имеет значение null, новый <xref:System.Net.Sockets.Socket> создается с тем же <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, и <xref:System.Net.Sockets.Socket.ProtocolType%2A> что и текущий <xref:System.Net.Sockets.Socket> и задать в качестве <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> свойство.  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.AcceptAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 При необходимости может быть оказана буфер для получения начального блока данных на сокете после <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод завершается успешно. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть присвоено буфер, содержащий данные для получения и <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> свойство должно быть присвоено максимальное число байтов данных, для получения в буфере. Эти свойства можно задать с помощью <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> метод. Часть буфера, переданного в будет использоваться внутренним образом для использования в базовый вызов Winsock AcceptEx. Это означает, что объем возвращаемых данных всегда будет меньше, чем значение <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> свойство <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> предоставленный экземпляр. Объем буфера, используемая внутри варьируются в зависимости от семейства адресов сокета. Минимальный размер буфера требуется составляет 288 байт. Если указан размер буфера, а затем <xref:System.Net.Sockets.Socket> будет ожидать, что некоторые дополнительные данные, отличные от адресов данные, полученные при вызове Winsock AcceptEx и будет ожидать до момента получения этих дополнительных данных. Если время ожидания, подключение сбрасывается. Поэтому если заданной суммы ожидается дополнительные данные, затем размер буфера задается минимальный размер буфера, а также этот объем.  
  
 Метод обратного вызова завершения следует изучить <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> свойства, чтобы определить, если <xref:System.Net.Sockets.Socket.AcceptAsync%2A> операция выполнена успешно.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> События могут возникать в некоторых случаях, если подключение не будет принято и в результате <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> свойству будет присвоено <xref:System.Net.Sockets.SocketError.ConnectionReset>. Это может произойти в результате сканирование портов с помощью типа проверки полуоткрытый SYN (SYN SYN-ACK, "->" -> последовательности RST). Приложения, использующие <xref:System.Net.Sockets.Socket.AcceptAsync%2A> метода должны быть готовы обрабатывать это условие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если обеспечиваемый буфер имеет недостаточный размер. Буфер должен иметь размер, равный, по крайней мере, 2 * (размер(SOCKADDR_STORAGE + 16) байт.  
  
Это исключение также возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент вне диапазона. Исключение возникает, если объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> имеет значение меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринят запрос выполнения недопустимой операции. Это исключение возникает, если принимающий объект <see cref="T:System.Net.Sockets.Socket" /> не производит прослушивание подключений или принимающий сокет является связанным.  
  
Требуется вызвать объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> перед вызовом метода <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
Это исключение также происходит, если сокет уже подключен или работа с сокетом уже выполнялась с использованием указанного параметра <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает семейство адресов объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> Задает схему адресации, экземпляр <xref:System.Net.Sockets.Socket> класс может использовать. Это свойство только для чтения и устанавливается при <xref:System.Net.Sockets.Socket> создается.  
  
   
  
## Examples  
 Следующий код отображает пример <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее количество полученных из сети и доступных для чтения данных.</summary>
        <value>Количество байтов данных, полученных из сети и доступных для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете неблокирующий <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> — хороший способ определить ли данные в очереди для чтения, перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Доступные данные — это общий объем данных в очереди в сетевом буфере для чтения. Если данные не помещается в очередь в сетевом буфере <xref:System.Net.Sockets.Socket.Available%2A> возвращает 0.  
  
 Если удаленный узел завершает работу или закрывает соединение, <xref:System.Net.Sockets.Socket.Available%2A> может вызвать исключение <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере сравниваются результаты вызова IOControl с fionread СПЕЦИФИКАЦИИ и доступное свойство.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать протоколы, использующие подключения <xref:System.Net.Sockets.Socket.BeginAccept%2A> попыток метод для асинхронной обработки входящего подключения. Асинхронно принимает подключения дает возможность отправлять и получать данные в отдельном потоке. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Listen%2A> метод для прослушивания и очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. Чтобы сделать это, по крайней мере, необходимо передать прослушивающий <xref:System.Net.Sockets.Socket> объект <xref:System.Net.Sockets.Socket.BeginAccept%2A> через `state` параметра. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система использует отдельный поток для выполнения указанный метод обратного вызова и обычно блоков в <xref:System.Net.Sockets.Socket.EndAccept%2A> пока не будет получено ожидающего подключения. <xref:System.Net.Sockets.Socket.EndAccept%2A> Возвращает новый <xref:System.Net.Sockets.Socket> который можно использовать для отправки и получения данных с удаленного узла. Нельзя использовать этот возвращенный <xref:System.Net.Sockets.Socket> для принятия любых дополнительных подключений из очереди на подключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод набора <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если вы хотите продолжить выполнение исходного потока.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращенном <xref:System.IAsyncResult> будет содержать значение, указывающее, <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод синхронно.  
  
 Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginAccept%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndAccept%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
> [!NOTE]
>  Можно использовать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойства возвращаемого <xref:System.Net.Sockets.Socket> для идентификации удаленный узел сети адрес и номер порта.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода пытается асинхронного получения входящего подключения.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-или- 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Число байтов, которые необходимо принять от отправителя.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения и получить первый блок данных, посланных клиентским приложением.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать протоколы, использующие подключения <xref:System.Net.Sockets.Socket.BeginAccept%2A> попыток метод для асинхронной обработки входящего подключения. Асинхронно принимает соединения позволяет отправлять и получать данные в отдельном потоке. Эта перегрузка позволяет указать число принимаемых байтов в начальной передачи в `receiveSize` параметра.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Listen%2A> метод для прослушивания и очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. Чтобы сделать это, по крайней мере, необходимо передать прослушивающий <xref:System.Net.Sockets.Socket> объект <xref:System.Net.Sockets.Socket.BeginAccept%2A> через `state` параметра. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система использует отдельный поток для выполнения указанный метод обратного вызова и обычно блоков в <xref:System.Net.Sockets.Socket.EndAccept%2A> пока не будет получено ожидающего подключения.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Возвращает новый <xref:System.Net.Sockets.Socket> можно использовать для отправки и получения данных с удаленного узла. Нельзя использовать этот возвращенный <xref:System.Net.Sockets.Socket> для принятия любых дополнительных подключений из очереди на подключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод набора <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если вы хотите продолжить выполнение исходного потока.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращенном <xref:System.IAsyncResult> будет содержать значение, указывающее, <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод синхронно.  
  
 Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод close <xref:System.Net.Sockets.Socket>.  Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginAccept%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndAccept%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
> [!NOTE]
>  Вы можете вызвать используйте <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойства возвращаемого <xref:System.Net.Sockets.Socket> объект для идентификации удаленный узел сети адрес и номер порта.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода открывает сокет и принимает асинхронного подключения. В этом примере сокет принимает начальные 10 байтов данных. Количество полученных байтов и данные отображаются на консоли делегат обратного вызова. См. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A> описание как происходит получение оставшихся данных.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-или- 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Принятый объект <see cref="T:System.Net.Sockets.Socket" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="receiveSize">Максимальное число принимаемых байтов.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения с указанного сокета и получить первый блок данных, посланных клиентским приложением.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать протоколы, использующие подключения <xref:System.Net.Sockets.Socket.BeginAccept%2A> попыток метод для асинхронной обработки входящего подключения. Асинхронно принимает подключения дает возможность отправлять и получать данные в отдельном потоке. Эта перегрузка позволяет указать допущенный сокет в `acceptSocket` параметра. Если этот параметр имеет `null`, созданные допущенный сокет <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. Можно указать число принимаемых байтов в начальной передачи в `receiveSize` параметра.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Listen%2A> метод для прослушивания и очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. Чтобы сделать это, по крайней мере, необходимо передать прослушивающий <xref:System.Net.Sockets.Socket> объект <xref:System.Net.Sockets.Socket.BeginAccept%2A> через `state` параметра. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система использует отдельный поток для выполнения указанный метод обратного вызова и обычно блоков в <xref:System.Net.Sockets.Socket.EndAccept%2A> пока не будет получено ожидающего подключения.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Возвращает новый <xref:System.Net.Sockets.Socket> который можно использовать для отправки и получения данных с удаленного узла. Нельзя использовать этот возвращенный <xref:System.Net.Sockets.Socket> для принятия любых дополнительных подключений из очереди на подключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод набора <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если вы хотите продолжить выполнение исходного потока.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращенном <xref:System.IAsyncResult> будет содержать значение, указывающее, <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод синхронно.  
  
 Дополнительные сведения о создании методов обратного вызова, см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginAccept%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndAccept%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
> [!NOTE]
>  Можно использовать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойства возвращаемого <xref:System.Net.Sockets.Socket> объект для идентификации удаленный узел сети адрес и номер порта.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода открывает сокет и принимает асинхронного подключения. В этом примере сокет принимает начальные 10 байтов данных и `acceptSocket` параметр `null`, какие силы <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод для создания допущенный сокет. Количество полученных байтов и данные отображаются на консоли делегат обратного вызова. См. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A> описание как происходит получение оставшихся данных.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-или- 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</param>
        <param name="end_point">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод начинает выполнение асинхронного запроса для соединения с `remoteEP` параметра. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.BeginConnect%2A> устанавливает удаленный узел по умолчанию. Подключение или задание удаленный узел по умолчанию в асинхронном режиме дает возможность отправлять и получать данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод. По крайней мере, необходимо передать <xref:System.Net.Sockets.Socket> для <xref:System.Net.Sockets.Socket.BeginConnect%2A> через `state` параметра. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginConnect%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndConnect%2A> пока <xref:System.Net.Sockets.Socket> успешно подключается, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, используйте <xref:System.Threading.WaitHandle.WaitOne%2A>. Вызовите метод набора <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.BeginConnect%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> для обмена данными с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.BeginConnect%2A>, будут потеряны любые датаграммы, поступившие от адрес, отличный от заданного по умолчанию. Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и присвоено вещания `true`. Если это невозможно, <xref:System.Net.Sockets.Socket.BeginConnect%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если вы используете протокол с установлением соединения и не следует вызывать <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>, основному поставщику услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Если вы используете протокол без установления соединения, поставщик услуг не присвоит локальный сетевой адрес и порт номер до вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод повторно с требуемой конечной точкой.  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginConnect%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndConnect%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, затем <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен вызываться в потоке, который не завершит работу до завершения операции. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода инициируется попытка асинхронного подключения.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Адрес <see cref="T:System.Net.IPAddress" /> удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. узел задается объектом <see cref="T:System.Net.IPAddress" /> и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Как правило, вызывается метод `requestCallback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода, или <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginConnect%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndConnect%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, затем <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен вызываться в потоке, который не завершит работу до завершения операции. Это ограничение базового поставщика. Также <xref:System.Net.EndPoint> то есть используется должны быть разными.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода инициируется попытка асинхронного подключения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Net.Sockets.Socket" /> не входит в состав семейства сокетов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">По крайней мере, один объект <see cref="T:System.Net.IPAddress" />, определяющий удаленный узел.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. узел задается массивом <see cref="T:System.Net.IPAddress" /> и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронные подключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Как правило, вызывается метод `requestCallback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода.  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginConnect%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndConnect%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, затем <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен вызываться в потоке, который не завершит работу до завершения операции. Это ограничение базового поставщика. Также <xref:System.Net.EndPoint> то есть используется должны быть разными.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода инициируется попытка асинхронного подключения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов, которые используют объект <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="host">Имя удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. Узел задается именем узла и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Как правило, вызывается метод `requestCallback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода.  
  
 Чтобы отменить ожидающий вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод close <xref:System.Net.Sockets.Socket>. Когда <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции, вызывается метод, обратный вызов передается <xref:System.Net.Sockets.Socket.BeginConnect%2A> вызывается метод.  Последующий вызов <xref:System.Net.Sockets.Socket.EndConnect%2A> метод вызывает исключение <xref:System.ObjectDisposedException> для указания, что операция была отменена.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, затем <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен вызываться в потоке, который не завершит работу до завершения операции. Это ограничение базового поставщика. Также <xref:System.Net.EndPoint> то есть используется должны быть разными.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода инициируется попытка асинхронного подключения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия подключения; в противном случае — значение <see langword="false" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, можно вызвать <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> метод для запроса к разрыву из удаленной конечной точки. Если `reuseSocket` является `true`, вы можете повторно использовать сокета.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Метод использует отдельный поток для вызова указанный метод обратного вызова. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Метод блокируется до ожидания отключения завершена. Дополнительные сведения о создании методов обратного вызова, см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> исключения, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создает сокет для асинхронной связи и отправляет данные на удаленном узле. После отправки данных <xref:System.Net.Sockets.Socket.Shutdown%2A> вызывается для остановки отправки и действие receive. Затем <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> вызывается, чтобы начать запрос на разъединение. По завершении запроса <xref:System.Net.Sockets.Socket.Connected%2A> свойство запрашивается для тестирования ли сокет отключен.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndReceive%2A> метод. Как правило, вызывается метод `callback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndReceive%2A> метод. Как правило, вызывается метод `callback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся принятые данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndReceive%2A> метод. Как правило, вызывается метод `callback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода начинает асинхронный прием данных из подключенного <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="error">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронный <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndReceive%2A> метод. Как правило, вызывается метод `callback` делегировать.  
  
 Этот метод не приводит к блокировке до завершения операции. Чтобы заблокировать до завершения операции, используйте один из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="remote_end">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Метод начинает асинхронное чтение датаграмм без установления соединения с удаленного узла. Вызов <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод дает возможность принимать данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> пока <xref:System.Net.Sockets.Socket> считывает данные, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метода, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызывайте метод Set T:System.Threading.ManualResetEvent в метод обратного вызова, когда вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова, см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, необходимо явно связать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод, или <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Этот метод считывает данные в `buffer` параметр и фиксирует удаленный узел конечной точки, с которого отправляются данные. Сведения о том, как получить эту конечную точку, см. <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Этот метод наиболее полезен в тех случаях, если планируется выполнение асинхронного приема датаграмм без установления соединения с неизвестного узла или нескольких узлах. В этих случаях <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать первую датаграмму в буфер локальной сети. Если датаграмма превышает размер `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод будет заполнять `buffer` с максимально возможную часть сообщения, а затем throw <xref:System.Net.Sockets.SocketException>. Если вы используете ненадежный протокол, избыточные данные будут потеряны. Если вы используете протокол надежного, избыточные данные будут храниться поставщиком услуг, и его можно получить, вызвав <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод с достаточно большой буфер.  
  
 Чтобы гарантировать, что всегда возвращается конечная точка удаленного узла, приложение должно явно привязать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод, а затем вызовите метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод с `optionLevel` параметру присвоить <xref:System.Net.Sockets.SocketOptionLevel.IP>или <xref:System.Net.Sockets.SocketOptionLevel.IPv6> соответствующим образом, `optionName` параметру присвоить <xref:System.Net.Sockets.SocketOptionName.PacketInformation>и `optionValue` параметр, чтобы включить этот параметр перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод. В противном случае возможна для конечной точки удаленного узла не возвращается при отправитель отправил число датаграмм, прежде чем получатель вызвал <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод.  
  
 Несмотря на то что <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> предназначен для протоколов без установления соединения, можно использовать также протокол ориентированного на подключение. Если вы решили сделать это, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод или принимать входящий запрос на подключение, вызвав <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. При вызове метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод до установления подключения или принятия запроса на подключения, вы получите <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод будет игнорировать `remoteEP` параметр и получать только данные из подключенных или удаленный узел по умолчанию.  
  
 С помощью сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать столько данных доступно до числа байтов, заданному параметром `size` параметр.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода асинхронно получает датаграмм без установления соединения с удаленного узла.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронную операцию получения должна быть завершена до вызова <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> метод. Как правило, вызывается метод `asyncCallback` делегировать.  
  
 Этот метод блокируется до завершения операции. Чтобы заблокировать до завершения операции, используйте <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Этот метод считывает данные в `buffer` параметра и захватов, удаленный узел конечной точки, из которого данные отправляются, а также сведения о полученном пакете. Сведения о том, как получить эту конечную точку, см. <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Этот метод наиболее полезен в тех случаях, если планируется выполнение асинхронного приема датаграмм без установления соединения с неизвестного узла или нескольких узлах.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. <xref:System.Net.Sockets.Socket.BeginSend%2A> будет выдано исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSend%2A> метод дает возможность отправлять данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginSend%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndSend%2A> пока <xref:System.Net.Sockets.Socket> отправляет количество запрошенных байтов, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginSend%2A> используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод. Вызывайте метод Set T:System.Threading.ManualResetEvent в метод обратного вызова, когда вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.BeginSend%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При работе с протоколами необходимо также убедиться в том, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. <xref:System.Net.Sockets.Socket.BeginSend%2A> будет выдано исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSend%2A> метод дает возможность отправлять данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginSend%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndSend%2A> пока <xref:System.Net.Sockets.Socket> отправляет количество запрошенных байтов, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginSend%2A> используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод. Вызовите метод набора <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.BeginSend%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При работе с протоколами необходимо также убедиться в том, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. <xref:System.Net.Sockets.Socket.BeginSend%2A> будет выдано исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSend%2A> метод дает возможность отправлять данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginSend%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndSend%2A> пока <xref:System.Net.Sockets.Socket> отправляет количество запрошенных байтов, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginSend%2A> используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод. Вызывайте метод Set T:System.Threading.ManualResetEvent в метод обратного вызова, когда вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.BeginSend%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При работе с протоколами необходимо также убедиться в том, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод. <xref:System.Net.Sockets.Socket.BeginSend%2A> будет выдано исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSend%2A> метод дает возможность отправлять данные в отдельном потоке.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginSend%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndSend%2A> пока <xref:System.Net.Sockets.Socket> отправляет количество запрошенных байтов, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginSend%2A> используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод. Вызывайте метод Set T:System.Threading.ManualResetEvent в метод обратного вызова, когда вы хотите продолжить выполнение исходного потока. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.BeginSend%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При работе с протоколами необходимо также убедиться в том, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром пользовательского класса.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода начинается асинхронная передача данных на удаленном узле.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет асинхронную передачу файла на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Строка, содержащая путь и имя отправляемого файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который представляет асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` подключенный сокет. Если `fileName` находится в локальном каталоге, он может быть идентифицирован с помощью только имя файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (».. \\\myfile.txt») и имена общих ресурсов UNC («\\\\\\\shared directory\\\myfile.txt»), поддерживаются. Если файл не найден, исключение <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 Этот метод использует `TransmitFile` найти функцию в Windows Sockets 2 API. Дополнительные сведения о `TransmitFile` функция и его флаги, см. в разделе [Windows Sockets](/windows/desktop/WinSock/) документации.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> методы. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод позволяет отправить файл в отдельном потоке.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый методом <xref:System.AsyncCallback> параметра делегата. Чтобы сделать это, по крайней мере, `state` параметр должен содержать <xref:System.Net.Sockets.Socket> объект, используемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого пользовательского объекта для <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должна вызвать <xref:System.Net.Sockets.Socket.EndSendFile%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения обратного вызова указанного метода и блокирует на <xref:System.Net.Sockets.Socket.EndSendFile%2A> пока <xref:System.Net.Sockets.Socket> перешлет весь файл или создает исключение. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. При работе с протоколами необходимо убедиться, что размер файла не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает <xref:System.Net.Sockets.SocketException> исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> исключения, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода создается и подключение сокета для асинхронной связи. Во-первых файл «text.txt» отправляется асинхронно к удаленному узлу. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Строка, содержащая путь и имя отправляемого файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="preBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="postBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="flags">Побитовое сочетание значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, который должен быть вызван, когда эта операция завершается. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="state">Определенный пользователем объект, содержащий сведения о состоянии для этого запроса. Этот параметр может иметь значение <see langword="null" />.</param>
        <summary>Выполняет асинхронную передачу файла и буферов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку необходимо указать имя файла для отправки и побитовое сочетание <xref:System.Net.Sockets.TransmitFileOptions> значения. `preBuffer` Параметр содержит все данные, должен предшествовать файл. `postBuffer` содержит данные, которые вы хотите изучить файл. Если `fileName` находится в локальном каталоге, он может быть идентифицирован с помощью только имя файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (».. \\\myfile.txt») и имена общих ресурсов UNC («\\\\\\\shared directory\\\myfile.txt»), поддерживаются. Если файл не найден, исключение <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 `flags` Параметр предоставляет поставщик услуг сокетов окно с дополнительными сведениями о передаче файла. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует `TransmitFile` найти функцию в Windows Sockets 2 API. Дополнительные сведения о `TransmitFile` функция и его флаги, см. в разделе [Windows Sockets](/windows/desktop/WinSock/) документации.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> методы. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод дает возможность отправки файла в отдельном потоке.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый методом <xref:System.AsyncCallback> параметра делегата. Чтобы сделать это, по крайней мере, `state` параметр должен содержать <xref:System.Net.Sockets.Socket> объект, используемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и другие необходимые сведения. Передать экземпляр этого пользовательского объекта для <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должна вызвать <xref:System.Net.Sockets.Socket.EndSendFile%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения обратного вызова указанного метода и блокирует на <xref:System.Net.Sockets.Socket.EndSendFile%2A> пока <xref:System.Net.Sockets.Socket> перешлет весь файл или создает исключение. Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод, чтобы установить удаленный узел по умолчанию. При работе с протоколами необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает <xref:System.Net.Sockets.SocketException> исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> исключения, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода создается и подключение сокета для асинхронной связи и начинается отправка файла «text.txt» асинхронно к удаленному узлу. В этом примере `preBuffer` и `postBuffer` данных создается для отправки файла и значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions> используется значение. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.NotSupportedException">Операционной системой не является Windows NT или более поздняя версия.  
  
-или- 
Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <param name="remote_end">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Асинхронно передает данные на конкретный удаленный узел.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Метод запускает операцию асинхронной передачи на удаленный узел, указанный в `remoteEP` параметра. Вызов <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метод дает возможность отправлять данные в отдельном потоке. Несмотря на то, что предназначены для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> работает с протоколами без установления соединения и ориентированных на подключение.  
  
 Можно создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегат и передайте ее имя в <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метод. Чтобы сделать это, по крайней мере, ваш `state` параметр должен содержать подключенного или по умолчанию <xref:System.Net.Sockets.Socket> , применяемый для связи. Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передать экземпляр этого класса для <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метод с помощью `state` параметра.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSendTo%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, система будет использовать отдельный поток для выполнения указанный метод обратного вызова и заблокирует <xref:System.Net.Sockets.Socket.EndSendTo%2A> пока <xref:System.Net.Sockets.Socket> отправляет количество запрошенных байтов, или создает исключение. Если необходимо, чтобы заблокировать после вызова исходный поток <xref:System.Net.Sockets.Socket.BeginSendTo%2A> используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод. Вызывайте метод Set T:System.Threading.ManualResetEvent в метод обратного вызова, когда вы хотите продолжить выполнение исходного потока. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Если вы используете протокол с установлением соединения, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод, или <xref:System.Net.Sockets.Socket.BeginSendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> будет игнорировать `remoteEP` параметр и отправляет данные на <xref:System.Net.EndPoint> в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, или <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` переопределит указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод. В этом случае основной поставщик услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Используйте номер порта 0, если требуется, чтобы у основного поставщика услуг, чтобы выбрать свободный порт. Если вам необходимо идентифицировать назначенные локальной сети адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.Socket.EndSendTo%2A> успешного завершения метода.  
  
 Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет равным <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. — Необходимо также быть убедитесь, что размер буфера превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.EndSendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенного пользователя и контекст вызова) кэшируется для асинхронной <xref:System.Net.Sockets.Socket> методы. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метод, определенный <xref:System.Net.Sockets.Socket> экземпляра и определенный обратный вызов), для последующего использования этого контекста будет повыситься производительность.  
  
   
  
## Examples  
 В следующем примере кода асинхронно отправляет данные на удаленный узел.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Локальный объект <see cref="T:System.Net.EndPoint" />, который необходимо связать с объектом <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Связывает объект <see cref="T:System.Net.Sockets.Socket" /> с локальной конечной точкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Net.Sockets.Socket.Bind%2A> метод, если необходимо использовать определенные локальной конечной точки. Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Listen%2A> метод. Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> перед использованием <xref:System.Net.Sockets.Socket.Connect%2A> метод Если не нужно использовать определенную локальную конечную точку. Можно использовать <xref:System.Net.Sockets.Socket.Bind%2A> метод для протоколов без установления соединения и ориентированных на подключение.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>, необходимо сначала создать локальный <xref:System.Net.IPEndPoint> из которой планируется обмен данных. Если неважно, какой локальный адрес назначен, вы можете создать <xref:System.Net.IPEndPoint> с помощью <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> параметр address, а базовая служба поставщика будет назначать наиболее подходящий сетевой адрес. Это поможет упростить приложение, если у вас есть несколько сетевых интерфейсов. Если неважно, какой локальный порт используется, можно создать <xref:System.Net.IPEndPoint> используется значение 0 для номера порта. В этом случае поставщик услуг назначит доступный номер порта от 1024 до 5000.  
  
 Если вы используете выше подход, вы узнаете, какие локальный сетевой адрес и номер порта назначен путем вызова <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> не вернет локально назначенный сетевой адрес до, после вызова <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Если вы используете протокол без установления соединения, вы не будет доступа к этой информации до завершения отправки или получения.  
  
 Если требуется получить интерфейс сведения о полученных пакетов UDP-сокет <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод должен вызываться явным образом с помощью параметра сокета, равным <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сразу после вызова <xref:System.Net.Sockets.Socket.Bind%2A> метод.  
  
> [!NOTE]
>  Если вы планируете получать датаграммы многоадресной рассылки, необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> метод с номером порта многоадресной рассылки.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> метод, если требуется получение датаграмм без установления соединения с использованием <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> при вызове <xref:System.Net.Sockets.Socket.Bind%2A> метода, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода примере <xref:System.Net.Sockets.Socket> с помощью заданной локальной конечной точкой.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений от узла, определенного параметром <paramref name="localEP" />. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, находится ли объект <see cref="T:System.Net.Sockets.Socket" /> в заблокированном режиме.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> будет заблокирован; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> Свойство указывает, является ли <xref:System.Net.Sockets.Socket> находится в режиме блокировки.  
  
 Если вы находитесь в режиме блокировки, и метод вызова, который не завершается немедленно, приложение будет блокировать выполнение до завершения запрошенной операции. Если вы хотите, чтобы продолжить, несмотря на то, что Запрошенная операция не завершена, изменить <xref:System.Net.Sockets.Socket.Blocking%2A> свойства `false`. <xref:System.Net.Sockets.Socket.Blocking%2A> Свойство не действует для асинхронных методов. Если вы отправляют и асинхронное получение данных и хотите заблокировать выполнение, используйте <xref:System.Threading.ManualResetEvent> класса.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, используемый для запроса соединения с удаленным узлом путем вызова одного из методов <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Отменяет выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Метод отменяет асинхронный запрос для подключения к удаленному узлу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Метод закрывает подключение к удаленному узлу и выпусков все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. При закрытии <xref:System.Net.Sockets.Socket.Connected%2A> свойству `false`.  
  
 Для протоколов, ориентированного на подключение, рекомендуется вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом <xref:System.Net.Sockets.Socket.Close%2A> метод. Это гарантирует, что все данные отправки и получения на подключенный сокет, до его закрытия.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без предварительного вызова функции <xref:System.Net.Sockets.Socket.Shutdown%2A>, убедитесь, что данные в очередь для передачи будут отправляться, задав <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> равным `false` и указанием интервала ожидания ненулевое значение. <xref:System.Net.Sockets.Socket.Close%2A> затем будет блокировать до отправки этих данных, или пока не истечет заданное время ожидания. Если задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> для `false` и укажите ноль интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет данные из выходной очереди.  
  
> [!NOTE]
>  Чтобы задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> сокета параметр, чтобы `false`, создание <xref:System.Net.Sockets.LingerOption>, значение свойства enabled `true`и задайте <xref:System.Net.Sockets.LingerOption.LingerTime%2A> свойства нужный период времени ожидания. Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с <xref:System.Net.Sockets.SocketOptionName.DontLinger> параметром для вызова сокета <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода пример закрывает <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Процесс ожидает указанное число секунд <paramref name="timeout" />, прежде чем отправить оставшиеся данные, а затем закрывает сокет.</param>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы с заданным временем ожидания, чтобы разрешить отправку данных в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Метод закрывает подключение к удаленному узлу и выпусков все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. При закрытии <xref:System.Net.Sockets.Socket.Connected%2A> свойству `false`.  
  
 Для протоколов, ориентированного на подключение, рекомендуется вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом <xref:System.Net.Sockets.Socket.Close%2A>. Это гарантирует, что все данные отправки и получения на подключенный сокет, до его закрытия.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без предварительного вызова функции <xref:System.Net.Sockets.Socket.Shutdown%2A>, убедитесь, что данные в очередь для передачи будут отправляться, задав <xref:System.Net.Sockets.SocketOptionName.DontLinger> равным `false` и указанием интервала ожидания ненулевое значение. <xref:System.Net.Sockets.Socket.Close%2A> затем будет блокировать до отправки этих данных, или пока не истечет заданное время ожидания. Если задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> для `false` и укажите ноль интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет данные из выходной очереди.  
  
> [!NOTE]
>  Чтобы задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> параметром для сокета `false`, создание <xref:System.Net.Sockets.LingerOption>, значение свойства enabled `true`и задайте <xref:System.Net.Sockets.LingerOption.LingerTime%2A> свойство в нужное время ожидания. Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с <xref:System.Net.Sockets.SocketOptionName.DontLinger> параметром для вызова сокета <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как закрыть <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает подключение к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <summary>Устанавливает подключение к удаленному узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, таких как протокол TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое соединение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точке. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова метода <xref:System.Net.Sockets.Socket.Connect%2A>, можно отправлять данные на удаленном устройстве с помощью <xref:System.Net.Sockets.Socket.Send%2A> метода или получение данных с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метод.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.Connect%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> синхронно взаимодействовать с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A>, будут потеряны любые датаграммы, поступившие от адрес, отличный от заданного по умолчанию. Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> параметр метода и набор сокет <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, или <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Метод выполняет блокировку, если только специально настроены, <xref:System.Net.Sockets.Socket.Blocking%2A> свойства `false` до вызова метода <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол с установлением соединения, такие как TCP и отключить блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> так, как требуется время для подключения. Протоколов без установления соединения не вызовет исключение, так как они просто установить удаленный узел по умолчанию. Можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Если ошибка возвращает WSAEWOULDBLOCK, подключение к удаленному узлу инициировала ориентированного на подключение <xref:System.Net.Sockets.Socket>, но еще не завершена успешно. Используйте <xref:System.Net.Sockets.Socket.Poll%2A> метод, чтобы определить, когда <xref:System.Net.Sockets.Socket> завершения подключения.  
  
> [!NOTE]
>  Если вы используете протокол с установлением соединения и не вызвал <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, основному поставщику услуг назначит локальный сетевой адрес и номер порта. Если вы используете протокол без установления соединения, поставщик услуг не присвоит локальный сетевой адрес и порт номер до завершения отправки или операции получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> повторно с требуемой конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, этот метод нельзя использовать для восстановления подключения. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методы для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода подключается к удаленной конечной точки и затем проверяет подключение.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">для подключения к удаленному узлу. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">IP-адрес удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Устанавливает подключение к удаленному узлу. Узел задается IP-адресом и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, таких как протокол TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое соединение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точке. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова метода <xref:System.Net.Sockets.Socket.Connect%2A> можно отправлять данные на удаленном устройстве с помощью <xref:System.Net.Sockets.Socket.Send%2A> метода или получение данных с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метод.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.Connect%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> синхронно взаимодействовать с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> датаграмм, поступившие с адрес, отличный от заданного по умолчанию будут потеряны. Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> параметр метода и набор сокет <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, или <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод выполняет блокировку, если только специально настроены, <xref:System.Net.Sockets.Socket.Blocking%2A> свойства `false` до вызова метода <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол с установлением соединения, такие как TCP и отключить блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> так, как требуется время для подключения. Протоколов без установления соединения не вызовет исключение, так как они просто установить удаленный узел по умолчанию. Можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Если ошибка возвращает WSAEWOULDBLOCK, подключение к удаленному узлу инициировала ориентированного на подключение <xref:System.Net.Sockets.Socket>, но еще не завершена успешно. Используйте <xref:System.Net.Sockets.Socket.Poll%2A> метод, чтобы определить, когда <xref:System.Net.Sockets.Socket> завершения подключения.  
  
> [!NOTE]
>  Если вы используете протокол с установлением соединения и не вызвал <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, основному поставщику услуг назначит локальный сетевой адрес и номер порта. Если вы используете протокол без установления соединения, поставщик услуг не присвоит локальный сетевой адрес и порт номер до завершения отправки или операции получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> повторно с требуемой конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, этот метод нельзя использовать для восстановления подключения. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методы для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода подключается к удаленной конечной точки и затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">IP-адрес удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Устанавливает подключение к удаленному узлу. Узел задается массивом IP-адресов и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется сразу же после вызова <xref:System.Net.Dns.GetHostAddresses%2A>, который может возвращать несколько IP-адресов для одного узла. Если вы используете протокол с установлением соединения, таких как протокол TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое соединение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точке. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова метода <xref:System.Net.Sockets.Socket.Connect%2A> можно отправлять данные на удаленном устройстве с помощью <xref:System.Net.Sockets.Socket.Send%2A> метода или получение данных с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метод.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.Connect%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> синхронно взаимодействовать с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> датаграмм, поступившие с адрес, отличный от заданного по умолчанию будут потеряны. Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> параметр метода и набор сокет <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, или <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод выполняет блокировку, если только специально настроены, <xref:System.Net.Sockets.Socket.Blocking%2A> свойства `false` до вызова метода <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол с установлением соединения, такие как TCP и отключить блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> так, как требуется время для подключения. Протоколов без установления соединения не вызовет исключение, так как они просто установить удаленный узел по умолчанию. Можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Если ошибка возвращает WSAEWOULDBLOCK, подключение к удаленному узлу инициировала ориентированного на подключение <xref:System.Net.Sockets.Socket>, но еще не завершена успешно. Используйте <xref:System.Net.Sockets.Socket.Poll%2A> метод, чтобы определить, когда <xref:System.Net.Sockets.Socket> завершения подключения.  
  
> [!NOTE]
>  Если вы используете протокол с установлением соединения и не вызвал <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, основному поставщику услуг назначит локальный сетевой адрес и номер порта. Если вы используете протокол без установления соединения, поставщик услуг не присвоит локальный сетевой адрес и порт номер до завершения отправки или операции получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> повторно с требуемой конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, этот метод нельзя использовать для восстановления подключения. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методы для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода подключается к удаленной конечной точки и затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="host">Имя удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Устанавливает подключение к удаленному узлу. Узел задается именем узла и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, таких как протокол TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое соединение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанного удаленного узла. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова метода <xref:System.Net.Sockets.Socket.Connect%2A> можно отправлять данные на удаленном устройстве с помощью <xref:System.Net.Sockets.Socket.Send%2A> метода или получение данных с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метод.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.Connect%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> синхронно взаимодействовать с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> датаграмм, поступившие с адрес, отличный от заданного по умолчанию будут потеряны. Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> параметр метода и набор сокет <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, или <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод выполняет блокировку, если только специально настроены, <xref:System.Net.Sockets.Socket.Blocking%2A> свойства `false` до вызова метода <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол с установлением соединения, такие как TCP и отключить блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> так, как требуется время для подключения. Протоколов без установления соединения не вызовет исключение, так как они просто установить удаленный узел по умолчанию. Можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Если ошибка возвращает WSAEWOULDBLOCK, подключение к удаленному узлу инициировала ориентированного на подключение <xref:System.Net.Sockets.Socket>, но еще не завершена успешно. Используйте <xref:System.Net.Sockets.Socket.Poll%2A> метод, чтобы определить, когда <xref:System.Net.Sockets.Socket> завершения подключения.  
  
 Если была включена поддержка IPv6 и <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> метод вызывается для подключения к узлу, который разрешается в IPv6 и IPv4-адреса, раньше IPv4-адрес, попытка установки соединения на IPv6, адресом будет. Это может влиять на задержки во времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы используете протокол с установлением соединения и не вызвал <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, основному поставщику услуг назначит локальный сетевой адрес и номер порта. Если вы используете протокол без установления соединения, поставщик услуг не присвоит локальный сетевой адрес и порт номер до завершения отправки или операции получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> повторно с требуемой конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, этот метод нельзя использовать для восстановления подключения. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методы для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода подключается к удаленной конечной точки и затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод начинает выполнение асинхронного запроса для подключения к удаленному узлу. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик событий\<SocketAsyncEventArgs > делегировать и присоединения обратный вызов, который <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событий.  
  
 Вызывающий должен установить <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойства <xref:System.Net.IPEndPoint> удаленного узла, для подключения к.  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.ConnectAsync%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> для обмена данными с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, будут потеряны любые датаграммы, поступившие от адрес, отличный от заданного по умолчанию. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод повторно с требуемой конечной точкой.  
  
 Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и присвоено вещания `true`. Если этого не сделать, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости, буфер может быть оказана которой атомарным образом будут отправляться на сокете после <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод завершается успешно. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть присвоено буфер, содержащий данные для отправки и <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> свойство должно быть присвоено число байтов данных для отправки из буфера. После того как соединение установлено, этот буфер данных отправляется.  
  
 Если вы используете протокол с установлением соединения и не следует вызывать <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, основному поставщику услуг назначит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если вы используете протокол без установления соединения, поставщик услуг не назначит локальной сети IP-адрес и порт номер до вызова метода <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> методы.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Вызывает метод <xref:System.NotSupportedException> Если семейства адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не в одном семействе адресов.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> при вызове этого метода, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, метод M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) начинает выполнение асинхронного запроса для подключение к удаленному узлу. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию, определяемое `socketType` и `protocolType` параметров.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик событий\<SocketAsyncEventArgs > делегировать и присоединения обратный вызов, который <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событий.  
  
 Вызывающий должен установить <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойства <xref:System.Net.IPEndPoint> удаленного узла, для подключения к.  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Если вы используете протокол без установления соединения, например UDP, у вас нет для вызова <xref:System.Net.Sockets.Socket.ConnectAsync%2A> до отправки и получения данных. Можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> для обмена данными с удаленным узлом. Если вы вызываете <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, будут потеряны любые датаграммы, поступившие от адрес, отличный от заданного по умолчанию. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод повторно с требуемой конечной точкой.  
  
 Если вы хотите установить удаленный узел по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и присвоено вещания `true`. Если этого не сделать, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости, буфер может быть оказана которой атомарным образом будут отправляться на сокете после <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод завершается успешно. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть присвоено буфер, содержащий данные для отправки и <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> свойство должно быть присвоено число байтов данных для отправки из буфера. После того как соединение установлено, этот буфер данных отправляется.  
  
 Если вы используете протокол с установлением соединения и не следует вызывать <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, основному поставщику услуг назначит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если вы используете протокол без установления соединения, поставщик услуг не назначит локальной сети IP-адрес и порт номер до вызова метода <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> методы.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Вызывает метод <xref:System.NotSupportedException> Если семейства адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не в одном семействе адресов.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> при вызове этого метода, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, подключается ли объект <see cref="T:System.Net.Sockets.Socket" /> к удаленному узлу в результате последней операции <see cref="Overload:System.Net.Sockets.Socket.Send" /> или <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> в результате последней операции был подключен к удаленному ресурсу; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` Свойство получает состояние подключения <xref:System.Net.Sockets.Socket> начиная с последней операции ввода-вывода. При возврате `false`, <xref:System.Net.Sockets.Socket> никогда не подключен, или уже не подключен.  
  
 Значение <xref:System.Net.Sockets.Socket.Connected%2A> свойство отражает состояние соединения, начиная с самой последней операции. Если вам нужно определить текущее состояние соединения, сделать вызов Send неблокирующем, нулевой длины. Если вызов успешно возвращается, или создает ошибки WAEWOULDBLOCK (10035), сокет по-прежнему подключен; в противном случае сокет не подключен.  
  
 При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> на сокете датаграмм протокола UDP (User), <xref:System.Net.Sockets.Socket.Connected%2A> свойство всегда возвращает `true`; тем не менее, это действие не приводит к изменению присущие без установления соединения характер UDP.  
  
   
  
## Examples  
 В следующем примере кода подключается к удаленной конечной точки проверки <xref:System.Net.Sockets.Socket.Connected%2A> свойство и проверяет текущее состояние соединения.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия текущего подключения; в противном случае — значение <see langword="false" />.</param>
        <summary>Закрывает подключение к сокету и позволяет повторно его использовать.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения, можно использовать этот метод, чтобы закрыть сокет. Этот метод завершается соединение и задает <xref:System.Net.Sockets.Socket.Connected%2A> свойства `false`. Тем не менее если `reuseSocket` является `true`, вы можете повторно использовать сокета.  
  
 Чтобы гарантировать, что все данные отправки и получения перед закрытием сокета, следует вызвать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом <xref:System.Net.Sockets.Socket.Disconnect%2A> метод.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Disconnect%2A> без предварительного вызова функции <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> равным `false` и укажите ненулевое значение ожидания, чтобы убедиться, что данные в очередь для передачи отправляется. <xref:System.Net.Sockets.Socket.Disconnect%2A> блокируется до отправки данных или пока не истечет заданное время ожидания. Если задать <xref:System.Net.Sockets.SocketOptionName.DontLinger> для `false` и укажите ноль интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет данные из выходной очереди.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создает сокет для синхронной связи и отправляет данные на удаленном узле. Затем он вызывает <xref:System.Net.Sockets.Socket.Shutdown%2A>, чтобы остановить отправки и получения действие, и <xref:System.Net.Sockets.Socket.Disconnect%2A>, чтобы закрыть подключение к сокету.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этого метода необходима операционная система Windows 2000 или более ранняя версия или будет создано исключение.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол с установлением соединения, вызвав <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> метод запрашивает запрос на отключение от удаленной конечной точки. Если задать <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> для `true` в `e` параметра сокета может быть повторно использован.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> не может быть равен null.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод `Dispose` по окончании использования класса <xref:System.Net.Sockets.Socket>. Метод `Dispose` оставляет класс <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии. После вызова метода `Dispose`, необходимо освободить все ссылки на <xref:System.Net.Sockets.Socket> , сборщик мусора мог освободить память, <xref:System.Net.Sockets.Socket> занимаемую.  
  
 Дополнительные сведения см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод `Dispose` перед освобождением последней ссылки на класс <xref:System.Net.Sockets.Socket>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> для освобождения управляемых и неуправляемых ресурсов; значение <see langword="false" /> для освобождения только неуправляемых ресурсов.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Net.Sockets.Socket" />, и при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` метод и <xref:System.Object.Finalize%2A> метод. `Dispose()` вызывает защищенный `Dispose(Boolean)` метод с `disposing` параметру присвоить `true`. <xref:System.Object.Finalize%2A> вызывает `Dispose` с `disposing` присвоено `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Net.Sockets.Socket>. Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />. Дополнительные сведения о том, как реализовать <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, см. в разделе [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />, см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [переопределение метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> выполнение фрагментации датаграмм протокола IP.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает фрагментацию датаграмм; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходима фрагментация датаграмм, когда их размер превышает максимальный передачи единицы (MTU) передачи данных. Датаграммы могут фрагментироваться отправляющем узле (все версии протокола IP) или промежуточным маршрутизатором (протокол Интернета версии 4 только). Если датаграмму должно быть фрагментировано и <xref:System.Net.Sockets.Socket.DontFragment%2A> параметр установлен, датаграмма отбрасывается и сообщение об ошибке сообщений протокола ICMP (Internet Control) отправляется обратно отправителю датаграммы.  
  
 Задание этого свойства на сокете протокола управления передачей (TCP) не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.DontFragment%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, является ли <see cref="T:System.Net.Sockets.Socket" /> сокетом с двойным режимом, используемым для IPv4 и IPv6.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> — сокет с двойным режимом. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Идентификатор конечного процесса, в котором создается дубликат ссылки сокета.</param>
        <summary>Дублирует ссылку сокета для конечного процесса и закрывает сокет для этого процесса.</summary>
        <returns>Ссылка сокета, передаваемая в конечный процесс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Целевой процесс следует использовать <xref:System.Net.Sockets.Socket.%23ctor%2A> для создания экземпляра повторяющиеся сокета.  
  
 При вызове метода <xref:System.Net.Sockets.Socket.%23ctor%2A> конструктор несколько раз с один и тот же байтовый массив в качестве аргумента для каждого вызова, вы создадите несколько управляемых <xref:System.Net.Sockets.Socket> экземпляры с тем же базовым сокетом. Этот подход не приветствуется.  
  
 Если процесс, создающий сокет использует асинхронные методы (<xref:System.Net.Sockets.Socket.BeginReceive%2A> или <xref:System.Net.Sockets.Socket.BeginSend%2A>), необходимо сначала установить процесс <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> значение true; в противном случае — значение сокет привязан к порту завершения создания процесса, который может привести к <xref:System.ArgumentNullException> исключение в целевом процессе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Параметр <paramref name="targetProcessID" /> не является допустимым идентификатором процесса. 
-или- 
Дубликат ссылки сокета не создан.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, может ли объект <see cref="T:System.Net.Sockets.Socket" /> производить отправку или прием широковещательных пакетов.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает использование широковещательных пакетов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Широковещательная рассылка ограничена определенной подсети и необходимо использовать протокол UDP (UDP). Для протокола IP версии 4 можно выполнить рассылку в локальной подсети путем отправки пакета по адресу 255.255.255.255; или можно использовать направленный широковещательный адрес, который является сетевой части адреса протокола Интернета (IP) с установлены все биты в часть узла. Например, если IP-адрес — 192.168.1.40 (это адрес класса C с маской подсети 255.255.255.0 — сетевой части — это первые три октета и часть узла – последний октет), направленный широковещательный адрес — 192.168.1.255.  
  
 Задание этого свойства на сокете протокола управления передачей (TCP) не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Эта функция применима только для сокета датаграмм.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно принимает попытку входящего подключения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</param>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом. Этот метод возвращает буфер, который содержит начальные данные для передачи.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>, необходимо создать метод обратного вызова, вызываемый методом <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает метод.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметр, чтобы получить <xref:System.Net.Sockets.Socket> на котором осуществляется попытка соединения. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод для успешного выполнения попытки подключения. `buffer` Параметр этой перегрузки содержит данные, полученные в вызове <xref:System.Net.Sockets.Socket.BeginAccept%2A> и `bytesTransferred` параметр содержит число байтов, переданных в вызове.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется, пока соединение находится в состоянии ожидания в очереди входящих подключений. <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод принимает входящие подключения и возвращает новый <xref:System.Net.Sockets.Socket> , можно использовать для отправки данных и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A> для создания и подключения сокета и принять начальные 10 байтов данных. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса. Количество передаваемых байтов и данные возвращаются в `buffer` и `bytesTransferred` параметры данного метода и отображаются на консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</summary>
        <returns>Объект<see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает метод. Он должен принимать `asyncResult` параметр, возвращаемый из <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметр, чтобы получить <xref:System.Net.Sockets.Socket> на котором осуществляется попытка соединения. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод для успешного выполнения попытки подключения.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется, пока соединение находится в состоянии ожидания в очереди входящих подключений. <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод принимает входящие подключения и возвращает новый <xref:System.Net.Sockets.Socket> , можно использовать для отправки данных и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершает асинхронный запрос и создает новый <xref:System.Net.Sockets.Socket> принимать входящий запрос на подключение. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в разделе [примеры кода сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. Дополнительные сведения см. в разделе "Примечания".</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</param>
        <param name="bytesTransferred">Количество переданных байтов.</param>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом. Этот метод возвращает буфер, который содержит начальные данные и число переданных байтов.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>, необходимо создать метод обратного вызова, вызываемый методом <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает метод. Он должен принимать `asyncResult` параметр, возвращаемый из <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметр, чтобы получить <xref:System.Net.Sockets.Socket> на котором осуществляется попытка соединения. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод для успешного выполнения попытки подключения. `buffer` Параметр этой перегрузки содержит данные, полученные в вызове <xref:System.Net.Sockets.Socket.BeginAccept%2A> и `bytesTransferred` параметр содержит число байтов, переданных в вызове.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется, пока соединение находится в состоянии ожидания в очереди входящих подключений. <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод принимает входящие подключения и возвращает новый <xref:System.Net.Sockets.Socket> , можно использовать для отправки данных и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A> для создания и подключения сокета и принять начальные 10 байтов данных. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса. Количество передаваемых байтов и данные возвращаются в `buffer` и `bytesTransferred` параметры данного метода и отображаются на консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает ожидающий асинхронный запрос на подключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> запускается блокировки метод, который завершает запрос на подключение асинхронную удаленного узла в <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginConnect%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginConnect%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметр, чтобы получить <xref:System.Net.Sockets.Socket> на котором осуществляется попытка соединения. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndConnect%2A> метод для успешного выполнения попытки подключения.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается попытка асинхронного подключения. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в разделе [примеры кода сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает ожидающий асинхронный запрос на разъединение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Метод блокируется до завершения disconnect. Сведения об асинхронных операциях см. в разделе Обзор асинхронного программирования, в библиотеке MSDN.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создает сокет для асинхронной связи и отправляет данные на удаленном узле. После отправки данных <xref:System.Net.Sockets.Socket.Shutdown%2A> вызывается для остановки отправки и действие receive. Затем <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> вызывается, чтобы начать запрос на разъединение. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndDisconnect%2A> для завершения асинхронного запроса. По завершении запроса <xref:System.Net.Sockets.Socket.Connected%2A> свойство запрашивается для тестирования ли сокет отключен.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.Net.WebException">Истекло время ожидания для запроса на разъединение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает отложенное асинхронное чтение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает отложенное асинхронное чтение.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод завершает асинхронную операцию чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginReceive%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> получить состояние объекта, переданного в <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод. Извлеките полученный <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndReceive%2A> метод для успешного завершения операции чтения и возвращает число считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод выполняет блокировку, пока данные недоступны. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать первую датаграмму, доступных во входном буфере сети. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndReceive%2A> метод считывает столько данных доступно до числа байтов, заданному в `size` параметр <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.EndReceive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Чтобы получить полученных данных, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult>и извлеките буфер, содержащийся в объекте результирующего состояния.  
  
 Чтобы отменить ожидающие <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершает отложенное асинхронное чтение. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в разделе [примеры кода сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Завершает отложенное асинхронное чтение.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод завершает асинхронную операцию чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginReceive%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> получить состояние объекта, переданного в <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод. Извлеките полученный <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndReceive%2A> метод для успешного завершения операции чтения и возвращает число считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод выполняет блокировку, пока данные недоступны. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать первую датаграмму, доступных во входном буфере сети. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndReceive%2A> метод считывает столько данных доступно до числа байтов, заданному в `size` параметр <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.EndReceive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Чтобы получить полученных данных, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult>и извлеките буфер, содержащийся в объекте результирующего состояния.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="endPoint">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <summary>Завершает отложенное асинхронное чтение с определенной конечной точки.</summary>
        <returns>Количество полученных байтов, если операция успешно выполнена. Возвращает значение 0, если операция завершилась неудачей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Метод завершает асинхронную операцию чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> получить состояние объекта, переданного в <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод. Извлеките полученный <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод для успешного завершения операции чтения и возвращает число считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Метод выполняет блокировку, пока данные недоступны. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет считывать первую датаграмму, доступных во входном буфере сети. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод считывает столько данных доступно до числа байтов, заданному в `size` параметр <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод будет немедленно завершен и вернет нуль байт. Чтобы получить полученных данных, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> и извлеките буфер, содержащийся в объекте результирующего состояния. Чтобы определить исходный узел, извлеките <xref:System.Net.EndPoint> и приведите его к <xref:System.Net.IPEndPoint>. Используйте <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> метод, чтобы получить IP-адрес и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> метод, чтобы получить номер порта.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершает отложенное асинхронное чтение из определенной <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="socketFlags">Поразрядное сочетание значений перечисления <see cref="T:System.Net.Sockets.SocketFlags" /> для принятого пакета.</param>
        <param name="endPoint">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Объект <see cref="T:System.Net.IPAddress" /> и интерфейс полученного пакета.</param>
        <summary>Завершает отложенное асинхронное чтение с определенной конечной точки. Этот метод также показывает больше информации о пакете, чем метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Количество полученных байтов, если операция успешно выполнена. Возвращает значение 0, если операция завершилась неудачей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до завершения удаления.  
  
 Для выполнения этой операции в синхронном режиме, используйте <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод.  
  
 Изучите `ipPacketInformation` вам необходимо знать, если датаграмма было отправлено с помощью одноадресный, многоадресный или широковещательный адрес.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> равно <see langword="null" />  
  
-или- 
 <paramref name="endPoint" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
        <returns>Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> Завершает асинхронную операцию отправки к работе <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginSend%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметр, чтобы получить отправляющий <xref:System.Net.Sockets.Socket>. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndSend%2A> метод для успешного завершения операции отправки и возвращает количество отправленных байтов.  
  
 Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSend%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndSend%2A> заблокируется, пока некоторые буфера было отправлено. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью передан, вызовите <xref:System.Net.Sockets.Socket.BeginSend%2A> метод опять же, изменение буфера, содержащего имеются неотправленные данные.  
  
 Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSend%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода Завершает отложенную операцию асинхронной передачи.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
        <returns>Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> Завершает асинхронную операцию отправки к работе <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginSend%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметр, чтобы получить отправляющий <xref:System.Net.Sockets.Socket>. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndSend%2A> метод для успешного завершения операции отправки и возвращает количество отправленных байтов.  
  
 Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSend%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndSend%2A> заблокируется, пока некоторые буфера было отправлено. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью передан, вызовите <xref:System.Net.Sockets.Socket.BeginSend%2A> метод опять же, изменение буфера, содержащего имеются неотправленные данные.  
  
 Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSend%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированных данного потока отменяется, если этот поток завершает работу. Отложенной асинхронной операции может завершиться ошибкой, если поток завершает работу до завершения операции.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной передачи файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> Завершает асинхронную операцию отправки к работе <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSendFile%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> объект, возвращаемый <xref:System.Net.Sockets.Socket.BeginSendFile%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметр, чтобы получить отправляющий <xref:System.Net.Sockets.Socket>. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndSendFile%2A> метод для успешного завершения операции отправки.  
  
 Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется, пока не будет отправлено датаграмм. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется, пока не будет отправлено всего файла. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключение сокета для асинхронной связи и начинается отправка файла «text.txt» асинхронно к удаленному узлу. Вызывает делегат обратного вызова <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи объекта <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной отправки в определенное местоположение.</summary>
        <returns>Если операция завершилась успешно — значение количества отправленных байтов; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> Завершает асинхронную операцию отправки к работе <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback> делегировать. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult> возвращаемые <xref:System.Net.Sockets.Socket.BeginSendTo%2A> методу в качестве параметра.  
  
 В методе обратного вызова, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметр, чтобы получить отправляющий <xref:System.Net.Sockets.Socket>. После получения <xref:System.Net.Sockets.Socket>, можно вызвать <xref:System.Net.Sockets.Socket.EndSendTo%2A> метод для успешного завершения операции отправки и возвращает количество отправленных байтов.  
  
 Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.EndSendTo%2A> заблокируется, пока не отправляются запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается операция асинхронной отправки в определенное расположение.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> привязку к порту только одного процесса.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает привязку только одного сокета к определенному порту; в противном случае — значение <see langword="false" />. По умолчанию используется <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2 и <see langword="false" /> для всех остальных версий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> — `false`, можно использовать несколько сокетов <xref:System.Net.Sockets.Socket.Bind%2A> метод для привязки к определенному порту; Однако только один из сокетов могут выполнять операции на сетевой трафик, отправляемый на порт. Попытка использовать более одного сокета <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> метод для привязки к конкретному порту, то тем более конкретные IP-адресом будет обрабатывать сетевой трафик, отправляемый на этот порт.  
  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> — `true`, первого использования <xref:System.Net.Sockets.Socket.Bind%2A> способ пытаются выполнить привязку к конкретному порту, независимо от адреса протокола Интернета (IP), будет выполнена успешно; все последующие использует <xref:System.Net.Sockets.Socket.Bind%2A> будет метод, чтобы попытаться выполнить привязку к этому порту восстановить исходное связанный сокет уничтожается.  
  
 Это свойство должно быть задано до <xref:System.Net.Sockets.Socket.Bind%2A> вызываемой; в противном случае <xref:System.InvalidOperationException> будет создано.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> вызван для этого объекта <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые классом <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Вызываемый метод завершения классом <xref:System.Net.Sockets.Socket.Close%2A> метод для закрытия <xref:System.Net.Sockets.Socket> и освободить ресурсы, связанные с <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-значение для экземпляра <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Целочисленное хэш-значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Метод GetHashCode Возвращает хэш-код данного экземпляра. Это значение может использоваться как ключ в хэш-таблицы.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение параметра <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде объекта.</summary>
        <returns>Объект, который представляет значение параметра. Когда для параметра <paramref name="optionName" /> установлено значение <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.LingerOption" />. Когда для параметра <paramref name="optionName" /> задано значение <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> или <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.MulticastOption" />. Когда для параметра <paramref name="optionName" /> задано любое другое значение, возвращаемое значение является целым числом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. Используйте этот перегруженный метод для получения <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, и <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> параметры. Для <xref:System.Net.Sockets.SocketOptionName.Linger> , используйте <xref:System.Net.Sockets.Socket> для `optionLevel` параметра. Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>, используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>. Если вы хотите задать значение любого из перечисленных выше параметров, используйте <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий код извлекает пример <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображает их на консоль.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
-или- 
 Для параметра <paramref name="optionName" /> было установлено неподдерживаемое значение <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Массив типа <see cref="T:System.Byte" />, который используется для отправки значения параметра.</param>
        <summary>Возвращает указанное значение параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде байтового массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. После успешного завершения этого метода массив, заданный параметром `optionValue` параметр содержит значение заданного объекта <xref:System.Net.Sockets.Socket> параметр.  
  
 Когда длину `optionValue` массива меньше, чем число байтов, необходимое для хранения значения указанной <xref:System.Net.Sockets.Socket> параметр, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Используйте этот перегруженный метод для всех сокетов, представленных логическими значениями или целых чисел.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий код извлекает пример <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображает их на консоль.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
-или- 
В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт. Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">Длина ожидаемого возвращаемого значения, указанная в байтах.</param>
        <summary>Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" /> в массиве.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, который содержит значение параметра сокета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` Параметр задает максимальный размер возвращаемого байтового массива. Если значение параметра требуется меньшее число байтов, массив будет содержать только то, что количество байтов. Если значение параметра требуется большее число байтов, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> вызовет <xref:System.Net.Sockets.SocketException>. Используйте этот перегруженный метод для всех сокетов, представленных логическими значениями или целых чисел.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий код извлекает пример <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображает их на консоль.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
-или- 
В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт. Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор операционной системы для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.IntPtr" />, представляющий дескриптор операционной системы для <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Значение <see cref="T:System.Int32" />, задающее код элемента управления для выполняемой операции.</param>
        <param name="optionInValue">Массив <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</param>
        <param name="optionOutValue">Массив <see cref="T:System.Byte" />, который содержит выходные данные, необходимые для операции.</param>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя цифровые коды элементов управления.</summary>
        <returns>Число байтов в параметре <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A> Метод предоставляет низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> экземпляра из <xref:System.Net.Sockets.Socket> класса. Дополнительные сведения см. в разделе [Функция WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) документации.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере сравниваются результаты fionread СПЕЦИФИКАЦИИ и доступное свойство.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на выполнение неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Значение <see cref="T:System.Net.Sockets.IOControlCode" />, задающее код элемента управления для выполняемой операции.</param>
        <param name="optionInValue">Массив типа <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</param>
        <param name="optionOutValue">Массив типа <see cref="T:System.Byte" />, который содержит выходные данные, возвращенные операцией.</param>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя перечисление <see cref="T:System.Net.Sockets.IOControlCode" />, чтобы указать коды элементов управления.</summary>
        <returns>Число байтов в параметре <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляет низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> экземпляра из <xref:System.Net.Sockets.Socket> класса. Дополнительные сведения см. в разделе [Функция WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) документации.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере сравниваются результаты вызова метода <xref:System.Net.Sockets.Socket.IOControl%2A> с <xref:System.Net.Sockets.IOControlCode.DataToRead> и <xref:System.Net.Sockets.Socket.Available%2A> свойство.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на выполнение неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, привязан ли объект <see cref="T:System.Net.Sockets.Socket" /> к конкретному локальному порту.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> привязан к локальному порту; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сокет считается связанной с локальным портом, явным образом связан, вызвав <xref:System.Net.Sockets.Socket.Bind%2A> метод, или неявно привязываемый путем вызова участников, например <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, использующий временный локальный порт (свободный порт больше, чем 1024, выбранного в операционной системе.) Серверы используют <xref:System.Net.Sockets.Socket.Bind%2A> метод для привязки к известный порт, таким образом, клиенты могут подключаться к ним.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.IsBound%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли объект <see cref="T:System.Net.Sockets.Socket" /> задерживать закрытие сокета при попытке отправки всех отложенных данных.</summary>
        <value>Объект <see cref="T:System.Net.Sockets.LingerOption" />, указывающий задержку при закрытии сокета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A> Свойство меняет способ отслеживания <xref:System.Net.Sockets.Socket.Close%2A> метода. Когда это свойство установлено, оно изменяет условия, при которых подключение может быть изменена Winsock. Сброс подключения можно по-прежнему происходит на основании поведение протокола IP.  
  
 Это свойство определяет продолжительность времени, подключения, ориентированного на подключение будет оставаться открытым после вызова <xref:System.Net.Sockets.Socket.Close%2A> Если продолжается отправка данных.  
  
 При вызове методов для отправки данных однорангового узла, эти данные помещается в выходной буфер сети. Это свойство может использоваться, чтобы убедиться, что эти данные отправляются на удаленный узел, прежде чем <xref:System.Net.Sockets.TcpClient.Close%2A> метод разрывает подключение.  
  
 Чтобы включить ожидание, создайте <xref:System.Net.Sockets.LingerOption> экземпляр, содержащий нужные значения и задайте <xref:System.Net.Sockets.Socket.LingerState%2A> свойство с данным экземпляром.  
  
 В следующей таблице описаны поведение <xref:System.Net.Sockets.Socket.Close%2A> метод для возможных значений параметра <xref:System.Net.Sockets.LingerOption.Enabled%2A> свойство и <xref:System.Net.Sockets.LingerOption.LingerTime%2A> хранимой в <xref:System.Net.Sockets.Socket.LingerState%2A> свойство.  
  
|LingerState.Enabled|LingerState.LingerTime|Поведение|  
|-------------------------|----------------------------|--------------|  
|`false` (отключено), значение по умолчанию|Время ожидания не применяется (по умолчанию).|Предпринимает попытку отправки ожидания данных, пока не истечет тайм-аут протокола IP-адрес по умолчанию.|  
|`true` (включено)|Ненулевое значение тайм-аута|Предпринимает попытку отправки ожидания данных, пока не истечет заданное время ожидания, и если попытка завершается неудачей, Winsock сбрасывает соединение.|  
|`true` (включено)|Нулевое время ожидания.|Отменяет все ожидающие данных. Для ориентированного на подключение сокета (например, TCP) Winsock сбрасывает соединение.|  
  
 Стек IP вычисляет период ожидания протокола IP-адрес по умолчанию для использования на основе времени кругового пути подключения. В большинстве случаев тайм-аут вычисленное стеком более релевантные, чем один определенный приложением. Это поведение по умолчанию для сокета при <xref:System.Net.Sockets.Socket.LingerState%2A> свойство не задано.  
  
 Когда <xref:System.Net.Sockets.LingerOption.LingerTime%2A> хранимой в <xref:System.Net.Sockets.Socket.LingerState%2A> свойство имеет значение больше таймаут по умолчанию для протокола IP-адрес, IP-адрес протокола по умолчанию время ожидания будет по-прежнему применяются, переопределяя.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.LingerState%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Максимальная длина очереди ожидающих подключений.</param>
        <summary>Устанавливает объект <see cref="T:System.Net.Sockets.Socket" /> в состояние прослушивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> вызывает, ориентированного на подключение <xref:System.Net.Sockets.Socket> ожидание входящих попыток подключения. `backlog` Указывает количество входящих подключений, которые могут быть поставлены в очередь условия приемки. Чтобы определить максимальное число подключений, можно указать, следует получить <xref:System.Net.Sockets.SocketOptionName.MaxConnections> значение. <xref:System.Net.Sockets.Socket.Listen%2A> не блокируется.  
  
 Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки. Используйте <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A> принять подключение из очереди.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.Listen%2A>, или <xref:System.Net.Sockets.Socket.Listen%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Параметр невыполненной работы ограничено разные значения в зависимости от операционной системы. Можно указать более высокое значение, но невыполненной работы будет ограничен в зависимости от операционной системы.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket> для прослушивания входящих подключений.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает локальную конечную точку.</summary>
        <value>Объект <see cref="T:System.Net.EndPoint" />, который объект <see cref="T:System.Net.Sockets.Socket" /> использует для взаимодействий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Свойство получает <xref:System.Net.EndPoint> , содержащий локальный IP-адрес и порт номер к которому вашей <xref:System.Net.Sockets.Socket> привязан. Необходимо привести это <xref:System.Net.EndPoint> для <xref:System.Net.IPEndPoint> до извлечения данные. Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> метод для извлечения локальной <xref:System.Net.IPAddress>и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> метод для извлечения номер локального порта.  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Свойство обычно задается после вызова <xref:System.Net.Sockets.Socket.Bind%2A> метод. Если предоставить системе назначить сокета локальный IP-адрес и номер порта, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> будет установлено после первой операции ввода-вывода. Для протоколов, ориентированного на подключение, первой операции ввода-вывода будет вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Для протоколов без установления соединения первой операции ввода-вывода может быть любой из отправки или принимать вызовы.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекает и отображает локальных и удаленных конечных точек.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, могут ли доставляться исходящие пакеты многоадресной рассылки в передающем приложении.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> получает исходящие пакеты многоадресной рассылки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многоадресная рассылка — масштабируемый метод для связи многие ко многим в Интернете. Процесс подписывается на адрес многоадресной рассылки; После этого любые пакеты, отправленные процессом, подписанных получаются любым другим процессом, подписка на адрес многоадресной рассылки.  
  
 Задание этого свойства на сокете протокола управления передачей (TCP) не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, используется ли поток <see cref="T:System.Net.Sockets.Socket" /> в алгоритме Nagle.</summary>
        <value>Значение <see langword="false" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует алгоритм Nagle; в противном случае — значение <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Алгоритм Nagle предназначена для уменьшения сетевого трафика, вызывая сокет для буферизации небольших пакетов и затем формировать и отправлять их в один пакет при определенных обстоятельствах. Пакет TCP состоит из 40 байт заголовка, а также отправляемых данных. При небольших пакетов данных отправляются с TCP, издержки, полученный в результате заголовке TCP может стать значительную часть сетевого трафика. В сильно загруженных сетях перегрузки, полученный в результате эти издержки может привести потери датаграмм и повторные отправки, а также время чрезмерного распространения, из-за перегрузки. Алгоритм Nagle запрещает отправку нового segmentswhen TCP новых исходящих данных поступает от пользователя, если все данные previouslytransmitted на соединение остается неподтвержденных.  
  
 Большинство приложений сети следует использовать алгоритм Nagle.  
  
 Задание этого свойства для сокета датаграмм протокола UDP (User) не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.NoDelay%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv4.</summary>
        <value>Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv4; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система поддерживает протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv6.</summary>
        <value>Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv6; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система поддерживает протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Время ожидания ответа, заданное в микросекундах.</param>
        <param name="mode">Одно из значений <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Определяет состояние объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Состояние объекта <see cref="T:System.Net.Sockets.Socket" />, основанное на значении режима опроса, переданного в параметре <paramref name="mode" />.  
  
 <list type="table"><listheader><term> Режим 
 </term><description> Возвращаемое значение 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>Значение <see langword="true" />, если был вызван метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> и подключение отложено; 
-или- 
 Значение <see langword="true" />, если данные доступны для чтения; 
-или- 
 Значение <see langword="true" />, если подключение закрыто, сброшено или завершено. 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>Значение <see langword="true" />, если обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и подключения завершились успешно; 
-или- 
 Значение <see langword="true" />, если данные могут быть посланы; 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>Значение <see langword="true" />, если не блокируется обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и попытка подключения завершилась неудачей; 
-или- 
 Значение <see langword="true" />, если не установлен объект <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> и доступны экстренные данные; 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A> Метод будет проверять состояние <xref:System.Net.Sockets.Socket>. Укажите <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> для `selectMode` параметр, чтобы определить, если <xref:System.Net.Sockets.Socket> доступен для чтения. Укажите <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> на предмет <xref:System.Net.Sockets.Socket> доступен для записи. Используйте <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> для обнаружения ошибки. <xref:System.Net.Sockets.Socket.Poll%2A> блокирует выполнение до заданного периода времени, измеряемый в `microseconds`, истекает. Задайте `microSeconds` параметра отрицательное целое число, если вы хотите бесконечно ожидать ответа. Если вы хотите проверять состояние нескольких сокетов, можно использовать <xref:System.Net.Sockets.Socket.Select%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, таким как нарушение сетевого кабеля, или удаленным узлом неправильное отключение. Необходимо предпринять для отправки и получения данных, чтобы обнаружить ошибки такого рода.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создает сокет, подключается к серверу и использует <xref:System.Net.Sockets.Socket.Poll%2A> для проверки состояния сокета.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="mode" /> не является одним из значений <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. примечания ниже.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип протокола объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> Свойство задается при <xref:System.Net.Sockets.Socket> создается и указывает протокол, используемый, <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Следующий код отображает пример <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <summary>Возвращает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр буфера и возвращает количество успешно прочитанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется только для обеспечения приемного буфера. По умолчанию равно 0, размер по умолчанию для длины параметра буфера, смещение буфера и <xref:System.Net.Sockets.SocketFlags> по умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, вплоть до размера буфера. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первой датаграммы из очереди из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffer` параметра `buffer` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода получает данные из подключенного <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в параметр буферов и возвращает количество успешно прочитанных байтов. Можно вызвать из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется предоставление одного или нескольких приемных буферов.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла соединения, установленного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, вплоть до размера буфера. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первую датаграмму из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffers` параметра `buffers` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
 **Примечание** данный член генерирует сведения трассировки, при включении трассировки сети в приложении. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр буфера и возвращает количество успешно прочитанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется только для обеспечения приемного буфера и необходимого <xref:System.Net.Sockets.SocketFlags>. Смещение буфера по умолчанию равно 0, и размер по умолчанию длина параметра байтов.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны. Если вы находитесь в режиме без блокировки, и нет данных в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите вашей операции получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных вплоть до размера буфера. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первую датаграмму из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffer` параметра `buffer` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задается буфер данных, и <xref:System.Net.Sockets.SocketFlags> для приема данных на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в `buffers` параметра и возвращает число успешно прочитанных байтов. Можно вызвать из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется предоставление одного или нескольких приемных буферов. <xref:System.Net.Sockets.SocketFlags> По умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла соединения, установленного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызова вызывает исключение <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, вплоть до размера буфера. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первую датаграмму из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffers` параметра `buffers` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить данные на подключенный объект <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.  
  
-или- 
 Значение <paramref name="buffers" />. Отсчет равен нулю.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод читает данные в `buffer` параметра и возвращает число успешно прочитанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется только для обеспечения приемный буфер, количество байтов, которые вы хотите получать и необходимого <xref:System.Net.Sockets.SocketFlags>.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите вашей операции получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, вплоть до выбранного числа байтов, заданному параметром `size` параметр. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первой датаграммы из очереди из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffer` параметра `buffer` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующие получает данные, найденные в `buffer`и указывает <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в `buffers` параметра и возвращает число успешно прочитанных байтов. Можно вызвать из сокетов, ориентированных на подключение и без установления соединения.  
  
 Эта перегрузка требуется предоставление одного или нескольких приемных буферов. <xref:System.Net.Sockets.SocketFlags> По умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла соединения, установленного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызова вызывает исключение <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, вплоть до размера буфера. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> прочитает первой датаграммы из очереди из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffers` параметра `buffers` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.  
  
-или- 
 Значение <paramref name="buffers" />. Отсчет равен нулю.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер с указанной позиции смещения, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр буфера и возвращает количество успешно прочитанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение и без установления соединения.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Произошла ошибка при попытке доступа к сокету. См. в разделе "Примечания" ниже. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, число байтов, указанное в параметре size. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первой датаграммы из очереди из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffer` параметра `buffer` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода указывает буфер данных, смещение, размер и флаг сокета перед получением данных на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр буфера и возвращает количество успешно прочитанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение и без установления соединения.  
  
 Если вы используете протокол с установлением соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> для установления подключения к удаленному узлу, или <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения до вызова метода <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Метод только считывает данные, поступающие из удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если вы используете протокол без установления соединения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит вам получать данные, поступающие от любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод выполняет блокировку, пока данные недоступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.Receive%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Произошла ошибка при попытке доступа к сокету. См. в разделе "Примечания" ниже. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Если вы используете, ориентированного на подключение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> метод считывает столько доступных данных, число байтов, указанное в параметре size. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.Receive%2A> метод будет немедленно завершен и вернет нуль байт.  
  
 Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> прочитает первой датаграммы из очереди из адреса назначения, указанного в <xref:System.Net.Sockets.Socket.Connect%2A> метод. Если датаграмма превышает размер `buffer` параметра `buffer` заполняется с первой части сообщения, избыточные данные теряются и <xref:System.Net.Sockets.SocketException> возникает исключение.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса, чтобы получить данные из подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Используется метод на подключения сокетов или сокеты привязанного без установления соединения и используется для считывания входящих данных. Должен быть известен локальный адрес сокета.  
  
 Для привязанных сокетов, без установления соединения эта функция ограничивает адреса, с которых принимаются полученных сообщений. Функция возвращает только сообщения с удаленного адреса, указанного в соединении. Отброшенных сообщений из других адресов.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Свойство `e` параметр предоставляет поставщик услуг окно сокетов с дополнительной информацией о запрос на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> имеет значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> имеет значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Для сокетов стиле потока байтов входящие данные помещаются в буфер, пока буфер заполняется, соединение закрывается или внутренне помещенные в буфер данные закончатся.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер до общий размер буфера, связанных с `e` параметра. Если сообщение является больше размера буфера, буфер заполняется в первой части сообщения.  
  
 Для сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> метода можно указать нормальном завершении виртуальный канал в одном из двух способов, которые зависят от того, является ли сокет байтового потока или ориентированный на сообщения. Для потоков байтов читаемых ноль байтов указывает нормального закрытия и что байты будет постоянно считывать. Для сокетов, ориентированных на сообщения, в которых сообщение ноль байтов является допустимый, <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> набора в машинный код ошибки Winsock WSAEDISCON (10101) используется для указания нормального закрытия. В любом случае <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> значение собственного WSAECONNRESET Winsock код ошибки (10054) указывает путем прерывания close.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент был недопустимым. Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы. Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, задающее размер приемного буфера объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.Int32" />, который содержит значение размера приемного буфера в байтах. Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чем больше размер буфера потенциально уменьшает количество пустых подтверждений приема (TCP-пакетов которых отсутствуют данные), но также может привести к задержкам распознавания трудностей при подключении. Попробуйте увеличить размер буфера при передаче больших файлов, или вы используете высокой пропускной способностью и высокой задержкой подключения (например, вспомогательные широкополосной связи поставщика.)  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции установки, меньше 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает датаграмму и сохраняет конечную точку источника.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Принимает датаграмму в буфер данных и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Метод читает данные в `buffer` параметр, возвращает количество байтов, считанных успешно и фиксирует конечную точку удаленного узла, с которого было отправлено данных. Этот метод полезен в том случае, если вы планируете получать датаграмм без установления соединения с неизвестного узла или нескольких узлах.  
  
 Эта перегрузка требуется только для обеспечения receive `buffer`и <xref:System.Net.EndPoint> , представляющий удаленный узел. Смещение буфера по умолчанию равно 0. Размер по умолчанию длина `buffer` параметр и `socketFlags` по умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, необходимо явно связать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод. Если вы этого не сделать, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 При работе с протоколами <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первую датаграмму в буфер локальной сети. Если датаграмма превышает размер `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет заполнять `buffer` с максимально возможную часть сообщения, а затем throw <xref:System.Net.Sockets.SocketException>. Если вы используете ненадежный протокол, избыточные данные будут потеряны. Если вы используете протокол надежного, избыточные данные будут храниться поставщиком услуг, и его можно получить, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большой буфер.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод выполняет блокировку, пока данные недоступны. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Несмотря на то что <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без установления соединения, можно использовать также протокол ориентированного на подключение. Если вы решили сделать это, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принять входящий запрос удаленного узла на подключение, вызвав <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод, вы получите <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет игнорировать `remoteEP` параметр и получать только данные из подключенных или удаленный узел по умолчанию.  
  
 С помощью сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько доступных данных до размера `buffer`. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет немедленно завершен и вернет нуль байт.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> должно совпадать с <xref:System.Net.Sockets.AddressFamily> из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимает без установления соединения датаграмму с удаленного узла.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Принимает датаграмму в буфер данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Метод читает данные в `buffer` параметр, возвращает количество байтов, считанных успешно и фиксирует конечную точку удаленного узла, с которого было отправлено данных. Этот метод полезен в том случае, если вы планируете получать датаграмм без установления соединения с неизвестного узла или нескольких узлах.  
  
 Эта перегрузка требуется только для обеспечения приемного буфера, необходимого <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint> , представляющий удаленный узел. По умолчанию смещение равно 0 и размер по умолчанию для длины параметра буфера.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, необходимо явно связать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод. Если вы этого не сделать, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 При работе с протоколами <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первую датаграмму в буфер локальной сети. Если датаграмма превышает размер `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет заполнять `buffer` с максимально возможную часть сообщения, а затем throw <xref:System.Net.Sockets.SocketException>. Если вы используете ненадежный протокол, избыточные данные будут потеряны. Если вы используете протокол надежного, избыточные данные будут храниться поставщиком услуг, и его можно получить, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большой буфер.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод выполняет блокировку, пока данные недоступны. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Несмотря на то что <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без установления соединения, можно использовать также протокол ориентированного на подключение. Если вы решили сделать это, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принять входящий запрос удаленного узла на подключение, вызвав <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод, вы получите <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет игнорировать `remoteEP` параметр и получать только данные из подключенных или удаленный узел по умолчанию.  
  
 С помощью сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько доступных данных до размера `buffer`. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет немедленно завершен и вернет нуль байт.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> должно совпадать с <xref:System.Net.Sockets.AddressFamily> из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимает без установления соединения датаграмму с удаленного узла. <xref:System.Net.Sockets.SocketFlags> передаваемые <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Получает указанное число байтов во входной буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Метод читает данные в `buffer` параметр, возвращает количество байтов, считанных успешно и фиксирует конечную точку удаленного узла, с которого было отправлено данных. Этот метод полезен в том случае, если вы планируете получать датаграмм без установления соединения с неизвестного узла или нескольких узлах.  
  
 Эта перегрузка требуется только для обеспечения приемный буфер, количество байтов, которые вы хотите получать необходимые <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint> , представляющий удаленный узел. Смещение буфера по умолчанию равно 0.  
  
 При работе с протоколами <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первую датаграмму в буфер локальной сети. Если датаграмма превышает размер `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет заполнять `buffer` с максимально возможную часть сообщения, а затем throw <xref:System.Net.Sockets.SocketException>. Если вы используете ненадежный протокол, избыточные данные будут потеряны. Если вы используете протокол надежного, избыточные данные будут храниться поставщиком услуг, и его можно получить, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большой буфер.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод выполняет блокировку, пока данные недоступны. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Несмотря на то что <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без установления соединения, можно использовать также протокол ориентированного на подключение. Если вы решили сделать это, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принять входящий запрос удаленного узла на подключение, вызвав <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод, вы получите <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет игнорировать `remoteEP` параметр и получать только данные из подключенных или удаленный узел по умолчанию.  
  
 С помощью сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных доступно до числа байтов, заданному параметром `size` параметр. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет немедленно завершен и вернет нуль байт.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, необходимо явно связать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод. Если вы этого не сделать, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> должно совпадать с <xref:System.Net.Sockets.AddressFamily> из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимает без установления соединения датаграмму с удаленного узла. Размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает длину <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Получает указанное число байтов данных в заданном расположении буфера данных с использованием определенного параметра <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Метод читает данные в `buffer` параметр, возвращает количество байтов, считанных успешно и фиксирует конечную точку удаленного узла, с которого было отправлено данных. Этот метод полезен в том случае, если вы планируете получать датаграмм без установления соединения с неизвестного узла или нескольких узлах.  
  
 При работе с протоколами <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первую датаграмму в буфер локальной сети. Если датаграмма превышает размер `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет заполнять `buffer` с максимально возможную часть сообщения, а затем throw <xref:System.Net.Sockets.SocketException>. Если вы используете ненадежный протокол, избыточные данные будут потеряны. Если вы используете протокол надежного, избыточные данные будут храниться поставщиком услуг, и его можно получить, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большой буфер.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод выполняет блокировку, пока данные недоступны. Если вы находитесь в режиме без блокировки, и нет данных, доступных в в буфере стек протокола <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> немедленно завершится и вызывать метод <xref:System.Net.Sockets.SocketException>. Можно использовать <xref:System.Net.Sockets.Socket.Available%2A> свойства, чтобы определить, если данные будут доступны для чтения. Когда <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Несмотря на то что <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без установления соединения, можно использовать также протокол ориентированного на подключение. Если вы решили сделать это, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принять входящий запрос удаленного узла на подключение, вызвав <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод, вы получите <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет игнорировать `remoteEP` параметр и получать только данные из подключенных или удаленный узел по умолчанию.  
  
 С помощью сокетов, ориентированных на подключение <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных доступно до количество байтов, заданному параметром `size` параметр. Если удаленный узел завершает работу <xref:System.Net.Sockets.Socket> соединения с <xref:System.Net.Sockets.Socket.Shutdown%2A> получено метод и все доступные данные <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет немедленно завершен и вернет нуль байт.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, необходимо явно связать <xref:System.Net.Sockets.Socket> в локальную конечную точку с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метод. Если вы этого не сделать, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> должно совпадать с <xref:System.Net.Sockets.AddressFamily> из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимает без установления соединения датаграмму с удаленного узла. Смещение, размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Метод используется главным образом для получения данных без установления соединения сокета. Должен быть известен локальный адрес сокета.  
  
 Вызывающий должен установить <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойства <xref:System.Net.IPEndPoint> удаленного узла, из которого должны быть получены данные.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Свойство `e` параметр предоставляет поставщик услуг окно сокетов с дополнительной информацией о запрос на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Для сокетов, ориентированных на сообщения входящее сообщение помещается в буфер до общий размер буфера. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> И <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> свойства определяют, где в буфере данных размещается и объема данных.  
  
 Для сокетов стиле потока байтов входящие данные помещаются в буфер, пока буфер заполняется, соединение закрывается или внутренне помещенные в буфер данные закончатся. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> И <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> свойства определяют, где в буфере данных размещается и объема данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> сохраняет адрес и сведения об интерфейсе.</param>
        <summary>Получает указанное число байтов данных в указанное расположение буфера данных с помощью заданного <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку и сведения о пакете.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Метод читает данные в `buffer` параметр, возвращает количество байтов, считанных успешно и фиксирует конечную точку удаленного узла, с которого было отправлено данных, а также информация о полученном пакете.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Метод используется главным образом для получения данных сообщения без установления соединения сокета. Должен быть известен локальный адрес сокета. Этот метод может использоваться только с помощью датаграмм и незащищенные сокеты. Необходимо инициализировать с помощью тип сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw> перед вызовом этого метода. Это можно сделать, когда сокет создается с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Для сокетов, ориентированных на сообщения, входящие сообщения помещаются в `buffer` параметр вплоть до общего размера, указанного в `size` параметра. `offset` Параметр определяет, где в `buffer` данные сохраняются. Фактический объем данных помещаются в `buffer` возвращается <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Метод автоматически задает метод <xref:System.Net.Sockets.SocketOptionName.PacketInformation> параметром для сокета `true` в первый раз, он вызывается для заданного <xref:System.Net.Sockets.Socket>. Тем не менее возвращенный <xref:System.Net.Sockets.IPPacketInformation> объекта будет действителен только для пакетов, которые поступают на локальном компьютере после установки параметра сокета. Если сокет отправляется пакетов между, когда он привязан к локальной конечной точки (явно, параметром <xref:System.Net.Sockets.Socket.Bind%2A> метода или неявно с помощью одного из <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, или <xref:System.Net.Sockets.Socket.SendToAsync%2A> методов) и его первый вызов <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> вызывает метод, чтобы <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод возвращает недопустимый <xref:System.Net.Sockets.IPPacketInformation> объекты для этих пакетов.  
  
 Чтобы убедиться, что все <xref:System.Net.Sockets.IPPacketInformation> объекты являются допустимыми, приложение должно установить <xref:System.Net.Sockets.SocketOptionName.PacketInformation> параметром для сокета `true` прежде, чем он привязан к локальной конечной точки с помощью <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> метод.  
  
 Приложение может проверить `ipPacketInformation` параметра, если он должен знать, если датаграмма было отправлено с помощью одноадресный, многоадресный или широковещательный адрес.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> должно совпадать с <xref:System.Net.Sockets.AddressFamily> из <xref:System.Net.EndPoint> используется в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
\- или - 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Платформа .NET Framework выполняется на 64-разрядном процессоре AMD.  
  
-или- 
Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Метод используется главным образом для получения данных сообщения без установления соединения сокета. Должен быть известен локальный адрес сокета. Этот метод может использоваться только с помощью датаграмм и незащищенные сокеты. Необходимо инициализировать с помощью тип сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw> перед вызовом этого метода. Это можно сделать, когда сокет создается с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Вызывающий должен установить <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойства <xref:System.Net.IPEndPoint> удаленного узла, из которого должны быть получены данные.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Для сокетов, ориентированных на сообщения входящее сообщение помещается в буфер до общий размер буфера. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> И <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> свойства определяют, где в буфере данных размещается и объема данных.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Автоматически задает метод <xref:System.Net.Sockets.SocketOptionName.PacketInformation> параметром для сокета `true` в первый раз, он вызывается для заданного <xref:System.Net.Sockets.Socket>. Тем не менее <xref:System.Net.Sockets.IPPacketInformation> объекта будет действителен только для пакетов, которые поступают на локальном компьютере после установки параметра сокета. Если сокет отправляется пакетов между, когда сокет привязан к локальной конечной точки (явно, параметром <xref:System.Net.Sockets.Socket.Bind%2A> метода или неявно с помощью одного из <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, или <xref:System.Net.Sockets.Socket.SendToAsync%2A> методов) и первый вызов <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>вызывает метод, чтобы <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> метода приведет к недопустимый <xref:System.Net.Sockets.IPPacketInformation> объекты для этих пакетов.  
  
 Чтобы убедиться, что все <xref:System.Net.Sockets.IPPacketInformation> объекты являются допустимыми, приложение должно установить <xref:System.Net.Sockets.SocketOptionName.PacketInformation> параметром для сокета`true` прежде, чем он привязан к локальной конечной точки с помощью <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> метод.  
  
 Приложение может проверить полученный в результате <xref:System.Net.Sockets.IPPacketInformation> объекты, если ей надо знать, если датаграмма было отправлено с помощью одноадресный, многоадресный или широковещательный адрес.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Receive" /> истечет время тайм-аута.</summary>
        <value>Значение времени ожидания в миллисекундах. По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется к синхронным <xref:System.Net.Sockets.Socket.Receive%2A> только вызовы. Если Превышен период ожидания, <xref:System.Net.Sockets.Socket.Receive%2A> метод вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает удаленную конечную точку.</summary>
        <value>Объект <see cref="T:System.Net.EndPoint" />, с которым взаимодействует объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойство получает <xref:System.Net.EndPoint> , содержащий удаленный IP-адрес и порт номер к которому <xref:System.Net.Sockets.Socket> подключен. Если вы используете протокол без установления соединения, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> содержит удаленный IP-адрес по умолчанию и номер порта с помощью которого <xref:System.Net.Sockets.Socket> будут обмениваться данными. Необходимо привести это <xref:System.Net.EndPoint> для <xref:System.Net.IPEndPoint> до извлечения данные. Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> метод для извлечения удаленного <xref:System.Net.IPAddress>и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> метод для извлечения номер удаленного порта.  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Устанавливается после вызова <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.Connect%2A>. При попытке доступа к этому свойству в более ранних версиях <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекает и отображает локальных и удаленных конечных точек.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="checkRead"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства чтения.</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства ведения записи.</param>
        <param name="checkError"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки ошибок.</param>
        <param name="microSeconds">Значение времени ожидания в миллисекундах. Значение -1 указывает на бесконечное время ожидания.</param>
        <summary>Определяет состояние одного или нескольких сокетов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> — Это статический метод, который определяет состояние одного или нескольких <xref:System.Net.Sockets.Socket> экземпляров. Необходимо поместить один или несколько сокетов в <xref:System.Collections.IList> перед использованием <xref:System.Net.Sockets.Socket.Select%2A> метод. Проверить для удобства чтения, вызвав <xref:System.Net.Sockets.Socket.Select%2A> с <xref:System.Collections.IList> как `checkRead` параметр. Чтобы проверить сокетов на возможность, используйте `checkWrite` параметра. Для обнаружения условий возникновения ошибок, используйте `checkError`. После вызова метода <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> будет заполняться только этих сокетов, которые удовлетворяют условиям.  
  
 Если вы находитесь в состояние прослушивания, удобства чтения означает, что вызов <xref:System.Net.Sockets.Socket.Accept%2A> успешно. Если вы уже приняли соединения, удобства чтения означает, что данные доступны для чтения. В этом случае все операции приема успешно. Можно также указать читаемость, ли удаленного <xref:System.Net.Sockets.Socket> завершил подключение; в этом случае вызов <xref:System.Net.Sockets.Socket.Receive%2A> немедленно, вернет нуль байтов, возвращаемых.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> Возвращает, если хотя бы один из сокетов интерес (сокетов в `checkRead`, `checkWrite`, и `checkError` перечислены) удовлетворяющий указанным требованиям, или `microSeconds` параметр превышен, какое событие произойдет первым. Параметр `microSeconds` значение -1 указывает на бесконечное время ожидания.  
  
 При внесении неблокирующем вызов <xref:System.Net.Sockets.Socket.Connect%2A>, удобства ведения записи означает, что вы успешно подключились. Если у вас уже есть соединение, установленное, удобства ведения записи означает, что все передачи успешно операций.  
  
 Если вы выполнили вызов без блокировки для <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` параметр определяет сокетов, которые не были успешно подключены.  
  
> [!NOTE]
>  Используйте <xref:System.Net.Sockets.Socket.Poll%2A> метод, если вы хотите определить состояние из одного <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, таким как нарушение сетевого кабеля, или удаленным узлом неправильное отключение. Необходимо предпринять для отправки и получения данных, чтобы обнаружить ошибки такого рода.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.Select%2A> чтобы определить, какие прослушивающих сокетов запрос подключения.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="checkRead" /> имеет значение <see langword="null" /> или является пустым.  
  
- и - 
Параметр <paramref name="checkWrite" /> имеет значение <see langword="null" /> или является пустым. 
- и - 
Параметр <paramref name="checkError" /> имеет значение <see langword="null" /> или является пустым.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> DAL и возвращает количество успешно переданных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов ориентированного на подключение и без установления соединения.  
  
 Эта перегрузка требует буфер, содержащий данные, которые вы хотите отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0, смещение буфера по умолчанию равно 0 и число байтов для отправки значения по умолчанию размер буфера.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> заблокируется, пока все байты в буфере отправляются, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем число байтов в буфере. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение отправляет байты в буфере. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется передача данных на подключенный объект <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов ориентированного на подключение и без установления соединения.  
  
 Эта перегрузка требует по крайней мере один буфер, содержащий данные, которые вы хотите отправить.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> заблокируется, пока все байты в буфере отправляются, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем число байтов в буфере. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение отправляет байты в буфере. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> DAL и возвращает количество успешно переданных байтов. <xref:System.Net.Sockets.Socket.Send%2A> Метод может использоваться для протоколов ориентированного на подключение и без установления соединения.  
  
 Эта перегрузка требует буфер, содержащий данные, необходимые для отправки и побитовое сочетание <xref:System.Net.Sockets.SocketFlags>. Смещение буфера по умолчанию равно 0 и число байтов для отправки значения по умолчанию размер буфера. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` значение параметра, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> заблокируется, пока все байты в буфере отправляются, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем число байтов в буфере. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Необходимо убедиться, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется передача данных на подключенный объект <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка требует по крайней мере один буфер, содержащий данные, которые вы хотите отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketFlags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> заблокируется, пока все байты в буфере отправляются, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем число байтов в буфере. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение отправляет байты в буфере. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> DAL и возвращает количество успешно переданных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов ориентированного на подключение и без установления соединения.  
  
 Эта перегрузка требует буфер, содержащий данные, необходимые для отправки, число байтов для отправки сообщений и битовую комбинацию любого <xref:System.Net.Sockets.SocketFlags>. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A> метод. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 С помощью протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> будут блокироваться до момента отправки запрошенное число байт, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем количество запрошенных байтов. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Необходимо убедиться, что размер не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода отправляет данные, находящиеся в буфере, с указанием <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="size" /> меньше 0 или превышает размер буфера.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Сбой операционной системы при доступе к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка требует по крайней мере один буфер, содержащий данные, которые вы хотите отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketFlags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A> метод, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> заблокируется, пока все байты в буфере отправляются, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем число байтов в буфере. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение отправляет байты в буфере. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Отправляет указанное количество байтов данных в подключенный <see cref="T:System.Net.Sockets.Socket" />, начиная с заданного смещения и используя заданный параметр <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> DAL и возвращает количество успешно переданных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов ориентированного на подключение и без установления соединения.  
  
 В этой перегрузке, если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A>, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Необходимо также убедиться, что размер не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> будут блокироваться до момента отправки запрошенное число байт, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем количество запрошенных байтов. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода указывает буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных на подключенный <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, начиная с указанного смещения и используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> DAL и возвращает количество успешно переданных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов ориентированного на подключение и без установления соединения.  
  
 В этой перегрузке, если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и план для отправки данных на несколько различных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A>, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Необходимо использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже в том случае, когда будет установлено удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию, перед вызовом метода <xref:System.Net.Sockets.Socket.Send%2A> путем обращения к методу <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Необходимо также убедиться, что размер не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.Send%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.Send%2A> будут блокироваться до момента отправки запрошенное число байт, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если превышено значение времени ожидания, <xref:System.Net.Sockets.Socket.Send%2A> вызов вызовет <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно даже если он отправляет меньше, чем количество запрошенных байтов. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Успешная отправка не означает, что данные было успешно доставлено. Если буфер не доступен в транспортной системы для хранения передаваемых данных, блокирует отправку, если сокет находится в неблокирующем режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода указывает буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных на подключенный <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Метод используется для записи выходных данных из одного или нескольких буферов на сокете, ориентированного на подключение. Этот метод также можно, однако без установления соединения сокеты, содержащие указанный удаленный узел операции подключения.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Метод запускает операцию асинхронной передачи удаленного узла, заданного в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> имеет значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> имеет значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.SendAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Метод вызовет исключение, если сначала не вызывается <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Вызов <xref:System.Net.Sockets.Socket.SendAsync%2A> метод дает возможность отправлять данные в отдельном потоке.  
  
 Для сокетов, ориентированных на сообщения не превышает максимальный размер сообщения основного поставщика услуг Windows sockets. Если данные слишком длинное атомарным образом проходить через основному поставщику услуг, данные не передаются и <xref:System.Net.Sockets.Socket.SendAsync%2A> вызывает метод <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> присваивается собственный код ошибки Winsock WSAEMSGSIZE (10040).  
  
 Обратите внимание, что успешное выполнение <xref:System.Net.Sockets.Socket.SendAsync%2A> метод не означает, что данные был успешно доставлен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы. Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Объект <see cref="T:System.Net.Sockets.Socket" /> уже не подключен или он был получен посредством метода <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> или <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее размер буфера передачи объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.Int32" />, который содержит значение размера буфера передачи в байтах. Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чем больше размер буфера может привести к задержкам распознавания трудностей при подключении. Попробуйте увеличить размер буфера при передаче больших файлов, или вы используете высокой пропускной способностью и высокой задержкой подключения (например, вспомогательные широкополосной связи поставщика.)  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции установки, меньше 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет синхронную передачу файла и дополнительных данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему. Этот параметр может иметь значение <see langword="null" />.</param>
        <summary>Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг передачи <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` подключенный сокет. `flags` Значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) и `preBuffer` и `postBuffer` параметры по умолчанию `null`. Если `fileName` находится в локальном каталоге, он может быть идентифицирован с помощью только имя файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (».. \\\myfile.txt») и имена общих ресурсов UNC («\\\\\\\shared directory\\\myfile.txt»), поддерживаются. Если файл не найден, исключение <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 Этот метод использует `TransmitFile` найти функцию в Windows Sockets 2 API. Дополнительные сведения о `TransmitFile` функция и его флаги, см. в разделе [Windows Sockets](/windows/desktop/WinSock/) документации.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. <xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать для обоих ориентированного на подключение, а также для протоколов без установления соединения.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> вызывает <xref:System.Net.Sockets.SocketException> исключение. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.SendFile%2A> блокирует работу до передачи файла. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> может успешно завершиться до передачи всего файла. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.SendFile%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключение сокета и затем отправляет файл на удаленный узел. Файл «test.txt» находится в корневом каталоге локального компьютера.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="preBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="postBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="flags">Одно или несколько значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Отправляет файл <paramref name="fileName" /> и буферы данных в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанное значение <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку необходимо указать имя файла для отправки и побитовое сочетание <xref:System.Net.Sockets.TransmitFileOptions> значения. `preBuffer` Параметр содержит все данные, должен предшествовать файл. `postBuffer` содержит данные, которые вы хотите изучить файл. Если `fileName` находится в текущем рабочем каталоге, он может быть идентифицирован с помощью только имя файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (».. \\\myfile.txt») и имена общих ресурсов UNC («\\\\\\\shared directory\\\myfile.txt»), поддерживаются.  
  
 `flags` Параметр предоставляет поставщик услуг сокетов окно с дополнительными сведениями о передаче файла. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует `TransmitFile` найти функцию в Windows Sockets 2 API. Дополнительные сведения о `TransmitFile` функция и его флаги, см. в разделе [Windows Sockets](/windows/desktop/WinSock/) документации.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A> метод. <xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать для обоих ориентированного на подключение, а также для протоколов без установления соединения.  
  
 Если вы используете протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода; в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> вызывает <xref:System.Net.Sockets.SocketException>. Если вы используете протокол с установлением соединения, необходимо использовать <xref:System.Net.Sockets.Socket.Connect%2A> установления подключения к удаленному узлу, или использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол с установлением соединения <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется, пока не будет отправлено всего файла. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> может успешно завершиться до передачи всего файла. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.SendFile%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключение сокета. Файл «test.txt» находится в корневом каталоге локального компьютера. В этом примере мы Создание пребуфер и значение postbuffer данных и отправлять их на удаленный узел с файлом. Значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions> используются.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Операционной системой не является Windows NT или более поздняя версия.  
  
-или- 
Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Выполняет асинхронную передачу набора файла или буферов данных в памяти на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Метод используется для отправки коллекции файлов или в памяти буферы данных к удаленному узлу. <xref:System.Net.Sockets.Socket> Должен быть подключен к удаленному узлу.  
  
 Если <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> ссылается на файл в рабочем каталоге, он может быть идентифицирован с помощью только имя файла; в противном случае необходимо указать полный путь и имя файла. Поддерживаются подстановочные знаки и имена общих ресурсов UNC. Если файл не найден, <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик событий\<SocketAsyncEventArgs > делегировать и присоединения обратный вызов, который <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событий.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Свойство `e` параметр предоставляет поставщик услуг сокетов окно с дополнительными сведениями о передаче файла. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Этот метод использует функцию TransmitPackets, в Windows Sockets 2 API. Дополнительные сведения о функции TransmitPackets и его флаги, см. в разделе [Windows Sockets](/windows/desktop/WinSock/) документации.  
  
 Несмотря на то, что предназначен для протоколов, ориентированного на подключение, <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> метод также работает для протоколов без установления соединения, при условии, что сначала вызвать <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод, чтобы установить удаленный узел по умолчанию. При работе с протоколами необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызывает <xref:System.Net.Sockets.SocketException> исключение.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Метод оптимизирован в соответствии с операционной системы, на котором он используется. В выпусках Windows server <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> метод оптимизирован для обеспечения высокой производительности.  
  
 В клиентских версиях Windows <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> метод оптимизирован для минимальное использование памяти и ресурсов.  
  
 Использование <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> флаг в <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> свойство `e` параметра может обеспечить значительные преимущества в производительности. Если поток запуска <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызов метода используется для больших вычислений, возможно, хоть и крайне малая, что APC может быть запрещено запуска. Обратите внимание, что разница между APC ядра и пользовательского режима. Ядра запускаются, когда поток находится в состоянии ожидания. Пользовательского режима запускаются, когда поток находится в состоянии извещающие ожидания  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Файл, указанный в свойстве <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />, не найден.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, когда объект <see cref="T:System.Net.Sockets.Socket" /> не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Используется объект <see cref="T:System.Net.Sockets.Socket" />, функционирующий без установления соединения, и размер отправляемого файла превышает максимальный размер пакета основного транспортного средства.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Send" /> истечет время тайм-аута.</summary>
        <value>Значение времени ожидания в миллисекундах. Если для этого свойства задать значение от 1 до 499, значение будет изменено на 500. По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется к синхронным <xref:System.Net.Sockets.Socket.Send%2A> только вызовы. Если Превышен период ожидания, <xref:System.Net.Sockets.Socket.Send%2A> метод вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше –1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Посылает данные на указанную конечную точку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает данные на указанную конечную точку.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0, число байтов для отправки значения по умолчанию размер `buffer` параметра и <xref:System.Net.Sockets.SocketFlags> по умолчанию — 0.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.Send%2A> метод. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` переопределит указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как у основного поставщика услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Если вам необходимо идентифицировать назначенные локальной сети адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.Socket.SendTo%2A> успешного завершения метода.  
  
 Несмотря на то, что предназначены для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с установлением соединения. Если вы используете протокол с установлением соединения, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принимать входящий запрос подключения используйте <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения к удаленному узлу <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> будет игнорировать `remoteEP` параметра и только отправка данных с подключенным или удаленный узел по умолчанию.  
  
 Блокированные сокеты будут пока не отправляются все байты из буфера. Поскольку неблокирующем <xref:System.Net.Sockets.Socket> завершается немедленно, он может отправить все байты в `buffer`. Ответственность приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит все байты в `buffer`. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем исходящих данных. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет равным <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Необходимо также убедиться, что количество отправленных байтов превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода отправляет без установления соединения датаграмму на удаленный узел.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Передает данные на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0 и число байтов для отправки значения по умолчанию размер `buffer`. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.Send%2A> метод. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` переопределит указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как у основного поставщика услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Если вам необходимо идентифицировать назначенные локальной сети адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.Socket.SendTo%2A> успешного завершения метода.  
  
 Несмотря на то, что предназначены для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с установлением соединения. Если вы используете протокол с установлением соединения, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принимать входящий запрос подключения используйте <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения к удаленному узлу <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> будет игнорировать `remoteEP` параметра и только отправка данных с подключенным или удаленный узел по умолчанию.  
  
 Блокированные сокеты будут до запрошенного все байты в `buffer` отправляются. Поскольку неблокирующем <xref:System.Net.Sockets.Socket> завершается немедленно, он может отправить все байты в `buffer`. Ответственность приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит все байты в `buffer`. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем данных, исходящий. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет равным <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Необходимо также убедиться, что количество отправленных байтов превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода отправляет без установления соединения датаграмму на удаленный узел. <xref:System.Net.Sockets.SocketFlags> передаваемые <xref:System.Net.Sockets.Socket.SendTo%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает указанное число байтов данных на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.Send%2A> метод. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` переопределит указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как у основного поставщика услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Если вам необходимо идентифицировать назначенные локальной сети адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.Socket.SendTo%2A> успешного завершения метода.  
  
 Несмотря на то, что предназначены для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с установлением соединения. Если вы используете протокол с установлением соединения, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принимать входящий запрос подключения используйте <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения к удаленному узлу <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> будет игнорировать `remoteEP` параметра и только отправка данных с подключенным или удаленный узел по умолчанию.  
  
 Блокированные сокеты будут пока не отправляются запрошенного числа байтов. Поскольку неблокирующем <xref:System.Net.Sockets.Socket> завершается немедленно, он может отправить все байты, запрашиваемый в рамках одной операции. Отвечает за приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем данных, исходящий. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет равным <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Необходимо также убедиться, что количество отправленных байтов превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода отправляет без установления соединения датаграмму на удаленный узел. Размер и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.SendTo%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает указанное число байтов данных на указанную конечную точку, начиная с заданной позиции буфера и используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке, если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> считали `socketflags` параметр, данные не будут направляться.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.Send%2A> метод. Если вы вызываете <xref:System.Net.Sockets.Socket.Connect%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` переопределит указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как у основного поставщика услуг назначит наиболее подходящий локальный сетевой адрес и номер порта. Если вам необходимо идентифицировать назначенные локальной сети адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.Socket.SendTo%2A> успешного завершения метода.  
  
 Несмотря на то, что предназначены для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с установлением соединения. Если вы используете протокол с установлением соединения, необходимо сначала установить подключения к удаленному узлу, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или принимать входящий запрос подключения используйте <xref:System.Net.Sockets.Socket.Accept%2A> метод. Если не устанавливать или принимать подключения к удаленному узлу <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>. Вы можете также установить удаленный узел по умолчанию для протокол без установления соединения до вызова метода <xref:System.Net.Sockets.Socket.SendTo%2A> метод. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> будет игнорировать `remoteEP` параметра и только отправка данных с подключенным или удаленный узел по умолчанию.  
  
 Блокированные сокеты будут пока не отправляются запрошенного числа байтов. С момента неблокирующий <xref:System.Net.Sockets.Socket> завершается немедленно, он может отправить все байты, запрашиваемый в рамках одной операции. Отвечает за ваши приложения для отслеживания число отправленных байт и повторите операцию, пока приложение не отправит запрошенного числа байтов. Нет никакой гарантии, что данные, которые вы отправляете немедленно появятся в сети. Для повышения пропускной способности сети базовая система может приостановить передачу, пока не собираются значительный объем данных, исходящий. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метод означает, что базовая система была места для буфера, отправка данных в сети.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> будут заблокированы, пока не будет отправлено датаграмм. Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет равным <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Необходимо также убедиться, что размер не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendTo%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода отправляет без установления соединения датаграмму на удаленный узел. Смещение, размер и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.SendTo%2A> метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Асинхронно передает данные на конкретный удаленный узел.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> Метод запускает операцию асинхронной передачи на удаленный узел, указанный в <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство `e` параметр. Вызов <xref:System.Net.Sockets.Socket.SendToAsync%2A> метод дает возможность отправлять данные в отдельном потоке. Несмотря на то, что этот метод предназначен для протоколов без установления соединения, <xref:System.Net.Sockets.Socket.SendToAsync%2A> работает с протоколами без установления соединения и ориентированных на подключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик событий\<SocketAsyncEventArgs > делегировать и присоединения обратный вызов, который <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событий.  
  
 Перечисленные ниже свойства и события на <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объект необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> свойства любого объекта состояния пользователя, требуемого перед вызовом <xref:System.Net.Sockets.Socket.SendToAsync%2A> метод, таким образом, данные будут доступны в метод обратного вызова. Если функция обратного вызова должна больше информации, чем один объект, можно создать небольшой класс для хранения других необходимой информации о состоянии как члены.  
  
 Если вы используете протокол с установлением соединения, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод. В противном случае <xref:System.Net.Sockets.Socket.SendToAsync%2A> вызовет <xref:System.Net.Sockets.SocketException>. При использовании протокола, ориентированного на подключение, <xref:System.Net.Sockets.Socket.SendToAsync%2A> метод будет игнорировать <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство и отправляет данные на <xref:System.Net.EndPoint?displayProperty=nameWithType> в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод.  
  
 Если вы используете протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Требуется только в случае, если вызываемая <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.SendAsync%2A> методы. Если вы вызываете <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод до вызова метода <xref:System.Net.Sockets.Socket.SendToAsync%2A>, <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство переопределяет указанный удаленный узел по умолчанию для этой операции только передачи. Вы также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод. В этом случае основной поставщик услуг назначит наиболее подходящий локальной сети IP адрес и номер порта. Используйте номер порта 0, если требуется, чтобы у основного поставщика услуг, чтобы выбрать свободный порт. Если необходимо определить IP-адрес и порт номер назначенные локальной сети, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойства после <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событие получает сигнал и связанные делегаты вызываются.  
  
 Если вы хотите отправлять данные в адрес широковещательной рассылки, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и набор сокет для параметра <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> значение true. Необходимо также убедиться, что размер буфера не превышает максимальный размер пакета основного поставщика услуг. В этом случае данные не отправляются и <xref:System.Net.Sockets.Socket.SendToAsync%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
 Если указать флаг DontRoute в <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> свойство, данные не будут направляться.  
  
 Для сокетов, ориентированных на сообщения необходимо соблюдать осторожность не должно превышать максимальный размер сообщения используемого транспорта. Если размер буфера превышает максимальный размер пакета основного поставщика услуг, датаграмма не отправляется и <xref:System.Net.Sockets.Socket.SendToAsync%2A> вызовет <xref:System.Net.Sockets.SocketException>. Успешное выполнение <xref:System.Net.Sockets.Socket.SendToAsync%2A> метод не означает, что данные был успешно доставлен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Указанный протокол работает с установлением соединения, но объект <see cref="T:System.Net.Sockets.Socket" /> еще не подключен.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="level">Уровень защиты IP, который надо установить для сокета.</param>
        <summary>Задается стандартный уровень защиты IP для сокета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Метод включает ограничение сокета IPv6 или IP-адрес для прослушивания указанной области действия, такие как адреса, с тем же связи, локальных или локальным префиксом сайта. Этот параметр сокета позволяет приложениям устанавливать ограничения доступа к сокетам IPv6 или IP-адрес. Такие ограничения позволяют приложению, работающему в частной локальной сети, просто и надежно защититься от внешних атак. Этот параметр сокета может также использоваться для удаления ограничения доступа, если `level` параметр имеет значение <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Этот параметр сокета расширяет или сужает диапазон прослушивающего сокета, обеспечивая при необходимости неограниченный доступ со стороны открытых и закрытых пользователей или ограничивая доступ только тем же сайтом.  
  
 Определенные уровни защиты этого параметра сокета указаны в перечислении <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Метод используется для включения или отключения обхода адресов в сети (NAT) для <xref:System.Net.Sockets.Socket> экземпляра. Обход NAT может предоставляться с помощью Teredo, 6to4 или туннель ISATAP.  
  
 Когда `level` параметр имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, или <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, это явно отключает обхода NAT для <xref:System.Net.Sockets.Socket> экземпляра.  
  
 Когда `level` параметр имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, это может позволить обойти NAT для <xref:System.Net.Sockets.Socket> в зависимости от правил брандмауэра на месте в системе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="level" /> не может иметь значение <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Уровень защиты IP не может быть неопределенным.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.AddressFamily" /> сокета должен быть либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />, либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает параметр <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Значение параметра, представленное в виде объекта <see cref="T:System.Boolean" />.</param>
        <summary>Устанавливает для заданного параметра <see cref="T:System.Net.Sockets.Socket" /> указанное значение <see cref="T:System.Boolean" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. Задайте `optionValue` для `true` включить этот параметр или `false` Чтобы отключить параметр.  
  
 <xref:System.Net.Sockets.Socket> Параметры сгруппированы по уровню поддержки протокола.  
  
 Ниже приведены различные <xref:System.Net.Sockets.Socket> параметры, которые могут быть установлены при использовании этой перегрузки. Эти параметры сгруппированы с помощью соответствующего <xref:System.Net.Sockets.SocketOptionLevel> значение. Если планируется установить любой из этих вариантов, не забудьте указать соответствующий <xref:System.Net.Sockets.SocketOptionLevel> значение `optionLevel` параметра. Параметр, выбранный для установки необходимо указать в `optionName` параметра. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Дополнительные сведения об этих параметрах см. <xref:System.Net.Sockets.SocketOptionName> перечисления.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> исключения, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
   
  
## Examples  
 В следующем примере кода открывает сокет и позволяет `DontLinger` и `OutOfBandInline` параметров сокета.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Массив типа <see cref="T:System.Byte" />, который представляет значение параметра.</param>
        <summary>Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде байтового массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. Используйте этот перегруженный метод, чтобы установить эти <xref:System.Net.Sockets.Socket> параметров, требующих байтовый массив в качестве значения параметра.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значений времени ожидания.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Значение параметра.</param>
        <summary>Устанавливает заданное целое значение для указанного параметра <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. Для параметра с <xref:System.Boolean> тип данных, укажите ненулевое значение, чтобы включить параметр, а нулевое значение, чтобы отключить параметр. Для параметра с типом данных integer задайте соответствующее значение. <xref:System.Net.Sockets.Socket> Параметры сгруппированы по уровню поддержки протокола.  
  
 Ниже приведены различные <xref:System.Net.Sockets.Socket> параметры, которые могут быть установлены при использовании этой перегрузки. Эти параметры сгруппированы с помощью соответствующего <xref:System.Net.Sockets.SocketOptionLevel>. Если планируется установить любой из этих вариантов, не забудьте указать соответствующий <xref:System.Net.Sockets.SocketOptionLevel> для `optionLevel` параметра. Параметр, выбранный для установки необходимо указать в `optionName` параметра. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Дополнительные сведения об этих параметрах см. <xref:System.Net.Sockets.SocketOptionName> перечисления.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значений времени ожидания.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Объект <see cref="T:System.Net.Sockets.LingerOption" /> или <see cref="T:System.Net.Sockets.MulticastOption" />, содержащий значение параметра.</param>
        <summary>Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>. Эта перегрузка позволяет задать <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, и <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> параметры. Для <xref:System.Net.Sockets.SocketOptionName.Linger> , используйте <xref:System.Net.Sockets.Socket> для `optionLevel` параметра. Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>, используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>. Если вы хотите получить текущее значение любого из перечисленных выше параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Одно из значений <see cref="T:System.Net.Sockets.SocketShutdown" />, указывающее на то, что операция более не разрешена.</param>
        <summary>Блокирует передачу и получение данных для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании ориентированного на подключение <xref:System.Net.Sockets.Socket>, всегда вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> метод перед закрытием <xref:System.Net.Sockets.Socket>. Это гарантирует, что все данные отправки и получения на подключенный сокет, до его закрытия.  
  
 Вызовите <xref:System.Net.Sockets.Socket.Close%2A> метод, чтобы освободить все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. Не пытайтесь повторно использовать <xref:System.Net.Sockets.Socket> после закрывающего тега.  
  
 В следующей таблице показаны <xref:System.Net.Sockets.SocketShutdown> значений перечисления, которые являются допустимыми для `how` параметра.  
  
|Значение|Описание|  
|-----------|-----------------|  
|Отправить|Отключить отправку на это <xref:System.Net.Sockets.Socket>.|  
|Получить|Запретить прием на этом <xref:System.Net.Sockets.Socket>.|  
|Оба|Отключение отправки и получения об этом <xref:System.Net.Sockets.Socket>.|  
  
 Установка `how` для <xref:System.Net.Sockets.SocketShutdown.Send> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Send%2A> не допускаются. Если вы используете без установления соединения <xref:System.Net.Sockets.Socket>, указав <xref:System.Net.Sockets.SocketShutdown.Send> не окажет никакого воздействия.  
  
 Установка `how` для <xref:System.Net.Sockets.SocketShutdown.Receive> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Receive%2A> не допускаются. Это не влияет на нижнем уровне протокола. Если вы используете протокол с установлением соединения, соединение будет разорвано, если выполняется любое из следующих условий после вызова <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Данные находятся в ожидании получения входящих сетевом буфере.  
  
-   Получены дополнительные данные.  
  
 Если вы используете протокол без установления соединения, датаграммы принимаются и в очередь. Тем не менее если буферное пространство не будет доступен для дополнительных входных датаграмм, они будут отменены, и ошибка не возвращается отправителю. С помощью <xref:System.Net.Sockets.Socket.Shutdown%2A> на без установления соединения <xref:System.Net.Sockets.Socket> не рекомендуется.  
  
 Установка `how` для <xref:System.Net.Sockets.SocketShutdown.Both> блокирует оба передачу и получение, как описано выше.  
  
> [!NOTE]
>  Если вы получили <xref:System.Net.Sockets.SocketException> при вызове <xref:System.Net.Sockets.Socket.Shutdown%2A> метода, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.Shutdown%2A> отключение <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> только для чтения и устанавливается при <xref:System.Net.Sockets.Socket> создается.  
  
   
  
## Examples  
 Следующий код отображает пример <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, доступна ли на текущем узле поддержка протокола IPv4 и включена ли эта функция.</summary>
        <value>Значение <see langword="true" />, если текущий узел поддерживает протокол IPv4; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система поддерживает протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, поддерживает ли Framework протокол IPv6 для определенных устаревших членов <see cref="T:System.Net.Dns" />.</summary>
        <value>Значение <see langword="true" />, если Framework поддерживает протокол IPv6 для определенных устаревших методов <see cref="T:System.Net.Dns" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система поддерживает протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, занятые модулем <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызовите IDisposable.Dispose, когда вы закончите с помощью <xref:System.Net.Sockets.Socket>. Метод IDisposable.Dispose оставляет <xref:System.Net.Sockets.Socket> окажется в неработоспособном состоянии. После вызова метода IDisposable.Dispose, необходимо удалить все ссылки на <xref:System.Net.Sockets.Socket> , сборщик мусора мог освободить память, <xref:System.Net.Sockets.Socket> занимаемую. Дополнительные сведения см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Всегда вызывайте метод IDisposable.Dispose, перед освобождением последней ссылки на <xref:System.Net.Sockets.Socket>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, задающее время существования (TTL) IP-пакетов, отправленных объектом <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Значение времени существования TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение TTL указывает максимальное число маршрутизаторов, может выполнить пакет, прежде чем маршрутизатор отклоняет пакет и протокол управления сообщений протокола ICMP (Internet) «Превысило срок ЖИЗНИ» сообщение об ошибке возвращается отправителю.  
  
 Значение срока ЖИЗНИ может быть присвоено значение от 0 до 255. Если это свойство не задано, значение срока ЖИЗНИ по умолчанию для сокета — 32.  
  
 Задание этого свойства для протокола управления передачей (TCP) сокета обрабатывается с помощью стека TCP/IP успешного подключения через сокет.  
  
 Если вы получили <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этот код, см. по [код ошибки API сокетов Windows версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) документации подробное описание ошибки.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.Ttl%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В качестве величины срока жизни нельзя задать отрицательное число.</exception>
        <exception cref="T:System.NotSupportedException">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. Эта ошибка также возвращается при попытке задать срок жизни больше, чем 255.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, должен ли сокет использовать только режим ввода-вывода Overlapped.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует только режим перекрывающего ввода-вывода; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` для <xref:System.Net.Sockets.Socket> вызываемая <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. В противном случае платформа может назначить порт завершения сокета, которая будет запрещена областью применения <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сокет привязан к порту завершения.</exception>
      </Docs>
    </Member>
  </Members>
</Type>