<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="88de072b4dbcedee84bbdce0710e670a91d8eebd" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58560955" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет контейнер, в котором может храниться несколько объектов данных.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> — Абстрактный класс, который может использоваться для упорядочивания объектов в одной сущности из определенного физического формата для обеспечения переносимости и эффективный доступ.  
  
 ZIP-файл является основным форматом физических <xref:System.IO.Packaging.Package>.  Другие <xref:System.IO.Packaging.Package> реализации может использовать другие физические форматы, например XML-документа, базы данных, или веб-службы.  
  
 Как и системные файлы, элементы, содержащиеся в <xref:System.IO.Packaging.Package> указываются в виде иерархической структуры папок и файлов.  
  
 Несмотря на то что <xref:System.IO.Packaging.Package> сам является абстрактным классом, <xref:System.IO.Packaging.ZipPackage> производном классе используется по умолчанию, <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Объект <xref:System.IO.Packaging.PackagePart> («часть») — это абстрактный класс, который представляет объект, который хранится в <xref:System.IO.Packaging.Package>.  
  
 Объект <xref:System.IO.Packaging.PackageRelationship> («отношение») определяет ассоциацию между исходным <xref:System.IO.Packaging.Package> или <xref:System.IO.Packaging.PackagePart> и целевым объектом.  Объект <xref:System.IO.Packaging.PackageRelationship> может принимать одно из двух типов, каждый из которых может принимать одно из двух форм:  
  
-   Отношение уровня пакета (созданные <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> метод) относится <xref:System.IO.Packaging.Package> либо:  
  
    -   Целевой части в пакете.  
  
    -   Целевой ресурс вне пакета.  
  
-   Отношение уровня части (созданные <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> метод) относится источник <xref:System.IO.Packaging.PackagePart> либо:  
  
    -   Другой целевой части в пакете.  
  
    -   Целевой ресурс вне пакета.  
  
 Источник отношений <xref:System.IO.Packaging.Package> или источника <xref:System.IO.Packaging.PackagePart> считается «владельцем» связи.  При удалении исходного объекта также удаляются все отношения, принадлежащие исходного объекта.  Процесс создания или удаления связи не изменяет физически исходных или целевых объектов любым способом.  
  
 Объект <xref:System.IO.Packaging.PackageDigitalSignature> («цифровая подпись») представляет собой сочетание частей и отношений, представляющий состав цифровой подписи <xref:System.IO.Packaging.Package>.  Цифровая подпись, определяющую отправителя и проверяет, что подписанные части и отношения содержится в <xref:System.IO.Packaging.Package> не были изменены.  
  
 Пакеты также поддерживают цифровыми правами (DRM), позволяющий элементами содержимого в <xref:System.IO.Packaging.Package> шифрование с конкретных прав доступа для авторизованных пользователей.  
  
 На основе <xref:System.IO.Packaging.Package> архитектуры, <xref:System.Windows.Xps.Packaging.XpsDocument> — это тип пакета, предназначенных для хранения документов, основанные на открытых [XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework использует пакеты для хранения содержимого, ресурсы и связи для страниц и документов с помощью стандартного ZIP-файла по умолчанию. Как любой ZIP-файл, приложение может использовать <xref:System.IO.Packaging> классов для хранения и защиты любого типа или количество файлов данных в одном контейнере эффективный доступ.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано основные шаги для создания <xref:System.IO.Packaging.Package>.  В этом примере пакет создается для хранения документа и графического изображения, которое отображается как часть документа.  (Это похоже на случай, в котором содержит HTML-файл \<IMG > тег, который ссылается на внешний файл изображения.)  Два <xref:System.IO.Packaging.PackageRelationship> элементы также будут включены в пакет.  Во-первых, связь «на уровне пакета», определяет части документа как корневого элемента пакета.  Во-вторых, «уровня части» отношение определяет связи между части документа («источник» отношения уровня части) и его использование части изображения («target» отношения уровня части).  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging характеристики соглашений (OPC)</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Цифровые подписи Framework стандарта Open Packaging Conventions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Разрешения файлового ввода-вывода для пакета.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />, использующий заданный режим <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор является защищенным из <xref:System.IO.Packaging.Package> абстрактного базового класса. При вызове в производном классе, <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="openFileAccess" /> является недопустимым.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="streaming" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Разрешения файлового ввода-вывода для пакета.</param>
        <param name="streaming"><see langword="true" />, если требуется открыть пакет для работы в потоке, в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />, использующий заданный режим <see cref="T:System.IO.FileAccess" /> и режим потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор является защищенным из <xref:System.IO.Packaging.Package> абстрактный базовый абстрактный базовый класс. При вызове в производном классе, <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="openFileAccess" /> является недопустимым.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет и закрывает пакет, а также все базовые потоки частей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.IO.Packaging.Package> класс <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> выполнить те же операции — нет причин для вызова <xref:System.IO.Packaging.Package.Dispose%2A> при вызове метода <xref:System.IO.Packaging.Package.Close%2A>, или наоборот.  
  
 <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> внутреннего вызова <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  `using` Инструкции (отличается от `using` директивы пространства имен) — это рекомендуемый способ <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> пакета.  [Пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055) и [пример чтения пакета](https://go.microsoft.com/fwlink/?LinkID=160034) показано, как закрыть и удалить пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новую часть пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Инициализирует пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Дополнительные сведения о части пакета в разделе 1.1 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] новой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <summary>Создает новую несжатую часть с заданным URI и типом содержимого.</summary>
        <returns>Новая созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Инициализирует пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Часть <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> является <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Дополнительные сведения об элементах пакета в разделе 1.1 в спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="partUri" /> или <paramref name="contentType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> уже имеется в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения (добавление новой части невозможно).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] новой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <param name="compressionOption">Режим сжатия потока данных — <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> или <see cref="F:System.IO.Packaging.CompressionOption.Normal" />.</param>
        <summary>Создает новую часть с заданными значениями URI, типа содержимого и режима сжатия.</summary>
        <returns>Новая созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производного класса <xref:System.IO.Packaging.Package.CreatePart%2A> метод поддерживает два только `compressionOption` значения, <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  Другие <xref:System.IO.Packaging.CompressionOption> значения <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, или <xref:System.IO.Packaging.CompressionOption.SuperFast> использовать <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Создает пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="partUri" /> или <paramref name="contentType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> уже имеется в пакете.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="compressionOption" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения (добавление новой части невозможно).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] создаваемой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <param name="compressionOption">Параметр сжатия потока данных.</param>
        <summary>При переопределении в производном классе создает новую часть в пакете.</summary>
        <returns>Созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные <xref:System.IO.Packaging.Package.CreatePartCore%2A> вызывается метод <xref:System.IO.Packaging.Package.CreatePart%2A> метод для создания части на основе физического формата реализации в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> реализация производного класса абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.CreatePart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.CreatePartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класс, чтобы создать новую часть в ZIP-файл.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производного класса <xref:System.IO.Packaging.Package.CreatePartCore%2A> метод поддерживает два только `compressionOption` значения, <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  Другие <xref:System.IO.Packaging.CompressionOption> значения <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, или <xref:System.IO.Packaging.CompressionOption.SuperFast> использовать <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производные <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> метод, который ее вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает связь с заданной частью на уровне пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевому объекту <xref:System.IO.Packaging.PackagePart> внутри пакета.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  Процесс создания или удаления связи не изменяет физически ни целевой части или ресурса любым способом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано создание <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] целевой части.</param>
        <param name="targetMode">Показывает, является ли целевая часть внутренней (<see cref="F:System.IO.Packaging.TargetMode.Internal" />) или внешней (<see cref="F:System.IO.Packaging.TargetMode.External" />) по отношению к пакету.</param>
        <param name="relationshipType">Код URI, однозначно определяющий роль связи.</param>
        <summary>Создает связь с частью на уровне пакета по заданным значениям URI, вида целевой части и типа связи.</summary>
        <returns>Связь с указанной частью на уровне пакета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> не изменяет физически целевой части или ресурса любым способом.  
  
 Целевым объектом связи не может быть другая связь.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` должен быть относительный URI, сформированный в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  Внутренний относительный URI может быть либо абсолютный путь, который начинается с косой черты («/») символ например «/ page1.xaml» или «/ images/picture4.jpg», или относительный путь, например, «.. / imagespicture1.jpg», разрешающее относительно корня пакета («/») как базовый URI.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.External>, `targetUri` может быть либо абсолютный или относительный URI, сформированный в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI). `http://www.microsoft.com/page2.xml` является примером абсолютный URI, который ссылается на ресурс внешний целевой объект «page2.xml».  «images/picture1.jpg» является примером относительный URI, который также ссылается на внешний целевой ресурс «1.jpg» но который разрешается относительно URI самого пакета.  
  
 `relationshipType` должно быть [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] , формируется в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Цифровая подпись сертификата|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Цифровая подпись источника|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для создания <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="targetUri" /> или <paramref name="relationshipType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Часть <paramref name="targetUri" /> представляет собой <see cref="T:System.IO.Packaging.PackageRelationship" />, или в качестве <paramref name="targetMode" /> задано <see cref="F:System.IO.Packaging.TargetMode.Internal" /> и <paramref name="targetUri" /> является абсолютным URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="targetMode" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] целевой части.</param>
        <param name="targetMode">Показывает, является ли целевая часть внутренней (<see cref="F:System.IO.Packaging.TargetMode.Internal" />) или внешней (<see cref="F:System.IO.Packaging.TargetMode.External" />) по отношению к пакету.</param>
        <param name="relationshipType">Код URI, однозначно определяющий роль связи.</param>
        <param name="id">Уникальный идентификатор XML.</param>
        <summary>Создает связь с частью на уровне пакета по заданным значениям URI, вида целевой части, типа связи и [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Связь с указанной частью на уровне пакета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> не изменяет физически целевой части или ресурса любым способом.  
  
 Целевым объектом связи не может быть другая связь.  
  
 `id` Должен быть допустимым идентификатором XML.  `id` Тип xsd:ID и должно соответствовать соглашениям об именах, описанный в XML Schema Part 2: Спецификации типов данных (см. в разделе [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Если `id` указывается как `null` уникальный идентификатор создается автоматически.  `id` Определяемое пустая строка недопустима.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` должен быть относительный URI, сформированный в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  Внутренний относительный URI может быть либо абсолютный путь, который начинается с косой черты («/») символ например «/ page1.xaml» или «/ images/picture4.jpg», или относительный путь, например, «.. / imagespicture1.jpg», разрешающее относительно корня пакета («/») как базовый URI.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.External>, `targetUri` может быть либо абсолютный или относительный URI, сформированный в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI). `http://www.microsoft.com/page2.xml` является примером абсолютный URI, который ссылается на ресурс внешний целевой объект «page2.xml».  «images/picture1.jpg» является примером относительный URI, который также ссылается на внешний целевой ресурс «1.jpg» но который разрешается относительно URI самого пакета.  
  
 `relationshipType` должен быть URI, сформированный в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Цифровая подпись сертификата|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Цифровая подпись источника|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для создания <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="targetUri" /> или <paramref name="relationshipType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Часть <paramref name="targetUri" /> представляет собой <see cref="T:System.IO.Packaging.PackageRelationship" />, или в качестве <paramref name="targetMode" /> задано <see cref="F:System.IO.Packaging.TargetMode.Internal" /> и <paramref name="targetUri" /> является абсолютным URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="targetMode" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> не является допустимым идентификатором XML; или часть с указанным <paramref name="id" /> уже имеется в пакете.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] удаляемой части.</param>
        <summary>Удаляет из пакета часть с заданным URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` должен быть относительным URI, который состоит из абсолютного пути, начинается с косой черты («/») символ.  Абсолютный путь задается относительно корневого каталога пакета и формируется в соответствии с [RFC 3986](https://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  «/ page1.xaml» и «/ images/picture4.jpg» являются примерами допустимой частью идентификаторы URI.  
  
 Исключение возникает в том случае, если часть с указанным `partUri` не находится в пакете.  (Можно использовать <xref:System.IO.Packaging.Package.PartExists%2A> метод, чтобы определить, является ли элемент с указанным `partUri` находится в пакете.)  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> метод фактически удалить части на основе физического формата реализации в производном классе.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Свойство <see cref="P:System.IO.Packaging.PackagePart.Uri" /> удаляемого объекта <see cref="T:System.IO.Packaging.PackagePart" />.</param>
        <summary>При переопределении в производном классе удаляет часть с заданным URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> реализация производного класса абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.DeletePart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.DeletePartCore%2A> из <xref:System.IO.Packaging.ZipPackage> классом для выполнения фактического удаления на основе формата физической реализации в производном классе.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производный класс <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> вызывается реализация <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> метод с указанной частью на основе физического формата реализации в производном классе.  
  
Производные <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> метод, который ее вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> удаляемого объекта <see cref="T:System.IO.Packaging.PackageRelationship" />.</param>
        <summary>Удаляет связь уровня пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 Исключение возникает в том случае, если связь с указанным `id` не находится в пакете.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> не изменяет физически целевой части любым способом.  
  
 Дополнительные сведения о связях пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Очищает и сохраняет содержимое всех частей и связей, закрывает пакет и освобождает все ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы убедиться в том, что все изменения сохраняются правильно, <xref:System.IO.Packaging.Package.Dispose%2A> также завершает работу, очищает и закрывает всех частей и связей, которые содержатся в пакете.  
  
 Для <xref:System.IO.Packaging.Package> класс, <xref:System.IO.Packaging.Package.Dispose%2A> и <xref:System.IO.Packaging.Package.Close%2A> выполнить те же операции — нет причин для вызова <xref:System.IO.Packaging.Package.Dispose%2A> при вызове метода <xref:System.IO.Packaging.Package.Close%2A>, или наоборот.  
  
 <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> внутреннего вызова <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Производные классы, выделить ресурсы и управлять ими неоптимизированными для памяти, которые должны переопределять этот метод для освобождения ресурсов при <xref:System.IO.Packaging.Package.Dispose%2A> вызывается. Производный класс переопределяет вызывать <xref:System.IO.Packaging.Package.Flush%2A> и базовый класс <xref:System.IO.Packaging.Package.Dispose%2A> метод, чтобы убедиться в том, что очистка базового класса всегда выполняется.  
  
> [!NOTE]
>  `using` Инструкции (отличается от `using` директивы пространства имен) — это рекомендуемый способ <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> пакета. [Пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055) показано, как закрыть и удалить пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение режима доступа к файлу для пакета.</summary>
        <value>Одно из значений <see cref="T:System.IO.FileAccess" />: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> или <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.IO.Packaging.Package.FileOpenAccess%2A> не имеет значения по умолчанию.  Режима доступа к файлу указан в <xref:System.IO.Packaging.Package.%23ctor%2A> вызовите конструктор при создании нового пакета или в <xref:System.IO.Packaging.Package.Open%2A> вызова при открытии существующего пакета.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет содержимое всех частей и связей, имеющихся в пакете.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> внутренне вызывает производного класса <xref:System.IO.Packaging.Package.FlushCore%2A> реализации для выполнения фактической операции записи на диск определенного формата.  Производный класс <xref:System.IO.Packaging.Package.FlushCore%2A> метод фактическое сохранение содержимого частей и связей в реализацию определенного физического производного класса.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс. В ходе операции по умолчанию <xref:System.IO.Packaging.Package.Flush%2A> внутренне вызывает <xref:System.IO.Packaging.Package.FlushCore%2A> для сохранения частей и отношений в ZIP-файл пакета.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> автоматически вызывается <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> методы.  Когда <xref:System.IO.Packaging.Package.Close%2A> или <xref:System.IO.Packaging.Package.Dispose%2A> вызове нет необходимости вызывать <xref:System.IO.Packaging.Package.Flush%2A> отдельно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения и не может быть изменен.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.FlushCore" /> метод фактически записать части на основе физического формата реализации в производном классе.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе сохраняет содержимое всех частей и связей в хранилище производного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> вызывается <xref:System.IO.Packaging.Package.Flush%2A> метод для выполнения фактической операции записи на диск на основе физического формата реализации в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производные <see cref="M:System.IO.Packaging.Package.FlushCore" /> реализация не должна делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.Flush" /> метод, который ее вызывает.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] части, которую требуется возвратить.</param>
        <summary>Возвращает часть с заданным URI.</summary>
        <returns>Часть с указанным <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> Возникает, если часть с указанным `partUri` не существует.  
  
 <xref:System.IO.Packaging.Package.PartExists%2A> Метод может использоваться для определения ли `partUri` ссылается на существующий элемент.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetPart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для возвращения запрашиваемой части из ZIP-файл.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Приведенный ниже показано, как находить, извлечь и прочитать части, содержащиеся в пакете.  Полный пример см. в разделе [пример чтения пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> не содержится в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> метод фактически записать части на основе физического формата реализации в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] части, которую требуется извлечь.</param>
        <summary>При переопределении в производном классе возвращает часть, адресованную заданным URI.</summary>
        <returns>Запрошенная часть или <see langword="null" />, если часть с указанным <paramref name="partUri" /> отсутствует в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetPart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для извлечения элемента из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производный класс <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> вызывается реализация <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> метод для доступа и возвращает указанную часть на основе физического формата реализации в производном классе.  
  
Производные <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> метод, который ее вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, состоящую из всех частей пакета.</summary>
        <returns>Коллекция всех элементов <see cref="T:System.IO.Packaging.PackagePart" />, содержащихся в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Возвращает коллекцию всех частей, содержащихся в пакете, включая <xref:System.IO.Packaging.PackageRelationship> частей.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> никогда не будут возвращать `null`; тем не менее, возвращаемая коллекция будет содержать нуль элементов, если пакет содержит компоненты не.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetParts%2A> вызовы <xref:System.IO.Packaging.Package.GetPartsCore%2A> метод <xref:System.IO.Packaging.ZipPackage> класса для возвращения частей из ZIP-файл.  
  
 Дополнительные сведения о пакетах и частей пакета в разделе 1.1 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.GetParts%2A> метод, чтобы получить коллекцию частей, содержащихся в <xref:System.IO.Packaging.Package>.  Полный исходный код программы, см. в разделе [Создание пакета с помощью цифровой подписи образца](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> метод фактически записать части на основе физического формата реализации в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает массив, состоящий из всех частей пакета.</summary>
        <returns>Массив всех частей, содержащихся в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный класс <xref:System.IO.Packaging.Package.GetPartsCore%2A> вызывается реализация <xref:System.IO.Packaging.Package.GetParts%2A> метод для доступа и возвращать массив частей на основе физического формата реализации в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetParts%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для извлечения частей из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производные <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.GetParts" /> метод, который ее вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> связи, которую требуется возвратить.</param>
        <summary>Возвращает связь уровня пакета с заданным идентификатором.</summary>
        <returns>Связь уровня пакета с указанным <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Должен быть допустимым идентификатором XML. `id` Тип xsd:ID и должно соответствовать соглашениям об именах, описанный в [разделе 3.3.8 элемента XML Schema Part 2: Спецификации типов данных](https://www.w3.org/TR/xmlschema-2/#ID).  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
        <exception cref="T:System.InvalidOperationException">Связь с указанным <paramref name="id" /> отсутствует в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, состоящую из всех связей уровня пакета.</summary>
        <returns>Коллекция всех связей уровня пакета, содержащихся в данном пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> никогда не будут возвращать `null`; Однако Возвращенная коллекция может содержать нуль элементов, если пакет содержит не связей уровня пакета.  
  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  Процесс создания или удаления связи не изменяет физически ни целевой части или ресурса любым способом.  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Свойство <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> для сопоставления и возврата в коллекцию.</param>
        <summary>Возвращает коллекцию, состоящую из всех связей уровня пакета с заданным типом <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Коллекция связей уровня пакета, соответствующих указанному типу <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> никогда не будут возвращать `null`; Однако Возвращенная коллекция может содержать нуль элементов, если нет связей уровня пакета, соответствующих указанному `relationshipType`.  
  
 В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Цифровая подпись сертификата|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Цифровая подпись источника|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Приведенный ниже показано, как извлечь связи, определенные для пакета.  Полный пример см. в разделе [пример чтения пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="relationshipType" /> равен пустой строке.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает пакет.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <summary>Открывает пакет с указанным путем и именем файла.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами по умолчанию <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, и <xref:System.IO.FileShare.None> (для указания различных атрибутов используйте один из других перегрузок метода Open).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода в указанном файловом режиме.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимое значение параметра <paramref name="packageMode" />.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути в указанном файловом режиме.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами по умолчанию <xref:System.IO.FileAccess.ReadWrite> и <xref:System.IO.FileShare.None> (для указания различных атрибутов используйте один из других перегрузок метода Open).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода с указанными значениями файлового режима и режима доступа к файлу.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> или <paramref name="packageAccess" /> является недопустимым.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути с указанными значениями файлового режима и режима доступа к файлу.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет по умолчанию <xref:System.IO.FileShare.None> атрибут (для указания использования другой атрибут <xref:System.IO.Packaging.Package.Open%2A> перегрузка метода).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как открыть и прочитать <xref:System.IO.Packaging.Package> , содержащий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример чтения пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> или <paramref name="packageAccess" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <param name="packageShare">Режим общего доступа, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути с указанными значениями файлового режима, режима доступа к файлу и режима общего доступа.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" />, <paramref name="packageAccess" /> или <paramref name="packageShare" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает основные свойства пакета.</summary>
        <value>Основные свойства пакета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о свойствах пакета core в разделе 3.1 в спецификации Open Packaging Conventions (OPC), можно загрузить в <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri"><see cref="T:System.Uri" /> проверяемой части.</param>
        <summary>Показывает, содержится ли часть с заданным URI в пакете.</summary>
        <returns><see langword="true" />, если часть с указанным <paramref name="partUri" /> находится в пакете, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` Должно начинаться с косой черты «/» и представлять абсолютный путь от корня пакета.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи (чтение информации невозможно).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> проверяемой связи.</param>
        <summary>Показывается, содержится ли в пакете связь уровня пакета с заданным идентификатором.</summary>
        <returns><see langword="true" />, если связь уровня пакета с указанным <paramref name="id" /> находится в пакете, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Данный член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для использования в приложениях.  Использовать вместо этого типобезопасный метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>