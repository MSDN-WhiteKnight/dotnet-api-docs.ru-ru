<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata><Meta Name="ms.openlocfilehash" Value="74963f79cec0337d355ae346abb7e05ee275ac99" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57913128" /></Metadata><TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type ResourceDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ISupportInitialize&#xA;    interface IUriContext&#xA;    interface INameScope" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет реализацию хэш-таблицы или словаря, содержащую ресурсы WPF, которые используются компонентами и другими элементами приложения WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы в <xref:System.Windows.ResourceDictionary> не обрабатываются немедленно при загрузке кода приложения с [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] загрузчика. Вместо этого <xref:System.Windows.ResourceDictionary> сохраняется как объект, и отдельные значения обрабатываются только в том случае, когда они запрашиваются специально.  
  
 <xref:System.Windows.ResourceDictionary> Класс не является производным от <xref:System.Collections.DictionaryBase>. Вместо этого <xref:System.Windows.ResourceDictionary> класс реализует <xref:System.Collections.IDictionary> , но зависит от <xref:System.Collections.Hashtable> внутренним образом.  
  
 В [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], <xref:System.Windows.ResourceDictionary> класс обычно является неявной коллекции элемент, который является значением элемента объекта из нескольких `Resources` свойства, получая в синтаксисе элемента свойства. Дополнительные сведения о неявных коллекциях в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], см. в разделе [XAML подробное описание синтаксиса](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Исключение — если вы хотите указать объединенный словарь; Дополнительные сведения см. в разделе [объединенные словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Другая возможная [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] используется для объявления словарь ресурсов как дискретные [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] файл и либо загружает его во время выполнения с помощью <xref:System.Windows.Markup.XamlReader.Load%2A> или включить его в проекте (с полным доверием) в качестве свободного файла или ресурса. В этом случае <xref:System.Windows.ResourceDictionary> может быть объявлен как объектный элемент, выступая в качестве корневого элемента [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Необходимо сопоставить соответствующие значения пространства имен XML (по умолчанию для [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] пространства имен и обычно `x:` для [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] пространства имен) на <xref:System.Windows.ResourceDictionary> элемент, если вы планируете использовать его в качестве корневого элемента. После этого можно добавить дочерние элементы, которые определяют ресурсы, каждый из которых [x: Key](~/docs/framework/xaml-services/x-key-directive.md) значение.  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Неявное использование коллекции XAML  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *resourcesProperty*  
 Задание свойства элемента, где тип значение этого свойства свойство <xref:System.Windows.ResourceDictionary>. Как правило, это `Resources` свойство <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, или <xref:System.Windows.Application> в случае ресурсы приложения.  
  
 *oneOrMoreResources*  
 Один или несколько ресурсов, заданного в качестве элементов объекта. Каждый ресурс должен иметь [директивы x: Key](~/docs/framework/xaml-services/x-key-directive.md) назначен.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="resourceDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Имя добавляемого ключа.</param>
        <param name="value">Значение добавляемого ресурса.</param>
        <summary>Добавляет ресурс по ключу для данного класса <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка добавления повторяющегося ключа приводит к появлению исключения.  
  
 Ключи всегда добавляются в базовый словарь. Ключи в <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> в текущем <xref:System.Windows.ResourceDictionary> не проверяются для дублирования, только базовый словарь, проверить наличие дублирующихся.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.ResourceDictionary" /> заблокирован или предназначен только для чтения.</exception>
        <exception cref="T:System.ArgumentException">Элемент с таким ключом уже существует в <see cref="T:System.Collections.Hashtable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="resourceDictionary.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинается этап инициализации для данного объекта <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода, чтобы указать, содержимое <xref:System.Windows.ResourceDictionary> должны быть загружены. Следующий шаг в процессе является вызов <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 Не вызывайте <xref:System.Windows.ResourceDictionary.BeginInit%2A> более одного раза, прежде чем вызвать <xref:System.Windows.ResourceDictionary.EndInit%2A>. Это приведет к появлению исключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.ResourceDictionary.BeginInit" /> вызван несколько раз, прежде чем был вызван метод <see cref="M:System.Windows.ResourceDictionary.EndInit" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="resourceDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все ключи (и значения) в базовом объекте <see cref="T:System.Windows.ResourceDictionary" />. Это не приводит к удалению элементов объединенного словаря.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если необходимо очистить элементов объединенного словаря, получить определенный словаря на основе <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> коллекции и вызвать специально <xref:System.Windows.ResourceDictionary.Clear%2A> об этом <xref:System.Windows.ResourceDictionary>, несмотря на то, что обычно являются удаленными словари и возможно, у вас нет доступа. Кроме того, полностью удалите <xref:System.Windows.ResourceDictionary> из <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> путем вызова Remove для универсальной коллекции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="resourceDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Ключ, который требуется найти в <see cref="T:System.Windows.ResourceDictionary" />.</param>
        <summary>Определяет, содержится ли элемент с указанным ключом в <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Windows.ResourceDictionary" /> содержит пару ключ-значение с указанным ключом, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если запрошенный раздел не существует в словаре ресурсов, логика подстановки ресурсов также проверит объединенных словарей.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="resourceDictionary.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив, в который копируются объекты <see cref="T:System.Collections.DictionaryEntry" />, из экземпляра <see cref="T:System.Windows.ResourceDictionary" />. Индекс в массиве должен начинаться с нуля.</param>
        <param name="arrayIndex">Нулевая индексация <paramref name="array" />, где начинается копирование.</param>
        <summary>Копирует элементы класса <see cref="T:System.Windows.ResourceDictionary" /> в одномерный массив класса <see cref="T:System.Collections.DictionaryEntry" /> с указанного индекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При этом копируются только базовый словарь. В массиве результатов будет содержать <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> если его воссоздается быть <xref:System.Windows.ResourceDictionary> еще раз.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.ResourceDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество записей в базовом словаре <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Текущее количество записей в базовом словаре.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeferrableContent : System.Windows.DeferrableContent with get, set" Usage="System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое, допускающее задержку, для этого словаря ресурсов.</summary>
        <value>Всегда возвращает значение <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="resourceDictionary.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершается этап инициализации, что делает недействительным предыдущее дерево. Это позволяет учесть все изменения ключей, выполненные во время этапа инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A> и <xref:System.Windows.ResourceDictionary.EndInit%2A> следуют модели транзакции. <xref:System.Windows.ResourceDictionary.BeginInit%2A> Помечает в словаре не инициализирована и <xref:System.Windows.ResourceDictionary.EndInit%2A> метки, для его инициализации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj&#xA;override this.FindName : string -&gt; obj" Usage="resourceDictionary.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Идентификатор имени для запрашиваемого объекта.</param>
        <summary>Не поддерживается этой реализацией словаря.</summary>
        <returns>Всегда возвращает значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Класс не поддерживает регистрации по имени. Вместо этого он использует ключи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Collections.IDictionaryEnumerator" />, который может использоваться выполнения итерации по элементам словаря <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <returns>Специальный перечислитель для <see cref="T:System.Windows.ResourceDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Итератор, является только базовый словарь.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InvalidatesImplicitDataTemplateResources : bool with get, set" Usage="System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, приводят ли недействительности, инициируемые объектом <see cref="T:System.Windows.Controls.ContentPresenter" />, к перепроверке выбранного шаблона объектами <see cref="T:System.Windows.ResourceDictionary" />. Недействительности возникают при неявном изменении ресурса шаблона данных.</summary>
        <value><see langword="true" />, если недействительности приводят к перепроверке выбранного шаблона объектами <see cref="T:System.Windows.Controls.ContentPresenter" />; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое показывает, имеет ли словарь <see cref="T:System.Windows.ResourceDictionary" /> фиксированный размер.</summary>
        <value>Возвращается значение <see langword="true" />, если хэш-таблица имеет фиксированный размер. В противном случае возвращается значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает <xref:System.Collections.Hashtable> по умолчанию, который является `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое показывает, доступен ли словарь <see cref="T:System.Windows.ResourceDictionary" /> только для чтения.</summary>
        <value>Значение <see langword="true" />, если хэш-таблица доступна только для чтения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает <xref:System.Collections.Hashtable> по умолчанию, который является `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.ResourceDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Ключ, который необходимо получить или установить.</param>
        <summary>Возвращает или задает значение, связанное с данным ключом.</summary>
        <value>Значение ключа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если запрошенный раздел не существует в словаре ресурсов, в системе ресурсов framework также проверит объединенных словарей.  
  
 Проверка <xref:System.Windows.ResourceDictionary> элемента или индекса обычно не является предпочтительным способом для извлечения ресурсов. Вместо этого следует вызывать методы, которые могут участвовать в процессе поиска ресурсов и найдите ресурсы, их ключи, а, можно найти ресурсы в приложениях или темы. <xref:System.Windows.FrameworkElement.FindResource%2A> Такой метод, а также присутствует на любом <xref:System.Windows.FrameworkElement>. В противном случае попытки поиска ресурса не соответствует значение true, поведение во время выполнения.  
  
 Тем не менее, получение ресурсов непосредственно из отдельного словаря может быть целесообразным, если вы пытаетесь получить ресурсы из известная <xref:System.Windows.ResourceDictionary> расположение и, чтобы избежать возможных производительности и область влияние на поиск ключа во время выполнения.  
  
 Индексаторы не используется для определения элементов коллекции в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Вместо этого создать дочерние элементы в разметке. Дочерние элементы являются либо дочерними элементами элемента <xref:System.Windows.ResourceDictionary>, или свойство элемента, где типом свойства является `ResourceDictionary`. Дополнительные сведения см. в разделе [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] разделы об использовании в <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех ключей, содержащихся в данном объекте <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Коллекция всех ключей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство существует, так как он необходим для <xref:System.Collections.IDictionary>, но <xref:System.Windows.ResourceDictionary.Keys%2A> обычно не подходит для большинства <xref:System.Windows.ResourceDictionary> сценариев.  
  
 Возвращаемые ключи не используйте ключи в <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Также ключей коллекции является моментальным снимком ключей в базовом словаре. Если впоследствии вы внесете изменения в это <xref:System.Windows.ResourceDictionary>, сохраненного <xref:System.Windows.ResourceDictionary.Keys%2A> не будет отражать изменения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedDictionaries : System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;" Usage="System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию словарей <see cref="T:System.Windows.ResourceDictionary" />, представляющих собой различные словари ресурсов в объединенных словарях.</summary>
        <value>Коллекция объединенных словарей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари объединяются, добавив <xref:System.Windows.ResourceDictionary> в универсальную коллекцию ссылается <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Объединенный <xref:System.Windows.ResourceDictionary> не имеет элементов ресурсов, определенных в нем в разметке. Вместо этого объединенного словаря является <xref:System.Windows.ResourceDictionary> нет дочерних элементов разметки определен (или без элементов, добавленных с помощью кода), но с [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] указанный для <xref:System.Windows.ResourceDictionary.Source%2A>. <xref:System.Windows.ResourceDictionary.Source%2A> Объединенный словарь из внешнего источника, например сборку отдельный ресурс, который поставляется с приложением, включает обозначение «свободные [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]«, или конкретных локализации или сборки глобальные ресурсы.  
  
 Указание элементов ресурсов в пределах <xref:System.Windows.ResourceDictionary> с <xref:System.Windows.ResourceDictionary.Source%2A> указанного не поддерживается.  
  
 Поведение подстановки в <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> коллекции будет искать добавить последнего <xref:System.Windows.ResourceDictionary> первая и поиск прекращается, как только запрошенный ключ найден. Не допускаются повторяющиеся ключи в коллекции объединенных словарей. Дополнительные сведения о поведении объединенных словарей, см. в разделе [объединенных словарей ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *oneOrMoreResourceDictionaries*  
 Один или несколько <xref:System.Windows.ResourceDictionary> объектных элемента. Объект <xref:System.Windows.ResourceDictionary> для <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> не имеет содержимого коллекции и указывает <xref:System.Windows.ResourceDictionary.Source%2A> атрибут, который ссылается на полный <xref:System.Windows.ResourceDictionary> удаленно.  
  
   
  
## Examples  
 В следующем примере указано два <xref:System.Windows.ResourceDictionary> элементы для объединения в основной <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberSignature Language="F#" Value="abstract member OnGettingValue : obj *  *  -&gt; unit&#xA;override this.OnGettingValue : obj *  *  -&gt; unit" Usage="resourceDictionary.OnGettingValue (key, value, canCache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" RefType="ref" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="canCache" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Ключ ресурса для получения.</param>
        <param name="value">Значение запрашиваемого ресурса.</param>
        <param name="canCache">Значение <see langword="true" />, если ресурс можно сохранить и использовать позже; в противном случае — значение <see langword="false" />.</param>
        <summary>Возникает, когда <see cref="T:System.Windows.ResourceDictionary" /> получает запрос на ресурс.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="resourceDictionary.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Не поддерживается.</param>
        <param name="scopedElement">Не поддерживается.</param>
        <summary>Не поддерживается этой реализацией словаря.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Класс не поддерживает регистрации по имени. Вместо этого он использует ключи. Методы области видимости имен XAML реализованы в виде нерабочие версии в <xref:System.Windows.ResourceDictionary> чтобы было ясно, что XAML имена не применяются к ресурсам.  
  
 Вызов этого метода приведет к <xref:System.NotSupportedException> исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Во всех случаях, когда вызывается этот метод.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="resourceDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Ключ записи, которую требуется удалить.</param>
        <summary>Удаляет запись с указанным ключом из базового словаря.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.ResourceDictionary> не содержит элемент с указанным ключом, <xref:System.Windows.ResourceDictionary> остается неизменным. Исключение не вызывается.  
  
 Этот метод не удаляет ключи из <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Необходимо получить конкретный <xref:System.Windows.ResourceDictionary> из коллекции, чтобы удалить те ключи, но, может оказаться невозможным, так как вы обычно обращаются к такой словарь удаленно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.ResourceDictionary" /> заблокирован или предназначен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.ResourceDictionary.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)], откуда должны загружаться ресурсы.</summary>
        <value>Исходное расположение внешнего словаря ресурсов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило <xref:System.Windows.ResourceDictionary.Source%2A> указывается как пакет URI, который ссылается на расположение словаря ресурсов, который включается в качестве некомпилированного ресурса или содержимое действия сборки, построение проекта приложения. Дополнительные сведения о формате URI пакета, см. в разделе [URI типа Pack в WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 Как правило <xref:System.Windows.ResourceDictionary.Source%2A> имеет значение только для <xref:System.Windows.ResourceDictionary> , указанный для <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> свойства (как элемент свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], или как <xref:System.Windows.ResourceDictionary> элемент коллекции в коде). В этом контексте значения <xref:System.Windows.ResourceDictionary.Source%2A> объединяет содержимое словаря, расположенный предоставленного [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] в текущий <xref:System.Windows.ResourceDictionary>. Любые сбои при загрузке вызовет исключение.  
  
   
  
## Examples  
 В следующем примере указано два <xref:System.Windows.ResourceDictionary> элементы для объединения в основной <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Отсчитываемый от нуля класс <see cref="T:System.Array" />, который получает элементы, скопированные из <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" />.</param>
        <param name="arrayIndex">Позиция в заданном <see cref="T:System.Array" />, начиная с которой в него будет помещаться копируемое содержимое.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.ResourceDictionary> приведен к типу интерфейса <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
        <value>Значение <see langword="true" />, если доступ к <see cref="T:System.Windows.ResourceDictionary" /> является синхронизированным (потокобезопасным), в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.ResourceDictionary> приведен к типу интерфейса <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Windows.ResourceDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.ResourceDictionary> приведен к типу интерфейса <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который используется для прохода по коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.ResourceDictionary> приведен к типу интерфейса <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System::Windows::Markup::IUriContext::BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>Базовый [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] текущего контекста.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Windows.ResourceDictionary> приведен к типу интерфейса <xref:System.Windows.Markup.IUriContext>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="resourceDictionary.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Не поддерживается.</param>
        <summary>Не поддерживается этой реализацией словаря.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Класс не поддерживает регистрации по имени. Вместо этого он использует ключи. Вызов этого метода не выполняет никаких действий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех значений, связанных с ключами в данном словаре <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Коллекция всех значений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство существует, так как он необходим для <xref:System.Collections.IDictionary>, но обычно не подходит для большинства <xref:System.Windows.ResourceDictionary> сценариев.  
  
 Возвращенные значения не указывайте значения в пределах <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Также в коллекции является моментальным снимком значений из базового словаря. Если впоследствии вы внесете изменения в это <xref:System.Windows.ResourceDictionary>, сохраненного <xref:System.Windows.ResourceDictionary.Values%2A> не будет отражать изменения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>