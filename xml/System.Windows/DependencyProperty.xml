<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0129b0c47acecd870bafaaa4655db115fee937a4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55372668" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет свойство, которое можно задать с помощью методов, например стили, привязки данных, анимации и наследование.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyProperty> поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Свойство может быть задано в стиле. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Свойство может устанавливаться через привязку данных. Дополнительные сведения о свойствах зависимостей привязки данных, см. в разделе [как: Привязка свойств двух элементов управления](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Свойство может быть задано со ссылкой на динамический ресурс. Дополнительные сведения см. в разделе [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Свойство может наследовать свое значение автоматически от родительского элемента в дереве элементов. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Свойства могут быть анимированы. Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Свойство может сообщать, когда предыдущее значение свойства было изменено, и можно ли привести значение свойства. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Свойство сообщает информацию для [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], такие как изменение значения свойства следует, требуется ли системе макета, чтобы представлять визуализации для элемента.  
  
-   Свойство получает поддержки в [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Например, можно изменить свойство в **свойства** окна.  
  
 Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Если вы хотите свойства на пользовательские типы для поддержки возможностей в списке выше, следует создать свойство зависимостей.  Чтобы научиться создавать пользовательские свойства взаимозависимости, см. в разделе [пользовательские свойства зависимости](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Присоединенное свойство — это свойство, которое включает любой объект, чтобы сообщить сведения о тип, который определяет присоединенное свойство. В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], любой тип, наследующий от <xref:System.Windows.DependencyObject> можно использовать независимо от того, является ли тип наследуется от типа, который определяет свойство присоединенное свойство. Присоединенное свойство — это функция [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] языка.  Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], использовать *Тип_владельца*. *propertyName* синтаксис. Пример присоединенного свойства — <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство. Если вы хотите создать свойство, которое может использоваться на всех <xref:System.Windows.DependencyObject> типов, а затем следует создавать присоединенное свойство. Дополнительные сведения о вложенных свойствах, в том числе о способах их создания, см. в разделе [зависимостей](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `dependencyPropertyName`  
 Строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> свойства нужные зависимости. Это может стоять префикс пространства имен XML, если свойство не существует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Строка, указывающая тип владельца свойства зависимостей, точка (.), а затем <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` может также предшествовать префикс пространства имен XML. Такое использование конкретной с поздним связыванием стили и шаблоны, где необходимо указать владельца свойства зависимостей для синтаксического анализа контекста, так как `TargetType` еще не известна. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Строковое значение, указывающее владельца присоединенного свойства, точка (.), а затем имя вложенного свойства. `attachedPropertyOwnerType` может также предшествовать префикс пространства имен XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован для типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, которое уже зарегистрировано.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств для распознавания свойства зависимостей для типа, который изначально не зарегистрировано это конкретное свойство зависимостей.  
  
 Как правило <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для добавления свойств зависимостей в классах, которые еще не предоставляют свойство зависимости через наследование управляемого класса (наследование класса вызовет свойства оболочки должны наследоваться от базового класса и, следовательно, разрешающие общей таблицы элементов доступ к свойству зависимостей уже). <xref:System.Windows.DependencyProperty.AddOwner%2A> позволяет системе свойств для распознавания свойства зависимостей для типа, который не зарегистрировало свойства зависимости, что изначально.  
  
 Эта подпись не позволяет указывать метаданные.  При использовании этого метода, автоматически создаются метаданные для нового <xref:System.Windows.DependencyProperty> и типом владельца. Метаданные автоматически генерируемым является результатом объединения метаданных из всех базовых типов, которые определено это свойство. Если нет объединенных метаданных, то используется значение по умолчанию метаданные для свойства. Если данное свойство зарегистрировано с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод, то метаданные по умолчанию совпадает со значением метаданных, который создается при <xref:System.Windows.DependencyProperty.RegisterAttached%2A> был вызван. В противном случае <xref:System.Windows.PropertyMetadata> создается объект с <xref:System.Windows.PropertyMetadata.DefaultValue%2A> свойство, значение по умолчанию тип свойства, а все остальные свойства <xref:System.Windows.PropertyMetadata> присваивается `null`. Используйте <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> подписи, если вы хотите предоставить метаданные для версии свойства зависимостей по мере добавления в указанный тип.  
  
 Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей, сохраняя идентификатор свойства зависимостей. Идентификатор предоставляет доступ к свойству зависимостей, если вы хотите вызвать системы свойств [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] со свойством зависимостей, особенно, когда он существует на добавляемый класс владельца. То же имя свойства для первоначального владельца и добавление владельца должен использоваться для указания аналогичную функциональность. Следует использовать <xref:System.Windows.DependencyProperty> возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> метод для определения идентификатора свойства зависимости, а также для объявления [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии, рекомендованная выше используется при создании свойства зависимостей, объявленных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойство зависимостей, которое имеют схожие функции. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> зависимости от первоначального владельца <xref:System.Windows.Controls.Border> и его зарегистрированных <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение используется для установления новую статическую <xref:System.Windows.DependencyProperty> поле (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства на добавление владельца и `BorderBrush` оболочки свойства также объявляется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <param name="typeMetadata">Метаданные, квалифицирующие свойство зависимостей в том виде, в котором оно существует в указанном типе.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей в том виде, в котором оно будет существовать в предоставленном типе владельца.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств для распознавания свойства зависимостей для типа, который изначально не зарегистрировано это конкретное свойство зависимостей.  
  
 Возвращаемое значение этого метода используется для объявления и предоставления свойства зависимостей, особенно в том случае, как оно существует в добавляемом классе владельца. Как правило одно и то же имя свойства для первоначального владельца и добавление владельца должен использоваться для указания аналогичную функциональность. Рекомендуется для предоставления идентификаторов, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии, рекомендованная выше используется при создании [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] объявлены внутри [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойство зависимостей, которое имеют схожие функции. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> на оригинал <xref:System.Windows.Controls.Border> и его зарегистрированных <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение используется для установления статический <xref:System.Windows.DependencyProperty> поле (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства на добавление владельца и `BorderBrush` оболочки свойства также объявляется.  
  
 Идентификатор свойства зависимостей добавление владельца следует использовать для операций, таких как <xref:System.Windows.DependencyObject.GetValue%2A>. Тем не менее, определенного типа операции, предполагающие или типов экземпляров класса, который был добавлен как владелец с разными метаданными будет по-прежнему возвращать даже если ожидаемые результаты исходного (не добавлены владельца) указанный идентификатор свойства зависимостей в вызовы методов, например <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Метаданные для Добавление владельца сохраняются по <xref:System.Windows.DependencyProperty.AddOwner%2A> вызвать сам себя, ссылается не обязательно исключительно поле идентификатора класса Добавление владельца. Тем не менее, рекомендуется предоставить идентификатор, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>, поскольку сделано несоответствие между [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представления свойств.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных, сохранятся. Только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются в случае, если они указаны в новые метаданные. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому поведения, описанного здесь не для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метаданные свойства зависимостей по умолчанию.</summary>
        <value>Метаданные свойства зависимостей по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные по умолчанию — это метаданные свойства, доступные для определенного объекта или объект производного типа, где альтернативные метаданные не предоставлен явно <xref:System.Windows.DependencyProperty.Register%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызова.  
  
 Если исходный владелец применения метаданных к первому <xref:System.Windows.DependencyProperty.Register%2A> вызова, которое установлено свойство зависимостей, то эти метаданные возвращаются в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Если метаданные не был применен в исходном <xref:System.Windows.DependencyProperty.Register%2A> вызова, то метаданные по умолчанию создается изнутри <xref:System.Windows.DependencyProperty.Register%2A> вызов и это значение возвращается в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Основной цели по умолчанию метаданные, связанные с <xref:System.Windows.DependencyProperty> — предоставить значение по умолчанию для этого свойства для какого-либо <xref:System.Windows.DependencyObject> или производный тип.  
  
 Для неприсоединенных свойств тип метаданных, возвращенный этим свойством не может быть приведен к производным типам из <xref:System.Windows.PropertyMetadata> тип, даже если свойство было изначально зарегистрировано с производным типом метаданных. Если требуется первоначально зарегистрированные метаданные, включая его исходному типу возможно производных метаданных, вызовите <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> вместо этого, передача исходной регистрации введите в качестве параметра.  
  
 Для присоединенных свойств тип метаданных, возвращенный этим свойством будет соответствовать тип, заданный в исходном <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод регистрации.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для данного свойства <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Хэш-код для этого экземпляра <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Система свойств использует свой собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, и значение этого свойства возвращается <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает метаданные, связанные с данным свойством зависимостей в том виде, в котором оно существует для конкретного типа. Это может быть тип, в котором свойство зависимостей было изначально зарегистрировано, тип, к которому оно было добавлено позже, или тип, в котором свойство зависимостей было получено путем наследования, но метаданные были переопределены.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Конкретный тип, из которого необходимо извлечь метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в котором оно представлено в указанном существующем типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект для использования в качестве типа является необходимым, поскольку метаданные могут отличаться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовы, изменять метаданные свойства зависимостей, как оно существует в типе.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, в зависимости от его типа. Этот тип получается с помощью `typeof` оператор.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Объект зависимости, проверяемый на наличие типа, чтобы определить, из какой типозависимой версии свойства зависимости нужно использовать метаданные.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде,в котором оно существует в указанном экземпляре объекта.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект необходима, так как метаданные любое заданное свойство зависимостей может варьироваться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые можно уточнить метаданные свойства, как оно существует в тип.  
  
 При запросе метаданных свойства на основе экземпляра, это просто передаются экземпляр таким образом, чтобы его тип может вычисляться внутренним образом. Метаданные свойства зависимостей не зависит от конкретного экземпляра; всегда является согласованным для любой комбинации типа и свойства.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, в зависимости от конкретного <xref:System.Windows.DependencyObject> экземпляра.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Специальный объект, который записывает тип объекта зависимости, из которого запрашиваются метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в каком они представлены в указанном типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект необходима, так как метаданные любое заданное свойство зависимостей может варьироваться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые можно уточнить метаданные свойства, как оно существует в тип.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, на основе его <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает внутреннее сгенерированное значение, уникальным образом идентифицирующее свойство зависимостей.</summary>
        <value>Уникальный числовой идентификатор.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение является целым числом, не является глобальным уникальным идентификатором (GUID). Как правило это значение индекса не является обязательным, и нет индекс доступа к таблицам всех свойств зависимостей. Свойства зависимостей вместо этого следует ссылаться их идентификатор поля.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> используется внутренне для более быстрого доступа к структурам данных, использующих <xref:System.Windows.DependencyProperty.GlobalIndex%2A> как массив, начинающийся с нуля индекс. Подобное использование может применяться для конструкторов или инструментов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа данного свойства зависимостей, проверяя его по типу свойства, указанного при исходной регистрации свойства зависимостей.</summary>
        <returns><see langword="true" />, если указанное значение принадлежит к зарегистрированному типу свойства или приемлемому производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `null` является допустимым типом для свойств зависимостей ссылочного типа или <xref:System.Nullable%601> свойства зависимостей и вернет `true` в этих случаях. В случаях, когда свойство зависимостей является ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidType%2A> как средство проверки перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа свойства, путем базовой проверки типа, а также, находится ли оно потенциально в пределах разрешенного диапазона значений для данного типа.</summary>
        <returns><see langword="true" />, если значение приемлемо и принадлежит к надлежащему или производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства зависимостей, можно указать разрешенный диапазон значений для этого типа с помощью <xref:System.Windows.ValidateValueCallback> , предоставляется при регистрации свойства зависимостей.  
  
 Этот метод вызывает метод <xref:System.Windows.DependencyProperty.IsValidType%2A> внутренним образом. Если рассматриваемое свойство зависимости не имеет <xref:System.Windows.ValidateValueCallback>, то вызов этого метода является фактически эквивалентна вызову <xref:System.Windows.DependencyProperty.IsValidType%2A>. Если свойство зависимости имеет <xref:System.Windows.ValidateValueCallback>и если <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращала бы `true`, то возвращаемое значение будет реализованное в обратный вызов.  
  
 Значение null является допустимым значением для свойства зависимостей типа ссылки или <xref:System.Nullable%601> свойства зависимостей и вернет `true` в этих случаях. В случаях, когда свойство зависимостей является ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidValue%2A> как средство проверки перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя свойства зависимостей.</summary>
        <value>Имя свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает имя, предоставленное как `name` параметр во время регистрации свойства зависимостей. Это имя является неизменяемым и не может быть `null` или является пустой строкой. Повторяющееся имя регистрации на один и тот же тип владельца не разрешены и вызовет исключение при попытке зарегистрировать дубликат.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Зависимости свойство должен соответствовать соглашению: соответствующее имени идентификатором свойства зависимостей без суффикса «Свойство». Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предоставляет альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа по сравнению с метаданными, предоставленными регистрацией первоначального свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <summary>Задает альтернативные метаданные для этого свойства зависимостей, если оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для данного свойства зависимостей в том виде, в котором оно было унаследовано от базовых типов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Система свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени, определенные экземпляры создаются с помощью класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статических конструкторах типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогично при создании экземпляра. Попытка изменить метаданные после экземпляров для типа владельца не возникнет исключения, но приведет к несогласованному поведению системы свойств.  
  
 После того как метаданные для определенного производного класса переопределения установлено с помощью этого метода, последующие попытки переопределить метаданные для этого же производного класса будет выдано исключение.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходные базовые метаданные сохраняются; только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если указан в новых метаданных. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому поведения, описанного здесь не для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка переопределения метаданных в доступном только для чтения свойстве зависимости (операция не может быть выполнена с помощью данной сигнатуры).</exception>
        <exception cref="T:System.ArgumentException">Метаданные уже были установлены для данного свойства зависимостей в том виде, в котором оно существует в предоставленном типе.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <param name="key">Ключ доступа для свойства зависимостей, доступного только для чтения.</param>
        <summary>Предоставляет альтернативные метаданные для свойства зависимостей, доступного только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, предоставленные при первоначальной регистрации свойства зависимостей. Вы должны передать <see cref="T:System.Windows.DependencyPropertyKey" /> для свойства зависимостей, доступного только для чтения, чтобы избежать возникновения исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись предоставляет базовую реализацию для идентификатора свойства зависимости только для чтения (<xref:System.Windows.DependencyPropertyKey>) метод. Если переопределение метаданных для свойства зависимостей для чтения и записи, используйте <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Система свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени создания конкретных объектов для класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статических конструкторах типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогично при создании экземпляра. Попытка изменить метаданные после экземпляров для типа владельца не возникнет исключения, но приведет к несогласованному поведению системы свойств.  
  
 После того как метаданные для определенного производного класса переопределения установлено с помощью этого метода, последующие попытки переопределить метаданные для этого же производного класса будет выдано исключение.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходные базовые метаданные сохраняются; только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если указан в новых метаданных. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. Поведение при объединении зависит от используемого для переопределения типа метаданных свойства. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства.</summary>
        <value>Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение было предоставлено во время регистрации свойства. Владельцем будет либо исходного регистрации типа в случае использования <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.Register%2A> вызова либо тип, который добавившего себя в качестве владельца в случае использования <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> С заданным <xref:System.Windows.DependencyProperty> является постоянным и не может быть `null` в допустимое <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере возвращается тип владельца, в зависимости от идентификатора свойства зависимостей `dp`, а затем получает метаданные для типа владельца по тому же идентификатору. Эта операция фактически эквивалентна начало <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> на `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, используемый свойством зависимостей для его значения.</summary>
        <value><see cref="T:System.Type" /> значения свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает тип значения свойства, объявленные в исходной регистрации свойства, через `propertyType` параметра. Аналогичную <xref:System.Windows.DependencyProperty.Name%2A>, тип свойства, свойства зависимостей, нельзя изменить после регистрации.  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.PropertyType%2A>. Строка имени типа <xref:System.Windows.DependencyProperty.PropertyType%2A> получается из возвращаемого <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли свойство зависимостей, идентифицируемое данным экземпляром <see cref="T:System.Windows.DependencyProperty" />, доступным только для чтения.</summary>
        <value><see langword="true" />, если свойство зависимостей доступно только для чтения; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства зависимостей только для чтения регистрируются в системе свойств путем вызова <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> метод, в отличие от <xref:System.Windows.DependencyProperty.Register%2A> метод. Вложенные свойства также можно зарегистрировать только для чтения; см. в разделе <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Свойства зависимостей только для чтения требуют <xref:System.Windows.DependencyPropertyKey> идентификатор вместо <xref:System.Windows.DependencyProperty> идентификатор для выполнения операций с метаданными, например переопределения метаданных или настройки значения. Если вы приобрели коллекцию <xref:System.Windows.DependencyProperty> идентификаторы, путем вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> или другой [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , предоставляющий идентификаторы, проверка <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение перед повторным вызовом <xref:System.Windows.DependencyObject.SetValue%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , используя идентификатор свойства зависимостей как входной параметр, чтобы убедиться, что свойства зависимостей, которое представляет идентификатор не только для чтения. Если значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> — `true` в свойстве зависимости, не существует способа для получения ссылки на программный <xref:System.Windows.DependencyPropertyKey> идентификатор этого свойства зависимостей, из метаданных или <xref:System.Windows.DependencyProperty> идентификатор; идентификатор Чтобы выполнить вызов должен быть доступен как статическое поле <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> свойством зависимостей только для чтения.  
  
 При создании настраиваемого свойства зависимостей и зарегистрировать его как доступный только для чтения, необходимо определить только метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] свойства-оболочки. В противном случае класс получит несогласованную объектную модель для оболочки свойства по сравнению с доступом к свойству зависимостей резервного. Дополнительные сведения см. в разделе [пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md) или [свойств зависимостей только для чтения](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию и идентификатора свойства зависимостей из различных полей свойства зависимостей и использует данные для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей. Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется свойство зависимости, включая обратный вызов проверки (определение обратного вызова не указывается; Дополнительные сведения об определении обратного вызова, см. в разделе <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство в системе свойств.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует присоединенное свойство с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется присоединенного свойства в абстрактный класс, с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <summary>Регистрирует присоединенное свойство с указанным именем и типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки значения свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 В следующем примере регистрируется присоединенного свойства в абстрактный класс, с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи. Это вложенное свойство является свойством типа перечисления и регистрации добавляет обратный вызов проверки, чтобы убедиться, что переданное значение имеет значение перечисления.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство зависимостей, предназначенное только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Только для чтения присоединенные свойства являются редко, так как основным сценарием для присоединенного свойства является его использование в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания присоединенного свойства не могут определяться [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей как вложенного заключается в поддержке наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, которые принадлежат к типу <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Только для чтения присоединенные свойства являются редко, так как основным сценарием для присоединенного свойства является его использование в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания присоединенного свойства не могут определяться [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей, как прикрепить вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей как свойство зависимостей только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Свойства зависимостей только для чтения — это довольно типичный сценарий обоих в существующем [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] и сценарии настройки, так как другие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функциям может требоваться свойство зависимостей, даже если это свойство не должно устанавливаться по вызывающие объекты. Значение свойства зависимостей только для чтения можно использовать как основу для других операций системы свойств, которые принимают свойства зависимостей, таких как создание основе <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется `AquariumSize` свойство зависимостей только для чтения. В примере определяется `AquariumSizeKey` как внутренний ключ (чтобы другие классы в сборке может переопределить метаданные) и предоставляет идентификатор свойства зависимостей на основе этого ключа как `AquariumSizeProperty`. Кроме того, создается оболочка для `AquariumSize`, с помощью только метода доступа get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Свойства зависимостей только для чтения — довольно типичный сценарий. Значение свойства зависимостей только для чтения можно использовать как основу для других операций системы свойств, которые принимают свойства зависимостей, таких как создание основе <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 Проверки в свойстве зависимостей только для чтения может быть менее важна. Уровень доступа к закрытым, указываемые для ключа снижает вероятность произвольного недопустимого ввода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление свойства зависимостей.</summary>
        <returns>Строковое представление свойства зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Windows.DependencyProperty.Name%2A> значение свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает статическое значение, используемое системой свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вместо <see langword="null" /> для указания того, что свойство существует, но его значение не задано системой свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет значение-метку, которая используется для сценариев, где [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] система свойств не удается определить запрошенный <xref:System.Windows.DependencyProperty> значение. <xref:System.Windows.DependencyProperty.UnsetValue> используется вместо `null`, так как `null` может быть является допустимым значением свойства, а также является допустимым (и часто используемые) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> на свойства зависимости в <xref:System.Windows.DependencyObject> применяется экземпляр, одно из следующих:  
  
-   Свойство зависимости имеет значение по умолчанию, установленное в метаданных и возвращается это значение. Это значение может быть получена из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Любое другое значение было установлено в системе свойств, и значение по умолчанию больше не нужны. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Установка <xref:System.Windows.PropertyMetadata.DefaultValue%2A> из <xref:System.Windows.DependencyProperty.UnsetValue> специально не допускается.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Возвращает <xref:System.Windows.DependencyProperty.UnsetValue> когда запрошенное свойство не задано локально.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет специальное значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>. Дополнительные сведения см. в разделе [проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 При привязке к базе данных, обратите внимание, что <xref:System.Windows.DependencyProperty.UnsetValue> не эквивалентен <xref:System.DBNull.Value>, аналогично тому, как <xref:System.DBNull.Value> не соответствует параметру значение true, значение null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает обратный вызов для проверки значения свойства зависимостей.</summary>
        <value>Обратный вызов для проверки значения данного свойства зависимостей, указанный параметром <paramref name="validateValueCallback" /> при изначальной регистрации свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство будет содержать `null` для любого свойства зависимостей нет зарегистрированного обратного вызова проверки.  
  
 Проверить значение, обратные вызовы должны действовать статически: проверка, применяемая через <xref:System.Windows.ValidateValueCallback> не может определить, является ли указанное значение допустимым для какой-либо экземпляр. Обратный вызов может определить только в том случае, следует ли не следует принимать предоставленное значение как допустимый все объекты, которые обладают свойством зависимостей. Если вам нужно выполнить проверку, которая зависит от того, знание значений других свойств зависимостей в определенном экземпляре, используйте <xref:System.Windows.CoerceValueCallback> вместо этого. <xref:System.Windows.CoerceValueCallback> Регистрируется как часть метаданных свойства зависимости, а не непосредственно в идентификатор свойства зависимостей. Дополнительные сведения см. в разделе [проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>