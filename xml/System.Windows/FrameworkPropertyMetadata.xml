<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474428" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Сообщает или применяет метаданные для свойства зависимостей, добавляя характеристики системы свойств, специфичные для платформы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс является производным от <xref:System.Windows.PropertyMetadata> (через <xref:System.Windows.UIPropertyMetadata>). Для большинства целей разработки приложений уровня платформы WPF <xref:System.Windows.FrameworkPropertyMetadata> тип, используемый для метаданных свойства зависимости, а не типы базовых метаданных <xref:System.Windows.PropertyMetadata> или <xref:System.Windows.UIPropertyMetadata>. Это справедливо как для существующих свойств зависимостей, так и для большинства настраиваемых сценариев свойств зависимостей.  
  
 Члены, объявленные в данном классе, дополнительный компонент <xref:System.Windows.PropertyMetadata> базового класса включают множество логических свойств, задающих или поведение системы свойств уровня среды WPF, например наследование свойств, привязка данных и макета отчета.  
  
 Несколько сигнатур конструкторов для создания <xref:System.Windows.FrameworkPropertyMetadata> принимают экземпляр <xref:System.Windows.FrameworkPropertyMetadataOptions> параметра. <xref:System.Windows.FrameworkPropertyMetadataOptions> Перечисления используется только для указания начальной поведения в конструкторе и после не предоставляется <xref:System.Windows.FrameworkPropertyMetadata> создается. Созданного экземпляра можно получить или задать соответствующую информацию через различные свойства, которые имеют имена из значений перечисления, используемые в вызове конструктора.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Этот класс обычно не используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей для определенного владельца как начальный базовый <xref:System.Windows.PropertyMetadata> типа. Эти метаданные приводится к <xref:System.Windows.FrameworkPropertyMetadata>. Если приведения возвращаемых является допустимым <xref:System.Windows.FrameworkPropertyMetadata>, а затем различные <xref:System.Windows.FrameworkPropertyMetadata> значения свойств передаются через простой пользовательский Интерфейс (не показано).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись инициализирует все значения <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> по умолчанию свойства. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> будет `null`и различных <xref:System.Windows.FrameworkPropertyMetadata> логическое свойства будут `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданным по умолчанию значением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и параметрами метаданных уровня платформы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения с пометкой флаги, заданные в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага, чтобы `true`. Впоследствии можно изменить значения свойств в метаданных, до тех пор, пока метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанными ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация вызывает базовый инициализатор, а затем добавляет `coerceValueCallback` , задав свойство в базовом экземпляре.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения с пометкой флаги, заданные в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага, чтобы `true`. По-прежнему можно изменить значения свойств в метаданных, до тех пор, пока метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения с пометкой флаги, заданные в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага, чтобы `true`. По-прежнему можно изменить значения свойств в метаданных, до тех пор, пока метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> данного свойства.</param>
        <param name="isAnimationProhibited">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Для разрешения анимации свойства следует установить значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами и логическим значением, которое может быть использовано для предотвращения анимации свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 `isAnimationProhibited` Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойство объявлено с помощью интерпретации базового <xref:System.Windows.UIPropertyMetadata> класса.  
  
 Значения с пометкой флаги, заданные в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага, чтобы `true`. По-прежнему можно изменить значения свойств в метаданных, до тех пор, пока метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается эта сигнатура конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <param name="isAnimationProhibited">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Значение по умолчанию — <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> для использования, когда привязки, примененные к данному свойству имеют <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> со значением <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами, логическим значением, которое может быть использовано для предотвращения анимации свойства и триггером обновления привязки данных по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должно соответствовать или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции. Система свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства значение по умолчанию — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 `isAnimationProhibited` Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойство объявлено с помощью интерпретации базового <xref:System.Windows.UIPropertyMetadata> класса.  
  
 Дополнительные сведения об обновлении поведения источника привязки, см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Значения с пометкой флаги, заданные в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага, чтобы `true`. По-прежнему можно изменить значения свойств в метаданных, до тех пор, пока метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на порядок размещения во время операций обработчика макета.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на порядок размещения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения ко всем свойствам зависимостей, существующих в элементе. Как часть этой логики, значение свойства зависимостей, которые изменяют вступают в силу и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> присвоено `true` будет инициировать запрос отложенного недействительным визуальные элементы для этого элемента (вызов <xref:System.Windows.UIElement.InvalidateArrange%2A>). Поскольку эта реализация уровня инфраструктуры WPF уже находится в месте, обычно не нужно искать свойств зависимостей с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> Если значительно замены или изменения поведения макетов уровня среды WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> выбрать реализаций аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> является `true`.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу измерения во время операций обработчика макета.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на передачу измерения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения ко всем свойствам зависимостей, существующих в элементе. Как часть этой логики, значение свойства зависимостей, которые изменяют вступают в силу и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> значение `true` будет инициировать запрос отложенного недействительным визуальные элементы для этого элемента. Поскольку эта реализация уровня инфраструктуры WPF уже находится в месте, обычно не нужно искать свойств зависимостей с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> Если значительно замены или изменения поведения макетов уровня среды WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> выбрать реализаций аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> является `true`.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу размещения разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу размещения непосредственно в родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения ко всем свойствам зависимостей, существующих в элементе. Как часть этой логики, значение свойства зависимостей, которые изменяют вступают в силу и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> значение `true` будет инициировать запрос отложенного недействительным визуальные элементы для родительского элемента.  
  
 Как правило, вы не требуется для отчета об изменениях из <xref:System.Windows.FrameworkElement> свойство в родительский элемент с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> так, как сам элемент должен уже иметь свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> как `true`. Обычно достаточно, поскольку изменения в дочернем элементе инициируют в родительском, когда это необходимо. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Иногда используется для <xref:System.Windows.FrameworkContentElement> производного класса. В данном случае элемент дочерние наборы свойство, в отличие от <xref:System.Windows.FrameworkContentElement> производного класса не контролирует собственные визуализации. Отрисовка обрабатывается <xref:System.Windows.FrameworkElement> родительского элемента, который служит в качестве узла содержимого. Например, изменение значения <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> присоединенное свойство, дочерний элемент делает недействительным упорядочить родительского элемента, так как необходимо изменить позицию дочернего элемента в родительском объекте. Таким образом <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> присоединенное свойство имеет метаданные где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> является `true`. Другой пример — <xref:System.Windows.Controls.Control.Padding%2A>; при этом изменения свойств родительского может изменить позицию дочернего элемента, в зависимости от доступного пространства.  
  
 Поскольку эта реализация уровня инфраструктуры WPF уже находится в месте, обычно не нужно искать свойств зависимостей с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Если значительно замены или изменения поведения макетов уровня среды WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> выбрать реализаций аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> является `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли свойство зависимостей потенциально влиять на передачу показателей разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу измерений непосредственно на родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения ко всем свойствам зависимостей, существующих в элементе. Как часть этой логики, значение свойства зависимостей, которые изменяют вступают в силу и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> значение `true` будет инициировать запрос отложенного недействительным визуальные элементы для родительского элемента. Поскольку эта реализация уровня инфраструктуры WPF уже находится в месте, обычно не нужно искать свойств зависимостей с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Если значительно замены или изменения поведения макетов уровня среды WPF.  
  
 Как правило, вы не требуется для отчета об изменениях из <xref:System.Windows.FrameworkElement> свойство в родительский элемент с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> так, как сам элемент должен уже иметь свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> как `true`. Это обычно достаточно, поскольку изменения в дочернем элементе инициируют передача мер родительского при необходимости. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Иногда используется для <xref:System.Windows.FrameworkContentElement> производного класса. В данном случае элемент дочерние наборы свойство, в отличие от <xref:System.Windows.FrameworkContentElement> производного класса не контролирует собственные визуализации. Отрисовка обрабатывается <xref:System.Windows.FrameworkElement> родительского элемента, который служит в качестве узла содержимого. Например, изменение значения <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> свойство дочерним элементом делает недействительным мер родительского элемента, так как относительное расстояние абзацев может изменять и может увеличить или уменьшить размер содержимого узла. Таким образом <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> свойство имеет метаданные где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> является `true`.  
  
 Элементы содержимого узла также часто проверяйте наличие изменений в свойства зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> является `true`, как часть логики отрисовки содержимого узла. Например <xref:System.Windows.Controls.TextBox> элемент должен отвечать на определенных изменений в текст, который может оказаться необходимым, ограничивающего прямоугольника <xref:System.Windows.Controls.TextBox> изменить сам.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> выбрать реализаций аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> является `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на общий макет таким способом, который не оказывает специального воздействия на расположение или размеры, но требует перерисовку.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, влияет на отрисовку; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения ко всем свойствам зависимостей, существующих в элементе. Как часть этой логики, значение свойства зависимостей, которые изменяют вступают в силу и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> значение `true` будет инициировать запрос отложенного недействительным визуальные элементы для этого элемента. Поскольку эта реализация уровня инфраструктуры WPF уже находится в месте, обычно не нужно искать свойств зависимостей с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> Если значительно замены или изменения поведения макетов уровня среды WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> выбрать реализаций аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> является `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, создает ли свойство двухсторонние привязки по умолчанию.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, создает двухсторонние привязки по умолчанию; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отсутствие этой из свойства `true`, обновления привязки являются односторонними по умолчанию, в зависимости от поведение по умолчанию <xref:System.Windows.Data.Binding> конструкторы или аналогичной [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис.  
  
 В существующих элементов, обычно можно найти это свойство установлено в `true` в метаданных для свойств зависимостей и сообщить о состоянии и можно изменять путем действий пользователя, например <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Это свойство сообщает только характеристики обновления привязки по умолчанию свойства зависимостей в целом. Любую привязку, задайте этому свойству экземпляра можно локально задать <xref:System.Windows.Data.Binding.Mode%2A> свойства привязки и изменить это значение по умолчанию.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение по умолчанию для <see cref="T:System.Windows.Data.UpdateSourceTrigger" />, который используется при привязке свойства к которому применены данные метаданные, с <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> имеющими значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Значение перечисления, кроме как <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Данному свойству присвоено значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; указанное значение будет считаться значением по умолчанию при получении запросов от привязок.</exception>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, наследуется ли значение свойства зависимостей.</summary>
        <value>Значение <see langword="true" />, если значение свойства может быть унаследовано; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наследование значения свойства — это функция [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системой свойств на уровне платформы WPF, при котором некоторые свойства зависимостей можно локально задать в элементе близка к корню [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] элемент дерева и затем их значений, наследуются все элементы в логическом дереве дочерних элементов, которые также обладают этим свойством. Наследование значения свойства не включена по умолчанию, и его подключение имеет некоторые последствия для производительности. Подробнее см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные разделениях в дереве среды выполнения не определено. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, поддерживается ли привязка данных для свойства зависимостей.</summary>
        <value>Значение <see langword="true" />, если привязка данных поддерживается для свойства зависимостей, к которому применяются эти метаданные; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает `false` для одного из двух возможных условий: привязка данных к свойству зависимостей не допускается, так как свойство зависимостей только для чтения (как указано в идентификатор свойства зависимостей, а не метаданных), или значение еще одно свойство метаданных, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, имеет значение `true` в этих метаданных. Это свойство предоставляется для удобства, чтобы вызывающие объекты не нужно проверять оба <xref:System.Windows.DependencyProperty.ReadOnly%2A> и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Если вы пытаетесь создать метаданные, указывающее, что свойство для чтения и записи, которое в противном случае следует поддерживает привязку данных, укажите флаг <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Обратите внимание, небольшая разница соглашение об именовании и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует эти сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, поддерживает ли свойство зависимостей привязку данных.</summary>
        <value>Значение <see langword="true" />, если свойство не поддерживает привязку данных; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство метаданных присваивается `true` для свойств, которые не должны поддерживать привязку данных, вне зависимости от свойств чтения и записи. Ожидается, что в большинстве случаев, где объявлен свойством зависимостей, привязка данных требуется, так как привязка данных является одним из основных сценариев, где полезно свойства зависимостей. В отличие от <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, при этом не изменяется просто значение по умолчанию, можно изменить позже на определенной привязки. Задание этого свойства `true` в метаданных для свойства зависимостей метаданные отключит все привязки применение значений с помощью выражений для этого свойства зависимостей.  
  
 Свойства зависимостей только для чтения не поддерживают привязку данных (из-за наличия не метод задания, который можно применить измененные значения), но отчет будет по-прежнему `false` для <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Это обусловлено тем, свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> значения сообщит о четности с помощью как метаданные были фактически установлены, вместо того, чтобы всегда reporting результирующем поведении, именование свойства может подразумеваться. Чтобы определить, разрешает ли указанному свойству зависимостей привязки данных, обычно следует проверить <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> вместо этого. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> — Это удобный инструмент для проверки оба <xref:System.Windows.DependencyProperty.ReadOnly%2A> и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> как одна операция, давая ожидаемый результат.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, содержит ли это свойство сведения о ведении журнала, которые приложения могут или должны хранить как часть реализации процесса ведения журнала.</summary>
        <value>Значение <see langword="true" />, если ведение журнала должно быть выполнено для свойства зависимостей, к которому применяются эти метаданные; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Базовые метаданные для слияния.</param>
        <param name="dp">Свойство зависимостей, к которому применяются эти метаданные.</param>
        <summary>Обеспечивает слияние исходных метаданных с базовыми.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне, при переопределении метаданных.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.PropertyMetadata" /> (или данный класс в особенности) должны переопределять этот метод, чтобы учесть все свойства метаданных, добавленных в их реализации. Например, реализация может добавлять новое значение флагового перечисления и <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализации затем должны иметь возможность правильно объединить эти флаги.  
  
Всегда вызовите базовую реализацию до собственную реализацию, так как базовая реализация берет на себя все свойства, уже определенные в предыдущих типов в иерархии.  
  
Поведение, добавленные <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализации в <see cref="T:System.Windows.FrameworkPropertyMetadata" /> является то, что определенные свойства уровня среды WPF в метаданные, такие как <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> объединяются в побитовой операции или.  
  
<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Поведение также реализует поведение, при переопределении метаданных свойства для существующего свойства зависимостей путем вызова <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, с помощью переопределения метаданных, <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. В случае с метаданными по умолчанию, значение может быть <see langword="null" />.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все изменения структуры данных <xref:System.Windows.FrameworkPropertyMetadata> экземпляр должен быть помечен как к неизменяемым при вызове этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkPropertyMetadata" /> Реализация этого метода не выполняет никаких действий за вызов базовой реализации.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должно ли вычисление наследования значения свойства охватывать определенные границы содержимого в логическом дереве элементов.</summary>
        <value>Значение <see langword="true" />, если наследование значения свойства должно охватывать определенные границы содержимого; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти метаданные сообщает редких изменениях, чтобы наследование значений свойств через границы элемента специальный родительский-дочерний элемент. Каноническим примером таких пределах представляет собой содержание <xref:System.Windows.Controls.Frame>, где <xref:System.Windows.Controls.Frame> содержимое может получить перезагружен независимо от существования <xref:System.Windows.Controls.Frame>. Поведение системы требуемого свойства — что наследование значения свойства не должны проходить в содержимое <xref:System.Windows.Controls.Frame>, так как им могут быть элементы, которые приложению не владеете или управляете. Указание метаданных с <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> присвоено `true`, а также как указание <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> как `true`, вызовет свойство, к которому применяется метаданные к наследуемому даже в <xref:System.Windows.Controls.Frame> границ или аналогичные границ.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после метаданных используется как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, влияют ли подсвойства свойства зависимостей на отрисовку вмещающего объекта.</summary>
        <value>Значение <see langword="true" />, если изменения значений подсвойств не влияют на отрисовку; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр метаданные относятся к свойствам зависимостей, которые являются ссылочными типами, где тип имеет собственные значения свойства. Как правило логика системы макета — предполагается, что любое свойство зависимостей с подсвойства, влияет на макет, так как проверка всех подсвойств для изменения занимает больше времени чем другой прохода отрисовки. Установка данного параметра равным `true` позволяет оптимизировать производительность реализация системы уровня макета WPF.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в модели объектов чтения и записи. Это, поэтому их можно изменить после инициализации экземпляра. Однако после исчерпания метаданные как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>