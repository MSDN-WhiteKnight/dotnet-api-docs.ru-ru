<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1c50a8a6bf5de1650ec4db222d0e7fe52ea28ad" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57915455" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, участвующий в системе свойств зависимостей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> Класса включает [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] служб системы свойств на многих производных от него.  
  
 Основной функцией системы свойств является для вычисления значения свойств и Системное уведомление о значениях, которые были изменены. Другой класс ключа, участвующий в системе свойств является <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> позволяет регистрации свойства зависимостей в системе свойств и предоставляет идентификации и сведениями о каждом свойстве зависимостей, в то время как <xref:System.Windows.DependencyObject> как базовый класс позволяет объектам использовать свойства зависимостей.  
  
 <xref:System.Windows.DependencyObject> службы и характеристики включают следующее:  
  
-   Поддержка размещения свойств зависимостей. Регистрируется свойство зависимости путем вызова <xref:System.Windows.DependencyProperty.Register%2A> метод и сохранения возвращаемого значения метода как открытое статическое поле в классе.  
  
-   Поддержка размещения вложенных свойств. Регистрация вложенного свойства зависимостей путем вызова <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод и сохранения возвращаемого значения метода как открытое статическое поле только для чтения в классе. (Существуют также дополнительные требования к членам; Обратите внимание на то, что это относится к [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] конкретной реализации для присоединенных свойств. Дополнительные сведения см. в разделе [зависимостей](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Затем можно задать присоединенное свойство для любого класса, производного от <xref:System.Windows.DependencyObject>.  
  
-   Get set и очистить служебные методы для значения всех свойств зависимостей, которые существуют на <xref:System.Windows.DependencyObject>.  
  
-   Метаданные, приводимый поддержка значений, изменения свойств уведомлений и обратные вызовы переопределение для свойств зависимостей или присоединенного свойства. Кроме того <xref:System.Windows.DependencyObject> класс облегчает-owner метаданные свойства зависимостей.  
  
-   Общий базовый класс для классов, производным от <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, или <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, другого класса базовых элементов, имеет иерархию классов, который включает в себя <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Следующий пример является производным от <xref:System.Windows.DependencyObject> для создания нового абстрактного класса. Затем класс регистрирует присоединенное свойство и включает в себя элементы поддержки для этого присоединенного свойства.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Очищает локальное значение свойства.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Очищаемое свойство зависимости, указанное объектной ссылкой <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Очищает локальное значение свойства. Очищаемое свойство задается идентификатором <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка значения свойства, вызвав <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно обеспечивает свойства зависимостей значение по умолчанию, который указан в метаданных свойства зависимостей. Очистка свойства только очистку любого локального значения могли быть применены. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Приведенный ниже пример проходит все свойства, имеющие локального значения, заданные для объекта, затем вызывает <xref:System.Windows.DependencyObject.ClearValue%2A> для очистки значения каждого такого свойства.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ для очищаемого свойства зависимостей.</param>
        <summary>Очищает локальное значение свойства, доступного только для чтения. Очищаемое свойство задается объектом <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyPropertyKey> определяет свойство зависимостей только для чтения для операций системы свойств. Классы, определяющие свойства зависимости только для чтения, не должны предоставлять этот ключ в открытый доступ. Если открытый ключ обеспечит передачу открытого кода, отрицательное символов только для чтения свойства, методы, такие как <xref:System.Windows.DependencyObject.ClearValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A> можно вызвать вне класса или сборки, ссылающиеся на ключ.  
  
 Очистка значения свойства, вызвав <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно обеспечивает свойства зависимостей значение по умолчанию, который указан в метаданных свойства зависимостей. Очистка значения только очистку любого локального значения могли быть применены. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор приводимого свойства зависимостей.</param>
        <summary>Приводит значение указанного свойства зависимостей. Это осуществляется путем вызова какой-либо функции <see cref="T:System.Windows.CoerceValueCallback" />, указанной в метаданных свойства зависимостей, которое существует в вызывающем объекте <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В дополнение к явным образом, вызываемому посредством вызова метода <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> зависимости также вызывается свойство внутренне всякий раз, когда значение свойства зависимостей оценке по [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.  
  
 При вызове <xref:System.Windows.DependencyObject.CoerceValue%2A> метода, в конечном итоге вызываются принудительного обратного вызова значения для свойства, которое можно указать. Обычно будет вызывать <xref:System.Windows.DependencyObject.CoerceValue%2A> только в том случае, если вы знаете, что существует значение принудительного обратного вызова, и в том случае, если вы знаете критерии обратного вызова для приведения.  
  
 Наиболее распространенным сценарием для вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> находится в пределах класса свойство или обработки изменений обратных вызовов связанных свойств, которые влияют на значения друг друга в виде зависимых. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.CoerceValue%2A> в <xref:System.Windows.PropertyChangedCallback> реализация, которая используется в качестве <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> для различные свойства зависимостей для одного класса. Это распространенный подход для значения true добавления зависимостей между свойствами зависимостей.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение недопустимы, или их не существует.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</summary>
        <value><see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство полезно, если объект, который возвращается из метода с типом возвращаемого значения <xref:System.Windows.DependencyObject> и требуется для выполнения операций системы свойств конкретного на нем в зависимости от его типа. Например эффективнее вызывать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> с помощью <xref:System.Windows.DependencyObjectType> вместо [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] типа. <xref:System.Windows.DependencyObjectType> обеспечивает более быстрый поиск.  
  
   
  
## Examples  
 В следующем примере псевдокода `MySubClass` планирует, что дополнительные производные классы могут изменить значение по умолчанию `MyCustom` свойства зависимостей. Класс реализует конструктор по умолчанию, который может определить фактический производного класса, используя преимущества полиморфизм <xref:System.Windows.DependencyObjectType> значение каждый раз, когда этот конструктор используется в качестве средства создания экземпляров производного класса.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, является ли указанный <see cref="T:System.Windows.DependencyObject" /> эквивалентом текущего <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns><see langword="true" />, если два экземпляра одинаковы; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация является равенством ссылок только и не пытается вычислить равенство автономной свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет и затем запечатывает два basic <see cref="T:System.Object" /> методы: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Вызов переопределения <see cref="T:System.Object" /> реализаций, что приводит к поведению равенства объектов. Эти переопределения намеренно предназначена для предотвращения попыток для определения равенства значений для производных классов <see cref="T:System.Windows.DependencyObject" />. Значение равенства для <see cref="T:System.Windows.DependencyObject" /> никогда не будет точным, из-за присущей свойство значение изменяться возможности <see cref="T:System.Windows.DependencyObject" /> и его свойства зависимостей. Сюда входят основные [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функции, такие как привязка данных и [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает хэш-код для данного объекта <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет и затем запечатывает два <see cref="T:System.Object" /> методы: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Вызов переопределения <see cref="T:System.Object" /> реализаций, что приводит к поведению равенства объектов. Эти переопределения намеренно предназначена для предотвращения попыток для определения равенства значений для производных классов <see cref="T:System.Windows.DependencyObject" />. Значение равенства для <see cref="T:System.Windows.DependencyObject" /> никогда не будет точным, из-за присущей свойство значение изменяться возможности <see cref="T:System.Windows.DependencyObject" /> и его свойства зависимостей. Сюда входят основные [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функции, такие как привязка данных и [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает специализированный перечислитель для определения свойств зависимостей, которые локально установили значения для данного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Специализированный перечислитель локальных значений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *локальное значение* — любое значение свойства зависимостей, установленное с <xref:System.Windows.DependencyObject.SetValue%2A>, в отличие от других аспектов системы свойств.  
  
 <xref:System.Windows.LocalValueEnumerator> Получен путем вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> может использоваться для перечисления свойств, имеющих локально заданное значение на <xref:System.Windows.DependencyObject> экземпляра. Каждое такое свойство представляется в перечислителе с <xref:System.Windows.LocalValueEntry> объект, который имеет свойства, которые ссылаются на конкретный <xref:System.Windows.DependencyProperty> и его значения. Этот прием перечисления локально заданного значения могут использоваться для оптимизации или другой обработки локальных значений, например, чтобы определить, какие значения свойств <xref:System.Windows.DependencyObject> изменится, если они были очищены.  
  
> [!IMPORTANT]
>  Возвращенный <xref:System.Windows.LocalValueEnumerator> может содержать <xref:System.Windows.LocalValueEntry> записей для свойства зависимостей, которые доступны только для чтения, либо свойства зависимостей, где значения вычисляются системой свойств. Например, элемент visual framework, имеет ширину, установленное через макет будет сообщать локальное значение для <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Если вы получаете локальных значений, чтобы сбросить их, проверьте <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение на идентификатор свойства каждого <xref:System.Windows.LocalValueEntry> чтобы убедиться, что <xref:System.Windows.DependencyProperty> рассматриваемый не только для чтения.  
  
   
  
## Examples  
 Приведенный ниже пример проходит все свойства, имеющие локального значения, заданные для объекта, затем вызывает <xref:System.Windows.DependencyObject.ClearValue%2A> для очистки значения каждого такого свойства.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает текущее действующее значение свойства зависимостей в этом экземпляре <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Возвращает текущее действующее значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Действительное значение* является значением свойства, которое возвращается системой свойств любому вызывающему объекту, запрашивающему значение. Действительное значение является результатом вычисления всех возможных входных значений, которые участвуют в приоритет значений свойств системы системой свойств. Сюда входят приведение и анимация. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Этот метод никогда не вернет <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> Значение sentinel, используемый в разных характеристик внутри организации и иногда также предоставляются через обратные вызовы приведение системы свойств.  
  
 Если вы не уверены, какой должна быть типа свойства, можно запросить идентификатор запрошенного свойства зависимостей, чтобы определить, является более конкретный <xref:System.Windows.DependencyProperty.PropertyType%2A> , возвращаемое значение преобразуется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение были недопустимы, или указанного параметра <paramref name="dp" /> не существует.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, которое следует сделать недействительным.</param>
        <summary>Повторно вычисляет действующее значение для указанного свойства зависимостей</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, любые связанные и применимые <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции, зарегистрированные для этого свойства может быть вызван.  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> свойство, которое у локального значение не имеет смысла, так как локальное значение имеет приоритет над другими свойство системные вводы, за исключением анимации. Тем не менее, можно вызвать <xref:System.Windows.DependencyObject.ClearValue%2A>, затем вызвать <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> не обязательно применимы для многих сценариев свойств зависимостей. Если свойство зависимостей становится недопустимым из-за изменения значения в любом из компонентов, система свойств делает недействительной и автоматически повторно проверяет свойство зависимостей. Тем не менее, существуют по-прежнему соответствующие сценарии, где <xref:System.Windows.DependencyObject.InvalidateProperty%2A> полезно. В частности, можно использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> внутри привязкой к значению или свойство изменено обратного вызова для свойства зависимостей в другой. Можно также использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для принудительной повторной оценки привязки к источнику данных, которые не сможет реализовать рекомендуемый <xref:System.ComponentModel.INotifyPropertyChanged> механизм уведомлений (возможно при использовании классов данных, который не может быть производным от или где данными является статическим элемент).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.InvalidateProperty%2A> на пользовательское свойство, каждый раз, когда, участвующих в вычислениях недопустимое свойство изменении свойств. Это альтернативный способ вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> метод, поскольку аннулирования свойства также вызывает все зарегистрированные <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот экземпляр в данный момент запечатанным (доступным только для чтения).</summary>
        <value><see langword="true" />, если этот экземпляр запечатан; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение внутренним образом.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, которые содержат интересующий идентификатор свойства зависимости, метаданные свойства для соответствующего типа, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.DependencyObject" />. Конкретное свойство зависимости, которое изменилось, сообщается в данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего выявления изменения отдельных свойств или аннулирования свойств для каждого случая. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> предназначен для изменения общего шаблона недействительности, если известны определенные сведения о классификациях расширенных свойств. Например, изменения в <xref:System.Windows.Freezable> могут быть изменения в типы значений <xref:System.Windows.Freezable>, или могут быть вложенные свойства, где изменения находятся в другом <xref:System.Windows.Freezable> ссылки. <xref:System.Windows.Freezable> Переопределить реализацию проверки <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> использует внутренние сведения для определения свойств являются вложенными и предоставляет логику соответствующего базового класса в обоих случаях.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> потенциально вызывается много раз в течение жизненного цикла объекта. Таким образом, можно добиться повышения производительности для системы общее свойство, если переопределить метаданные свойств, а затем подключить <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции для отдельных свойств. Тем не менее, можно использовать, этот метод Если <xref:System.Windows.DependencyObject> включает значительное количество свойств зависимостей с взаимосвязанными значение, или если он содержит логику, такие как поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию. Если этого не сделать значительно отключит всего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, вызывая будут сообщены неверные значения.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает локальное значение свойства зависимостей, если таковое существует.</summary>
        <returns>Возвращает локальное значение, или значение-метку <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, если локальное значение не задано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует использовать <xref:System.Windows.DependencyObject.GetValue%2A> для наиболее типичных операций «get» для свойства зависимостей. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> не возвращает действительное значение в ряде где значение не было задано локально.  
  
 Значения, которые задаются стили, темы и шаблоны, значение по умолчанию из метаданных или наследование значения свойства не считаются локальными значениями. Тем не менее привязки и другие выражения считаются локальными значениями, после их вычисления.  
  
 Если локальное значение не задано, этот метод возвращает <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Если возвращаемое значение, отличное от <xref:System.Windows.DependencyProperty.UnsetValue>, вы можете запросить метаданные свойства запрошенной зависимости, чтобы определить, есть ли более конкретный тип, который возвращаемое значение может быть преобразован в.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает значение свойства зависимостей, не меняя источник значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется компонентом, который программно задает значение одного из собственных свойств без отключения объявленного использования свойства приложения. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Метод изменения эффективного значения свойства, но имеющиеся триггеры, привязки данных и стили будут продолжать работать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает локальное значение свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимостей, указанного идентификатором этого свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный тип не соответствует тип, объявленный для свойства зависимостей, как он изначально был зарегистрирован, создается исключение. `value` Параметр всегда должен иметь вид соответствующего типа.  
  
 Условия возникновения исключений потенциально влияют <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> обратный вызов, который существует на идентификатор свойства зависимостей, задаваемого свойства зависимостей. В противном случае — значение, предоставленное возможно, произошла ошибка Общие условия проверки типов (например, передача строки, когда собственный тип — Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор <see cref="T:System.Windows.DependencyPropertyKey" /> задаваемого свойства.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимости только для чтения, определяемое идентификатором <see cref="T:System.Windows.DependencyPropertyKey" /> свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись обычно используется при задании значений для свойств зависимостей только для чтения, которые определяются пользовательские классы. Как правило <xref:System.Windows.DependencyObject.SetValue%2A> вызывается только из типа, который зарегистрировал это свойство зависимости, который реализует внутренняя логика, которая предоставляет значения, указанного для свойства зависимостей. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Если указанный тип не соответствует тип, объявленный для свойства зависимостей, как он изначально был зарегистрирован, создается исключение. `value` Параметр всегда должен иметь вид соответствующего типа. Условия возникновения исключений потенциально влияют <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> обратный вызов, который существует на идентификатор свойства зависимостей, задаваемого свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере определяется свойство зависимостей только для чтения, наряду с `public static readonly` <xref:System.Windows.DependencyProperty> , предоставляющий необходимые воздействие только для чтения свойство потребителей и метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] программы-оболочки.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор для свойства зависимости, которое следует сериализовать.</param>
        <summary>Возвращает значение, которое указывает, следует ли процессам сериализации выполнять сериализацию значения для предоставленного свойства зависимостей.</summary>
        <returns><see langword="true" />, если значение переданного свойства зависимостей следует сериализовать; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` во всех случаях, когда свойство зависимостей было установлено на локальное значение <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Переопределения для этого метода может по-разному обрабатывать особые свойства зависимостей.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>