<Type Name="RichTextBox" FullName="System.Windows.Controls.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="17f292eb483186c1c0cec4ace253ccbb24b487c6" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933437" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Document")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет элемент управления с расширенным редактированием для работы с объектами <see cref="T:System.Windows.Documents.FlowDocument" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> — Это единственный поддерживаемый дочернего элемента для <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.RichTextBox> предусмотрена встроенная обработка восходящей <xref:System.Windows.UIElement.MouseUp> и <xref:System.Windows.UIElement.MouseDown> события.  Следовательно, пользовательские обработчики событий, которые прослушивают `MouseUp` или `MouseDown` события из <xref:System.Windows.Controls.RichTextBox> никогда не будет вызываться.  Если вам нужно реагировать на эти события, прослушивание по нисходящей <xref:System.Windows.UIElement.PreviewMouseUp> и <xref:System.Windows.UIElement.PreviewMouseDown> события вместо, или регистрировать обработчики с <xref:System.Windows.EventSetter.HandledEventsToo%2A> аргумент (Этот последний параметр доступен только через код). Не следует помечать событие как обработанное, если не отключить <xref:System.Windows.Controls.RichTextBox> собственного, обработка этих событий и имейте в виду, что это существенно повлияет на элементе управления [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Хотя <xref:System.Windows.Controls.RichTextBox> поддерживает копирование и вставка изображений, определенных сценариях, в настоящее время не поддерживаются и могут работать неправильно.  В следующей таблице перечислены эти сценарии и ожидаемые результаты.  
  
|Источник копирования изображения|Результат вставки изображения|  
|-----------------------|------------------------|  
|Источник изображения — графический метафайл|Не производится|  
|Источник данных использует относительный путь или ссылку|Вставляется искаженное или пустое изображение|  
|Ссылка на источник изображения не заканчивается ожидаемым обозначением формата изображения (. PNG. JPG. GIF)|Вставляется искаженное или пустое изображение|  
|Источник изображения скопирован из неправильного формата поля RTF|Ссылка на источник изображения будет вставлен (а не образа)|  
  
 Вставив содержимое HTML в <xref:System.Windows.Controls.RichTextBox> может привести к непредвиденному поведению, так как <xref:System.Windows.Controls.RichTextBox> использует формат RTF, вместо непосредственного использования в формате HTML.  
  
 Всегда перенос текста в <xref:System.Windows.Controls.RichTextBox>. Если не хотите, чтобы затем задайте перенос текста <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> на <xref:System.Windows.Documents.FlowDocument> которых превышает ширину <xref:System.Windows.Controls.RichTextBox>. Тем не менее при достижении ширину страницы текст по-прежнему переносится.  
  
 Горизонтальное и вертикальное выравнивание содержимого в <xref:System.Windows.Controls.RichTextBox> делается с помощью <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> и <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> свойства. Выравнивание <xref:System.Windows.Controls.RichTextBox> в макете страницы выполняется с помощью <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> и <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> свойства.  
  
 Полосы прокрутки не отображаются на <xref:System.Windows.Controls.RichTextBox> по умолчанию. Чтобы отобразить полосы прокрутки, задайте <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A> свойства <xref:System.Windows.Controls.ScrollBarVisibility.Visible> или <xref:System.Windows.Controls.ScrollBarVisibility.Auto>.  
  
 Как правило <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> событие должно использоваться, чтобы определить, когда текст в <xref:System.Windows.Controls.TextBox> или <xref:System.Windows.Controls.RichTextBox> изменяется, а не <xref:System.Windows.UIElement.KeyDown> как можно ожидать. Пример см. в статье [Практическое руководство. Определение изменения текста в TextBox](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md).  
  
 <xref:System.Windows.Controls.RichTextBox> поддерживает широкий набор команд клавиатуры. Список команд клавиатуры, см. в разделе <xref:System.Windows.Documents.EditingCommands>.  
  
 Свойства зависимостей для данного элемента управления могут быть заданы посредством стиля элемента управления по умолчанию.  Если свойство имеет значение стилем по умолчанию, может измениться со значения по умолчанию, когда элемент управления отображается в приложении. Стиль по умолчанию определяется, какая тема рабочего стола используется, когда приложение выполняется.  Дополнительные сведения см. в разделе [темы WPF по умолчанию](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 В следующем примере объявляется <xref:System.Windows.Controls.RichTextBox> , содержащий простой <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-xaml[RichTextBoxSnippets#_RTB_XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml#_rtb_xaml)]  
  
 [!code-csharp[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/CSharp/RichTextBoxExample.cs#richtextboxcodeonlyexample)]
 [!code-vb[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/visualbasic/richtextboxexample.vb#richtextboxcodeonlyexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый, определяемый по умолчанию экземпляр класса <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает пустой <xref:System.Windows.Documents.FlowDocument> связанный со свойством документа.  Этот пустой объект <xref:System.Windows.Documents.FlowDocument> содержит один объект <xref:System.Windows.Documents.Paragraph>, в котором содержится один объект <xref:System.Windows.Documents.Run> без текста.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox (System.Windows.Documents.FlowDocument document);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.FlowDocument document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor(System.Windows.Documents.FlowDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (document As FlowDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox(System::Windows::Documents::FlowDocument ^ document);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.RichTextBox : System.Windows.Documents.FlowDocument -&gt; System.Windows.Controls.RichTextBox" Usage="new System.Windows.Controls.RichTextBox document" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="document" Type="System.Windows.Documents.FlowDocument" />
      </Parameters>
      <Docs>
        <param name="document">Объект <see cref="T:System.Windows.Documents.FlowDocument" />, добавляемый в качестве начального содержимого нового элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Windows.Controls.RichTextBox" />, добавляя указанный объект <see cref="T:System.Windows.Documents.FlowDocument" /> в качестве начального содержимого.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование этого конструктора.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_constructor)]
 [!code-vb[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_constructor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer CaretPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer CaretPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretPosition As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ CaretPosition { System::Windows::Documents::TextPointer ^ get(); void set(System::Windows::Documents::TextPointer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaretPosition : System.Windows.Documents.TextPointer with get, set" Usage="System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает положение точки ввода.</summary>
        <value>Объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий положение точки ввода.  
  
По умолчанию точка ввода располагается в первой позиции вставки в начале содержимого элемента <see cref="T:System.Windows.Controls.RichTextBox" />. Дополнительные сведения о "позиции вставки" и других терминах позиционирования текста см. в разделе <see cref="T:System.Windows.Documents.TextPointer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример иллюстрирует использование этого свойства.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_caretposition)]
 [!code-vb[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_caretposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Была предпринята попытка установить для этого свойства значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Попытка установить в качестве значения свойства объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на позицию вне текущего документа.</exception>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FlowDocument Document { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FlowDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Document" />
      <MemberSignature Language="VB.NET" Value="Public Property Document As FlowDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FlowDocument ^ Document { System::Windows::Documents::FlowDocument ^ get(); void set(System::Windows::Documents::FlowDocument ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Documents.FlowDocument with get, set" Usage="System.Windows.Controls.RichTextBox.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FlowDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Windows.Documents.FlowDocument" />, представляющий содержимое элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Объект <see cref="T:System.Windows.Documents.FlowDocument" />, представляющий содержимое элемента <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
По умолчанию данное свойство определяет пустой объект <see cref="T:System.Windows.Documents.FlowDocument" />.  Этот пустой объект <see cref="T:System.Windows.Documents.FlowDocument" /> содержит один объект <see cref="T:System.Windows.Documents.Paragraph" />, в котором содержится один объект <see cref="T:System.Windows.Documents.Run" /> без текста.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 FlowDocument может размещаться только один <xref:System.Windows.Controls.RichTextBox>.  Указание одного документа нефиксированного формата в качестве содержимого нескольких <xref:System.Windows.Controls.RichTextBox> элементы управления не поддерживается.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование этого свойства.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_document)]
 [!code-vb[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_document)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Была предпринята попытка установить для этого свойства значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Попытка установить в качестве значения свойства объект <see cref="T:System.Windows.Documents.FlowDocument" />, представляющий содержимое другого элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство устанавливается при включенной блокировке изменений.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextSpellingErrorPosition (System.Windows.Documents.TextPointer position, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextSpellingErrorPosition(class System.Windows.Documents.TextPointer position, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorPosition (position As TextPointer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextSpellingErrorPosition(System::Windows::Documents::TextPointer ^ position, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorPosition : System.Windows.Documents.TextPointer * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetNextSpellingErrorPosition (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="position">Объект <see cref="T:System.Windows.Documents.TextPointer" />, обозначающий место, с которого следует начинать поиск следующей орфографической ошибки.</param>
        <param name="direction">Объект <see cref="T:System.Windows.Documents.LogicalDirection" />, задающий направление, в котором следует искать очередную орфографическую ошибку, начиная с указанного параметра <c>posision</c>.</param>
        <summary>Возвращает объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на следующую орфографическую ошибку в содержимом элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на следующую орфографическую ошибку в содержимом элемента <see cref="T:System.Windows.Controls.RichTextBox" />, или <see langword="null" />, если больше орфографических ошибок нет.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Объект <see cref="T:System.Windows.Point" />, задающий место, для которого извлекается <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <param name="snapToText">Если задано <see langword="true" />, данный метод всегда возвращает объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на ближайшую позицию вставки для заданного объекта <see cref="T:System.Windows.Point" />, независимо от того, находится ли этот объект <see cref="T:System.Windows.Point" /> внутри ограничивающего прямоугольника символа.  
  
Если задано <see langword="false" />, то этот метод возвращает <see langword="null" />, если заданный объект <see cref="T:System.Windows.Point" /> не попадает внутрь ни одного ограничивающего прямоугольника символа.</param>
        <summary>Возвращает объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на точку вставки, ближайшую к указанному положению.</summary>
        <returns>Объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на ближайшую позицию вставки для заданной точки, или <see langword="null" />, если параметр <paramref name="snapToText" /> имеет значение <see langword="false" /> и заданная точка <see cref="T:System.Windows.Point" /> не принадлежит ни к одному ограничивающему прямоугольнику символа. Обратите внимание, что возвращаемый объект <see cref="T:System.Windows.Documents.TextPointer" /> обычно определяет позицию между двумя символами. Свойство <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> возвращенного объекта <see cref="T:System.Windows.Documents.TextPointer" /> позволяет определить, которому из этих двух символов соответствует <see cref="T:System.Windows.Documents.TextPointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox> использует стандартный систему координат с началом отсчета в левом верхнем углу <xref:System.Windows.Controls.RichTextBox>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Возникает, если сведения о разметке для элемента <see cref="T:System.Windows.Controls.RichTextBox" /> устарели.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (position As TextPointer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : System.Windows.Documents.TextPointer -&gt; System.Windows.Controls.SpellingError" Usage="richTextBox.GetSpellingError position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий позицию и логическое направление, которые определяют символ, проверяемый на орфографические ошибки. Свойство <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> этого объекта <see cref="T:System.Windows.Documents.TextPointer" /> позволяет задать направление для проверяемого символа.</param>
        <summary>Возвращает объект <see cref="T:System.Windows.Controls.SpellingError" />, связанный с орфографической ошибкой (если она существует) в указанной позиции содержимого элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Controls.SpellingError" /> со сведениями об орфографической ошибке, обнаруженной в символе, положение которого определяется параметром <paramref name="position" />, или <see langword="null" />, если в указанном символе нет орфографических ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Documents.TextPointer> как `position` обычно определяет позицию между двумя символами. Используйте <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> свойство `position` для указания какой символ для проверки.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorRange">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextRange GetSpellingErrorRange (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextRange GetSpellingErrorRange(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorRange (position As TextPointer) As TextRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextRange ^ GetSpellingErrorRange(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorRange : System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="richTextBox.GetSpellingErrorRange position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Объект <see cref="T:System.Windows.Documents.TextPointer" />, указывающий позицию и логическое направление, которые определяют символ, проверяемый на орфографические ошибки. Свойство <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> этого объекта <see cref="T:System.Windows.Documents.TextPointer" /> позволяет задать направление для проверяемого символа.</param>
        <summary>Возвращает объект <see cref="T:System.Windows.Documents.TextRange" />, включающий слово с ошибкой (если оно существует) в указанной позиции содержимого элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Documents.TextRange" />, в который входит слово с ошибкой, включающее символ в позиции <paramref name="position" />, или <see langword="null" />, если в указанном символе нет орфографических ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Documents.TextPointer> как `position` обычно определяет позицию между двумя символами. Используйте <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> свойство `position` для указания какой символ для проверки.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabled">
      <MemberSignature Language="C#" Value="public bool IsDocumentEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDocumentEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDocumentEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDocumentEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDocumentEnabled : bool with get, set" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, может ли пользователь работать с объектами <see cref="T:System.Windows.UIElement" /> и <see cref="T:System.Windows.ContentElement" />, расположенными в элементе <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value><see langword="true" />, если пользователь может работать с объектами <see cref="T:System.Windows.UIElement" /> и <see cref="T:System.Windows.ContentElement" /> в элементе <see cref="T:System.Windows.Controls.RichTextBox" />, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> впервые появился в .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.CheckBox> и <xref:System.Windows.Controls.RichTextBox> , содержащий <xref:System.Windows.Documents.Hyperlink> и <xref:System.Windows.Controls.Button>.  <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> Свойство <xref:System.Windows.Controls.RichTextBox> привязан к <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> свойство <xref:System.Windows.Controls.CheckBox>.  Когда пользователь выбирает <xref:System.Windows.Controls.CheckBox>, пользователь может взаимодействовать с <xref:System.Windows.Controls.Button> и <xref:System.Windows.Documents.Hyperlink>. Когда пользователь удаляет <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.Button> и <xref:System.Windows.Documents.Hyperlink> отключены.  
  
 [!code-xaml[RTBIsDocumentEnabled#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RTBIsDocumentEnabled/VB/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDocumentEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDocumentEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDocumentEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDocumentEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDocumentEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает перечислитель, который может выполнять перебор логических дочерних элементов объекта <see langword="RichTextBox" />.</summary>
        <value>Перечислитель для логических дочерних элементов.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="richTextBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Структура <see cref="T:System.Windows.Size" />, в которой указываются ограничения на размер элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Вызывается для повторного измерения элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Структура <see cref="T:System.Windows.Size" />, указывающая на новый размер <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.Controls.Control.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="richTextBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает объект <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> для данного <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> для данного <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpiScaleInfo, System.Windows.DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpiScaleInfo, valuetype System.Windows.DpiScale newDpiScaleInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpiScaleInfo As DpiScale, newDpiScaleInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpiScaleInfo, System::Windows::DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="richTextBox.OnDpiChanged (oldDpiScaleInfo, newDpiScaleInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpiScaleInfo" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpiScaleInfo" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpiScaleInfo">Предыдущий параметр масштабирования.</param>
        <param name="newDpiScaleInfo">Новый параметр масштабирования.</param>
        <summary>Вызывается, когда изменяется значение DPI, с использованием которого отображается текстовое поле в формате RTF.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextSelection Selection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextSelection Selection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Selection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Selection As TextSelection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextSelection ^ Selection { System::Windows::Documents::TextSelection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Selection : System.Windows.Documents.TextSelection" Usage="System.Windows.Controls.RichTextBox.Selection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextSelection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Documents.TextSelection" />, содержащий текущий выделенный фрагмент элемента <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Объект <see cref="T:System.Windows.Documents.TextSelection" />, содержащий текущий выделенный фрагмент элемента <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
У возвращаемого по умолчанию объекта <see cref="T:System.Windows.Documents.TextSelection" /> свойство <see cref="P:System.Windows.Documents.TextRange.IsEmpty" /> имеет значение <see langword="true" />. Пустой объект <see cref="T:System.Windows.Documents.TextSelection" /> изображается в виде символа вставки в текстовой области без выделения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Documents.TextRange.Select%2A> метод на программное выделение содержимого.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование этого свойства.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_selection)]
 [!code-vb[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_selection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeDocument">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.ShouldSerializeDocument" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeDocument () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeDocument();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeDocument : unit -&gt; bool" Usage="richTextBox.ShouldSerializeDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, показывающее, должно ли быть сериализовано действительное значение свойства <see cref="P:System.Windows.Controls.RichTextBox.Document" /> в процессе сериализации объекта <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Значение <see langword="true" />, если свойство<see cref="P:System.Windows.Controls.RichTextBox.Document" /> должно сериализоваться; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект для добавления в качестве дочернего объекта.</param>
        <summary>Данный тип или член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Строка, которую требуется добавить в объект.</param>
        <summary>Данный тип или член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>