<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87eeecb8b8986cbce06930adde285bc5e388a5d1" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57956470" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет произвольно большое целое число со знаком.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Тип является неизменяемым типом, представляющим произвольно большое целое число, значение которого теоретически не имеет верхней или нижней границы. Члены <xref:System.Numerics.BigInteger> повторяют других целочисленных типов ( <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, и <xref:System.UInt64> типы). Этот тип отличается от других целочисленных типов в [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], которые имеют диапазон, заданный их `MinValue` и `MaxValue` свойства.  
  
> [!NOTE]
>  Так как <xref:System.Numerics.BigInteger> тип является неизменяемым (см. в разделе [Изменяемость и BigInteger-структура](#mutability)) и так как он не имеет верхней или нижней границы, <xref:System.OutOfMemoryException> может быть создано для любой операции, которое вызывает <xref:System.Numerics.BigInteger> значение расти слишком большой.  
  
## <a name="instantiating-a-biginteger-object"></a>Создание экземпляра объекта BigInteger  
 Можно создать экземпляр <xref:System.Numerics.BigInteger> объекта несколькими способами:  
  
-   Можно использовать `new` ключевое слово и предоставить любое значение целочисленного типа или с плавающей запятой в качестве параметра <xref:System.Numerics.BigInteger> конструктор. (Значения с плавающей запятой, усекаются, прежде чем они назначаются <xref:System.Numerics.BigInteger>.) В следующем примере показано, как использовать `new` ключевое слово для создания экземпляра <xref:System.Numerics.BigInteger> значения.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Можно объявить <xref:System.Numerics.BigInteger> переменной и назначить его значение так же, как бы любого числового типа, если это значение является целочисленным типом. В следующем примере используется назначение для создания <xref:System.Numerics.BigInteger> значение из <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Можно присвоить значение с плавающей запятой или decimal <xref:System.Numerics.BigInteger> объекта, если приведение значения, или преобразовать его. В следующем примере приводится (в C#) или явным образом преобразует (в Visual Basic) <xref:System.Double> и <xref:System.Decimal> значение <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Эти методы позволяют создавать экземпляры <xref:System.Numerics.BigInteger> только типы объектов, значение которого находится в диапазоне одного из существующих числовым. Можно создать экземпляр <xref:System.Numerics.BigInteger> объект, значение которого может превышать диапазон существующих числовых типов в одном из трех способов:  
  
-   Можно использовать `new` ключевое слово и предоставить массив байтов любого размера для <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> конструктор. Например:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Можно вызвать <xref:System.Numerics.BigInteger.Parse%2A> или <xref:System.Numerics.BigInteger.TryParse%2A> методы для преобразования строкового представления числа в <xref:System.Numerics.BigInteger>. Например:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Можно вызвать `static` (`Shared` в Visual Basic) <xref:System.Numerics.BigInteger> метод, который выполняет некоторые операции в числовом выражении и возвращает вычисляемые <xref:System.Numerics.BigInteger> результат. Следующий пример делает это путем cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> и присваивание результата для <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Значение неинициализированной <xref:System.Numerics.BigInteger> является <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Выполнение операций над значениями BigInteger  
 Можно использовать <xref:System.Numerics.BigInteger> экземпляра так же, как любой целочисленный тип. <xref:System.Numerics.BigInteger> перегружает стандартные числовые операторы для выполнения основных математических операций, таких как сложение, вычитание, деление, умножение, вычитание, отрицание и Унарное отрицание. Вы также можете использовать стандартные числовые операторы для сравнения двух <xref:System.Numerics.BigInteger> значения друг с другом. Другие целочисленные типы, такие как <xref:System.Numerics.BigInteger> также поддерживает побитового `And`, `Or`, `XOr`, shift и операторы сдвига вправо. Для языков, которые не поддерживают пользовательские операторы <xref:System.Numerics.BigInteger> структура также предоставляет эквивалентные методы для выполнения математических операций. К ним относятся <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>и несколько других.  
  
 Многие члены <xref:System.Numerics.BigInteger> структура напрямую соответствуют членами других целочисленных типов. Кроме того <xref:System.Numerics.BigInteger> добавляет члены следующего вида:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, который возвращает значение, указывающее знак <xref:System.Numerics.BigInteger> значение.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, который возвращает абсолютное значение <xref:System.Numerics.BigInteger> значение.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, который возвращает частное и остаток от операции деления.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, который возвращает наибольший общий делитель двух <xref:System.Numerics.BigInteger> значения.  
  
 Многие из этих дополнительных членов соответствуют членам <xref:System.Math> класс, который предоставляет функциональные возможности для работы с числовых типов-примитивов.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Изменяемость и BigInteger-структура  
 В следующем примере создается <xref:System.Numerics.BigInteger> объекта и затем увеличивает его значение на единицу.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Несмотря на то, что в этом примере отображается в том, чтобы изменить значение существующего объекта, это не так. <xref:System.Numerics.BigInteger> объекты являются неизменяемыми, означающее, что внутренне, среда CLR фактически создает новый <xref:System.Numerics.BigInteger> объекта и присваивает ей значение 1 больше, чем предыдущее значение. Затем этот новый объект возвращается вызывающему объекту.  
  
> [!NOTE]
>  Числовые типы в .NET Framework также являются неизменяемыми. Тем не менее поскольку <xref:System.Numerics.BigInteger> тип не имеет верхней или нижней границы, его значения может расширяться слишком большой и оказывают заметного влияния на производительность.  
  
 Несмотря на то, что этот процесс является прозрачным для вызывающего, она страдает производительность. В некоторых случаях, особенно когда повторяющиеся операции выполняются в цикле с очень больших <xref:System.Numerics.BigInteger> значения, снижения производительности может быть значительным. Например, в следующем примере операция выполняется несколько раз до миллионов раз и <xref:System.Numerics.BigInteger> значение увеличивается на единицу каждый раз при успешном выполнении операции.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 В таком случае можно повысить производительность путем выполнения всех промежуточных назначений <xref:System.Int32> переменной. Конечное значение переменной затем могут быть назначены <xref:System.Numerics.BigInteger> объекта после выхода из цикла. Ниже приведен пример.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Работа с массивами байтов и шестнадцатеричные строки  
 При преобразовании <xref:System.Numerics.BigInteger> значения в массив байтов, либо если массивы байтов, чтобы преобразовать <xref:System.Numerics.BigInteger> значения, необходимо учитывать порядок байтов. <xref:System.Numerics.BigInteger> Структура ожидает отдельных байтов в массив байтов в прямом порядке (то есть, младшие байты значения предшествуют более высокого порядка байтов). Вы можете приема-передачи <xref:System.Numerics.BigInteger> значение путем вызова метода <xref:System.Numerics.BigInteger.ToByteArray%2A> метод и передав получившийся в результате байт массив <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктора, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Для создания экземпляра <xref:System.Numerics.BigInteger> значение из массива байтов, представляющий значение некоторого целочисленного типа, можно передать целое значение в <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> и затем передайте полученный байтового массива в том, чтобы <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор. В следующем примере создается <xref:System.Numerics.BigInteger> значение из массива байтов, представляющий <xref:System.Int16> значение.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger> Структура предполагается, что отрицательные значения хранятся с помощью представления дополнение до двух. Так как <xref:System.Numerics.BigInteger> структура представляет числовое значение с не фиксированной длины, <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор всегда интерпретирует значащий бит последнего байта в массиве как бит знака. Чтобы предотвратить <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор с толку двух дополнением представлением отрицательное значение знака и величины представлением положительное значение, положительные значения в котором наиболее значащему разряду последнего байта в массиве байтов Обычно набор должен включать в себя дополнительные байт, значение которого равно 0. Например, 0xC0 0xBD 0xF0 0xFF является шестнадцатеричным представлением с прямым порядком байтов 1 000 000 или 4 293 967 296. Поскольку наиболее значимого бита последнего байта в этом массиве, значение массива байтов будет интерпретироваться по <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор в качестве-1,000,000. Для создания экземпляра <xref:System.Numerics.BigInteger> , значение которого задано положительное число, массив байтов, элементы которого являются 0xC0 0xBD 0xF0 0xFF 0x00 должно быть передано в конструктор. Это показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Байтовые массивы, созданные <xref:System.Numerics.BigInteger.ToByteArray%2A> метода из положительные значения включают этот байт очень нулевое значение. Таким образом <xref:System.Numerics.BigInteger> структуры можно гарантировать правильное обратное преобразование значений, их назначения и последующего восстановления из байтовых массивов, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Тем не менее, необходимо добавить этот дополнительный байтовый нулевое значение в массивы байтов, который динамически создаются разработчиком или возвращаемые методы, которые преобразуют целых чисел без знака в массивы байтов (такие как <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, и <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 При синтаксическом анализе в шестнадцатеричную строку, <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> и <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> методы предполагается, что если значащий бит первого байта в строке, или если первая цифра шестнадцатеричные строки представляет нижний четыре бита значение в байтах, значение равно представлены с помощью двух представление дополнения до единицы. Например «FF01» и «F01» представляют десятичное значение -255. Чтобы отличать положительное из отрицательные значения, положительные значения должен включать нулем. Соответствующие перегрузки <xref:System.Numerics.BigInteger.ToString%2A> при передаче строки формата «X», метод добавления начальных нулей в возвращаемой шестнадцатеричные строки для положительных значений. Это делает возможным выполнение цикла обработки <xref:System.Numerics.BigInteger> значения с помощью <xref:System.Numerics.BigInteger.ToString%2A> и <xref:System.Numerics.BigInteger.Parse%2A> методы, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Тем не менее, шестнадцатеричных строк, созданных вызывающими `ToString` методы других целочисленных типов или перегрузки <xref:System.Convert.ToString%2A> метод, который включают `toBase` параметр указывает знак значения или тип источника данных, из которого шестнадцатеричная строка является производным. Успешно создание экземпляров <xref:System.Numerics.BigInteger> значение из строки требует некоторой дополнительной логики. Следующий пример предоставляет одна возможная реализация.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив значений типа byte в прямом порядке байтов.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя значения в массиве типа byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отдельные байты в `value` массива должен быть в прямом порядке из младшего байта на старший байт. Например числовое значение 1,000,000,000,000 представляется, как показано в следующей таблице:  
  
|||  
|-|-|  
|Шестнадцатеричная строка|E8D4A51000|  
|Массив байтов (сначала минимальный индекс)|00 10 A5 D4 E8 00|  
  
 Большинство методов, которые преобразуют числовые значения в массив байтов, таких как <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> и <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, возвращающих массивы байтов в прямом порядке.  
  
 Конструктор ожидает положительные значения в массиве байтов для использования представление знака и величины, а отрицательные значения для использования двух представление дополнения до единицы. Другими словами если старший бит самого старшего байта в `value` имеет значение, полученный в результате <xref:System.Numerics.BigInteger> имеет отрицательное значение. В зависимости от исходного массива байтов это может привести к положительное значение, чтобы быть ошибочно интерпретирована как отрицательное значение. Байтовые массивы обычно создаются следующими способами:  
  
-   Путем вызова <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> метод. Поскольку этот метод возвращает массив байтов с самого старшего бита самого старшего байта в массиве равным нулю для положительных значений, нет возможности неправильной интерпретации положительного значения как отрицательное. Неизмененный байтовые массивы, созданные <xref:System.Numerics.BigInteger.ToByteArray%2A> всегда обратимость, когда они передаются в метод <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор.  
  
-   Путем вызова <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> метода и передача целое число со знаком в качестве параметра. Поскольку целых чисел со знаком обрабатывают представление знака и величины и представление дополнение до двух, нет возможности неправильной интерпретации положительного значения как отрицательное.  
  
-   Путем вызова <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> метода и передача целое число без знака в качестве параметра. Так как целые числа без знака, представлены только своей величиной, положительные значения могут быть ошибочно интерпретирована как отрицательные значения. Во избежание этой ошибочной интерпретации можно добавить значение нулевой длины в конец массива. В следующем разделе приведен пример.  
  
-   Создав массив байтов либо динамически или статически не обязательно вызова любого из предыдущих методов, или путем изменения существующего массива байтов. Чтобы предотвратить положительные значения ошибочно интерпретированы как отрицательные значения, можно добавить значение нулевой длины в конец массива.  
  
 Если `value` — это пустой <xref:System.Byte> массива, новый <xref:System.Numerics.BigInteger> инициализации объекта значение <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Если `value` — `null`, конструктор вызывает <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Numerics.BigInteger> объекта из массива байтов 5-элемент, значение которого равно {5, 4, 3, 2, 1}. Затем он отобразит <xref:System.Numerics.BigInteger> значение, представленное в виде десятичных и шестнадцатеричных чисел, на консоль. Сравнение входной массив с выходными данными текста позволяет понять, почему эта перегрузка <xref:System.Numerics.BigInteger> конструктор класса создает <xref:System.Numerics.BigInteger> объект, значение которого равно 4328719365 (или 0x102030405). Первый элемент массива байтов, значение которого равно 5, определяет значение младшего байта <xref:System.Numerics.BigInteger> объект, являющийся 0x05. Второй элемент массива байтов, значение которого равно 4, определяет значение для второй байт <xref:System.Numerics.BigInteger> объект, являющийся 0x04 и т. д.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 В следующем примере создается положительного и отрицательного <xref:System.Numerics.BigInteger> значений, они передаются в <xref:System.Numerics.BigInteger.ToByteArray%2A> метод, а затем восстанавливает исходное <xref:System.Numerics.BigInteger> значения из полученного байтового массива. Обратите внимание на то, что два значения представляются одинаковые байтовые массивы. Единственное различие между ними заключается в том, в значащий бит последнего элемента в массиве байтов. Этот бит имеет значение (значение байта — 0xFF), если массив создается на основе отрицательное <xref:System.Numerics.BigInteger> значение. Бит не задано (значение байта равно нулю), если массив создается на основе положительное <xref:System.Numerics.BigInteger> значение.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 В следующем примере показано, как убедитесь в том, что положительное значение не создается неправильно как отрицательное значение, добавив в байтах, значение которого равно нулю, в конец массива.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Десятичное число.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя значение <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат вызова этого конструктора идентична явного присвоения <xref:System.Decimal> значение <xref:System.Numerics.BigInteger> переменной.  
  
 Вызов этого конструктора может привести к потере данных; Дробная часть `value` усекается при создании экземпляра <xref:System.Numerics.BigInteger> объекта.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> конструктора для создания <xref:System.Numerics.BigInteger> объекта. Он определяет массив <xref:System.Decimal> значения, а затем передает каждого значения <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> конструктор. Обратите внимание, что <xref:System.Decimal> значение усекается вместо округления при его назначении <xref:System.Numerics.BigInteger> объекта.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение с плавающей точкой двойной точности.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя значение с плавающей запятой двойной точности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается при создании экземпляра <xref:System.Numerics.BigInteger> объекта.  
  
 Из-за недостатка точности <xref:System.Double> тип данных, вызвав этот конструктор может привести к потере данных.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате явного присвоения значению <xref:System.Double> значение <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> конструктора для создания <xref:System.Numerics.BigInteger> объекта. Также показывает потерю точности, которая может возникнуть при использовании <xref:System.Double> тип данных. Объект <xref:System.Double> назначается большое значение, которое затем присваивается <xref:System.Numerics.BigInteger> объекта. Как показывает вывод, это назначение включает потеря точности. Оба значения затем увеличиваются на единицу. Выход показывает, что <xref:System.Numerics.BigInteger> объекта отражает измененное значение, тогда как <xref:System.Double> не делает.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> имеет значение <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> или <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32-разрядное знаковое целое число.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя 32-разрядное знаковое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нет потери точности при создании экземпляра <xref:System.Numerics.BigInteger> объекта с помощью этого конструктора.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате присвоения значению <xref:System.Int32> значение <xref:System.Numerics.BigInteger>.  
  
 <xref:System.Numerics.BigInteger> Структура не имеет конструктора с параметром типа <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, или <xref:System.UInt16>. Тем не менее <xref:System.Int32> тип поддерживает неявное преобразование 8-разрядных и 16-разрядных целых чисел со знаком и без знака в 32-разрядных целых чисел со знаком. В результате этот конструктор вызывается, если `value` любой из этих четырех целых типов.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> конструктора для создания <xref:System.Numerics.BigInteger> значений в массиве 32-разрядных целых чисел. Также использует неявное преобразование, чтобы присвоить каждое значение 32-разрядное целое число, чтобы <xref:System.Numerics.BigInteger> переменной. Затем сравнивает два значения для определения того, что полученный в результате <xref:System.Numerics.BigInteger> значения совпадают.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64-разрядное целое число со знаком.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя 64-разрядное целое число со знаком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нет потери точности при создании экземпляра <xref:System.Numerics.BigInteger> объекта с помощью этого конструктора.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате присвоения значению <xref:System.Int64> значение <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> конструктора для создания <xref:System.Numerics.BigInteger> значений в массиве 64-разрядных целых чисел. Также использует неявное преобразование, чтобы присвоить каждое значение 64-разрядное целое число, чтобы <xref:System.Numerics.BigInteger> переменной. Затем сравнивает два значения для определения того, что полученный в результате <xref:System.Numerics.BigInteger> значения совпадают.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение с плавающей точкой одинарной точности.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя значение с плавающей запятой одиночной точности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается при создании экземпляра <xref:System.Numerics.BigInteger> объекта.  
  
 Из-за недостатка точности <xref:System.Single> тип данных, вызов этого конструктора может привести к потере данных.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате явного присвоения значению <xref:System.Single> значение <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> конструктора для создания <xref:System.Numerics.BigInteger> объекта. Также показывает потерю точности, которая может возникнуть при использовании <xref:System.Single> тип данных. Объект <xref:System.Single> назначается больших отрицательное значение, которое затем присваивается <xref:System.Numerics.BigInteger> объекта. Как показывает вывод, это назначение включает потеря точности. Оба значения затем увеличиваются на единицу. Выход показывает, что <xref:System.Numerics.BigInteger> объекта отражает измененное значение, тогда как <xref:System.Single> не делает.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> имеет значение <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> или <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">32-разрядное целое значение без знака.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя 32-разрядное целое число без знака.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нет потери точности при создании экземпляра <xref:System.Numerics.BigInteger> с помощью этого конструктора.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате присвоения значению <xref:System.UInt32> значение <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> конструктор и оператор присваивания для инициализации <xref:System.Numerics.BigInteger> значений в массиве 32-разрядных целых чисел. Затем он сравнивает два значения, чтобы продемонстрировать, что два метода инициализации <xref:System.Numerics.BigInteger> значение давать одинаковые результаты.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64-разрядное целое число без знака.</param>
        <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.BigInteger" />, используя 64-разрядное целое число без знака.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нет потери точности при создании экземпляра <xref:System.Numerics.BigInteger> с помощью этого конструктора.  
  
 <xref:System.Numerics.BigInteger> Значение, полученный в результате вызова этого конструктора, полученный в результате присвоения значению <xref:System.UInt64> значение <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> конструктора для создания <xref:System.Numerics.BigInteger> объект, значение которого равно <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Число.</param>
        <summary>Получает абсолютное значение объекта <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Абсолютное значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Абсолютное значение числа — это число без знака, как показано в следующей таблице.  
  
|Параметр `value`|Возвращаемое значение|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 <xref:System.Numerics.BigInteger.Abs%2A> Метод эквивалентен <xref:System.Math.Abs%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.Abs%2A> метод для преобразования <xref:System.Numerics.BigInteger> значение из двух дополнением представления в представление знака и величины до его сериализации в файл. Данные в файле затем десериализуется и назначенный для нового <xref:System.Numerics.BigInteger> объекта.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое из складываемых значений.</param>
        <param name="right">Второе из складываемых значений.</param>
        <summary>Складывает два значения <see cref="T:System.Numerics.BigInteger" /> и возвращает результат.</summary>
        <returns>Сумма <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Языки, не поддерживающих перегрузку операторов или пользовательские операторы могут использовать <xref:System.Numerics.BigInteger.Add%2A> метод для выполнения сложения с помощью <xref:System.Numerics.BigInteger> значения.  
  
 <xref:System.Numerics.BigInteger.Add%2A> Метод является полезным замены для оператора сложения, при создании экземпляра <xref:System.Numerics.BigInteger> переменной, назначив ей суммы, полученный в результате сложения, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Сравнивает два значения <see cref="T:System.Numerics.BigInteger" /> и возвращает целое значение, которое показывает, больше или меньше первое значение по сравнению со вторым или равно ему.</summary>
        <returns>Знаковое целое число, которое определяет относительные значения параметров <paramref name="left" /> и <paramref name="right" />, как показано в следующей таблице.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description>Значение <paramref name="left" /> меньше <paramref name="right" />.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="left" /> равняется <paramref name="right" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description>Значение <paramref name="left" /> больше значения <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что <xref:System.Numerics.BigInteger> тип имеет не фиксированный диапазон, выполняется сравнение <xref:System.Numerics.BigInteger> значения не характеризуется недостаточной точности, характеризующий сравнение чисел с плавающей запятой. В следующем примере сравниваются два <xref:System.Numerics.BigInteger> значения, которые отличаются на единицу и оба имеют из 1 896 цифр. <xref:System.Numerics.BigInteger.Compare%2A> Метод неправильно сообщает, что два значения не равны.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает значение данного экземпляра с другим значением и возвращает целое число, которое показывает, является ли значение данного экземпляра меньшим, большим или равным другому значению.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">64-разрядное знаковое целое число для сравнения.</param>
        <summary>Сравнивает данный экземпляр с 64-разрядным знаковым целым числом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньшим, большим или равным значению 64-битового знакового целого числа.</summary>
        <returns>Знаковое целое число, определяющее, как соотносятся между собой данный экземпляр и объект <paramref name="other" />. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Текущий экземпляр меньше значения параметра <paramref name="other" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Текущий экземпляр равен значению параметра <paramref name="other" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Текущий экземпляр больше значения параметра <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `other` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значения при <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> вызывается метод.  
  
   
  
## Examples  
 В следующем примере демонстрируется результат вызова метода <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> метод целыми значениями.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения.</param>
        <summary>Сравнивает данный экземпляр с другим экземпляром <see cref="T:System.Numerics.BigInteger" /> и возвращает целое число, которое показывает, является ли значение данного экземпляра меньшим, большим или равным значению указанного объекта.</summary>
        <returns>Знаковое целое число, определяющее, как соотносятся между собой данный экземпляр и объект <paramref name="other" />. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Текущий экземпляр меньше значения параметра <paramref name="other" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Текущий экземпляр равен значению параметра <paramref name="other" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Текущий экземпляр больше значения параметра <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Numerics.BigInteger.CompareTo%2A> реализует метод <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> метод. Используется универсальная коллекция объектов для упорядочения элементов в коллекции.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> для упорядочивания списка `StarInfo` объектов. Каждый `StarInfo` объект предоставляет сведения о имени звезды и расстояния от Земли в милях. `StarInfo` реализует <xref:System.IComparable%601> интерфейс, позволяющий `StarInfo` объектов следует отсортировать с универсальных классов коллекций. Его <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> реализации просто создает оболочку для вызова <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Следующий код создает экземпляр четыре `StarInfo` объектов и сохраняет их в универсальной <xref:System.Collections.Generic.List%601> объекта. После <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> вызывается метод, `StarInfo` объекты отображаются в порядке расстоянию от Земли.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного объекта.</summary>
        <returns>Знаковое целое число, определяющее, как соотносятся между собой текущий экземпляр и параметр <paramref name="obj" />. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Текущий экземпляр меньше значения параметра <paramref name="obj" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Текущий экземпляр равен значению параметра <paramref name="obj" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Текущий экземпляр больше значения параметра <paramref name="obj" /> или параметр <paramref name="obj" /> равен <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Numerics.BigInteger.CompareTo%2A> реализует метод <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> метод. Используется неуниверсальную коллекцию объектов для упорядочения элементов в коллекции.  
  
 `obj` Параметр должен иметь одно из следующих:  
  
-   Объект, тип которого во время выполнения равно <xref:System.Numerics.BigInteger>.  
  
-   <xref:System.Object> Переменной, значение которого равно `null`. Если значение `obj` параметр `null`, метод возвращает 1, означающее, что текущий экземпляр больше, чем `obj`.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> метод для сравнения <xref:System.Numerics.BigInteger> значение с каждым элементом в массиве объектов  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> не является объектом <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-разрядное целое число без знака для сравнения.</param>
        <summary>Сравнивает данный экземпляр с 64-разрядным целым числом без знака и возвращает целое число, которое показывает, является ли значение данного экземпляра меньшим или большим по сравнению со значением 64-битового целого числа без знака или равным ему.</summary>
        <returns>Целое число со знаком, определяющее, как соотносятся между собой данный экземпляр и объект <paramref name="other" />. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Текущий экземпляр меньше значения параметра <paramref name="other" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Текущий экземпляр равен значению параметра <paramref name="other" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Текущий экземпляр больше значения параметра <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Значение, которое необходимо разделить.</param>
        <param name="divisor">Значение, на которое необходимо разделить.</param>
        <summary>Делит одно значение <see cref="T:System.Numerics.BigInteger" /> на другое и возвращает результат.</summary>
        <returns>Частное от деления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A> Метод выполняет целочисленное деление; любой остаток от деления отбрасывается. Чтобы выполнить целочисленное деление, сохраняя остаток, вызовите <xref:System.Numerics.BigInteger.DivRem%2A> метод. Чтобы получить только остаток, вызовите <xref:System.Numerics.BigInteger.Remainder%2A> метод.  
  
 <xref:System.Numerics.BigInteger.Divide%2A> Метод может использоваться в языках программирования, не поддерживающих перегрузку операторов. Его поведение идентично поведению деления, используя оператор деления.  
  
   
  
## Examples  
 В следующем примере создается массив <xref:System.Numerics.BigInteger> значения. Затем он использует каждый элемент как частное в операции деления, которая использует <xref:System.Numerics.BigInteger.Divide%2A> метод, оператор деления (/) и <xref:System.Numerics.BigInteger.DivRem%2A> метод.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">Значение параметра <paramref name="divisor" /> равно нулю (0).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Значение, которое необходимо разделить.</param>
        <param name="divisor">Значение, на которое необходимо разделить.</param>
        <param name="remainder">После выполнения данного метода содержит значение <see cref="T:System.Numerics.BigInteger" />, представляющее остаток от деления. Этот параметр передается неинициализированным.</param>
        <summary>Делит одно значение <see cref="T:System.Numerics.BigInteger" /> на другое, возвращает результат, а также возвращает остаток в виде параметра вывода.</summary>
        <returns>Частное от деления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сохраняет частное и остаток от деления целое число. Если вы не заинтересованы в остаток, используйте <xref:System.Numerics.BigInteger.Divide%2A> метода или оператор деления; если только вас интересует остаток, используйте <xref:System.Numerics.BigInteger.Remainder%2A> метод.  
  
 Возвращаемый знак `remainder` значение совпадает со значением знак `dividend` параметра.  
  
 Поведение <xref:System.Numerics.BigInteger.DivRem%2A> метод идентична <xref:System.Math.DivRem%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере создается массив <xref:System.Numerics.BigInteger> значения. Затем он использует каждый элемент как частное в операции деления, которая использует <xref:System.Numerics.BigInteger.Divide%2A> метод, оператор деления (/) и <xref:System.Numerics.BigInteger.DivRem%2A> метод.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">Значение параметра <paramref name="divisor" /> равно нулю (0).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, равны ли два числовых значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">64-разрядное целое число со знаком для сравнения.</param>
        <summary>Возвращает значение, определяющее, равны ли текущий экземпляр и 64-разрядное целое число со знаком.</summary>
        <returns>Значение <see langword="true" />, если 64-разрядное целое число со знаком и текущий экземпляр равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `other` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при вызове метода.  
  
 Чтобы определить связь между двумя объектами, вместо простой проверки на предмет равенства, вызовите <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Numerics.BigInteger> объекта из каждого целого типа, за исключением <xref:System.UInt64>. Затем он вызывает <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> метод для сравнения <xref:System.Numerics.BigInteger> значение исходное значение целое число, которое было передано <xref:System.Numerics.BigInteger> конструктор. Как показывает вывод, значения равны, в каждом конкретном случае.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения.</param>
        <summary>Возвращает значение, определяющее равны ли текущий экземпляр и указанный объект <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение <see langword="true" />, если значения данного объекта <see cref="T:System.Numerics.BigInteger" /> и объекта <paramref name="other" /> совпадают; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.IEquatable%601> интерфейс, а также выполняет немного лучше, чем <xref:System.Numerics.BigInteger.Equals%28System.Object%29> так, как его не требуется преобразовать `other` параметр <xref:System.Numerics.BigInteger> объекта.  
  
 Чтобы определить отношения между ними <xref:System.Numerics.BigInteger> объекты вместо простой проверки на равенство, вызывать <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере сравниваются приблизительное расстояние от нескольких звезд сравнивается с расстоянием Эпсилон араметр от земли, чтобы определить, равны ли они. В примере используется каждая перегрузка <xref:System.Numerics.BigInteger.Equals%2A> метод для проверки на равенство.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения.</param>
        <summary>Возвращает значение, определяющее, равны ли текущий экземпляр и указанный объект.</summary>
        <returns>Значение <see langword="true" />, если аргумент <paramref name="obj" /> — это объект <see cref="T:System.Numerics.BigInteger" />, и его значение равно значению текущего экземпляра <see cref="T:System.Numerics.BigInteger" />. В противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `obj` аргумент не является <xref:System.Numerics.BigInteger> значение, метод возвращает `false`. Этот метод возвращает `true` только если `obj` является <xref:System.Numerics.BigInteger> экземпляра, значение которого равен текущему экземпляру.  
  
 Чтобы определить связь между двумя объектами, вместо простой проверки на предмет равенства, вызовите <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> метод.  
  
   
  
## Examples  
 В следующем примере определяется параллельной <xref:System.Object> и <xref:System.Numerics.BigInteger> массивов. Каждый элемент массива имеет то же значение, что и соответствующий элемент второго массива. Как видно в результатах показано в примере, экземпляр в <xref:System.Numerics.BigInteger> массива считается равным экземпляру в <xref:System.Object> массив только в том случае, если последнее <xref:System.Numerics.BigInteger> и равны значения их.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-разрядное целое число без знака для сравнения.</param>
        <summary>Возвращает значение, определяющее, равны ли текущий экземпляр и 64-разрядное целое число без знака.</summary>
        <returns>Значение <see langword="true" />, если текущий экземпляр и 64-разрядное целое число без знака равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить связь между двумя объектами, вместо простой проверки на предмет равенства, вызовите <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере сравниваются приблизительное расстояние от нескольких звезд сравнивается с расстоянием Эпсилон араметр от земли, чтобы определить, равны ли они. В примере используется каждая перегрузка <xref:System.Numerics.BigInteger.Equals%2A> метод для проверки на равенство.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для текущего объекта <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое значение в вычитании.</param>
        <param name="right">Второе значение в вычитании.</param>
        <summary>Находит наибольший общий делитель двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Наибольший общий делитель значений <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наибольший общий делитель — наибольшее число, в котором два <xref:System.Numerics.BigInteger> значений можно разделить без остатка.  
  
 Если `left` и `right` параметры являются числами ненулевое значение, метод всегда возвращает по крайней мере значение 1, так как все числа, которые могут быть разделены на 1. Если один из параметров равно нулю, метод возвращает абсолютное значение параметра ненулевое значение. Если оба значения равны нулю, метод возвращает 0.  
  
> [!NOTE]
>  Наибольший общий делитель значений очень больших вычислений `left` и `right` может быть очень длительной операцией.  
  
 Значение, возвращенное <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> метод всегда является положительным, независимо от того, знак `left` и `right` параметров.  
  
   
  
## Examples  
 В следующем примере показан вызов <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> метод обработке ошибок и исключений необходимо предоставить полезную информацию о <xref:System.ArgumentOutOfRangeException>. Результат показывает, что наибольший общий делитель этих двух чисел равно 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, равно ли значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> четному числу.</summary>
        <value>Значение <see langword="true" />, если значение объекта <see cref="T:System.Numerics.BigInteger" /> равно четному числу; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство — это удобное средство, которое указывает, является ли <xref:System.Numerics.BigInteger> значение делится на два. Это эквивалентно следующее выражение:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Если значение текущего <xref:System.Numerics.BigInteger> объект <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, это свойство возвращает `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, равно ли значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> значению <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Numerics.BigInteger" /> имеет значение <see cref="P:System.Numerics.BigInteger.One" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обеспечивает лучшую производительность, чем другие сравнения вместе с одной, такие как `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, равно ли значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> степени двух.</summary>
        <value>Значение <see langword="true" />, если значение объекта <see cref="T:System.Numerics.BigInteger" /> равно степени двух; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство определяет, является ли <xref:System.Numerics.BigInteger> значение имеет один бит ненулевое значение. Это означает, что он возвращает `true` Если значение текущего <xref:System.Numerics.BigInteger> объект-1 (то есть 2<sup>0</sup>) или любой большей степени двух. Он возвращает `false` Если значение текущего <xref:System.Numerics.BigInteger> объекта равно 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, равно ли значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> значению <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Numerics.BigInteger" /> имеет значение <see cref="P:System.Numerics.BigInteger.Zero" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обеспечивает лучшую производительность, чем `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает логарифм указанного числа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Число, логарифм которого требуется найти.</param>
        <summary>Возвращает натуральный логарифм (с основанием <see langword="e" />) указанного числа.</summary>
        <returns>Натуральный (по основанию <see langword="e" />) логарифм числа <paramref name="value" />, как показано в таблице в разделе примечаний.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр указывается как десятичное число.  
  
 Точную возвращают значение этого метода зависит от знака `value`, как показано в следующей таблице.  
  
|Знак `value` параметр|Возвращаемое значение|  
|-------------------------------|------------------|  
|Положительное число|Натуральный логарифм `value`; то есть, ln `value`, или log`value`.|  
|Нуль|<xref:System.Double.NegativeInfinity>.|  
|Отрицательное число|<xref:System.Double.NaN>.|  
  
 Для вычисления логарифм по основанию 10 числа <xref:System.Numerics.BigInteger> значения, вызовите <xref:System.Numerics.BigInteger.Log10%2A> метод. Чтобы вычислить логарифм числа в другой системе счисления, вызовите <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> метод.  
  
 Квадратный корень числа можно найти, вызвав <xref:System.Numerics.BigInteger.Log%2A> метод вместе с <xref:System.Math.Exp%2A?displayProperty=nameWithType> метод. Обратите внимание, что в результате <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Если результат больше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>. В следующем примере вычисляется квадратный корень из каждого элемента в массиве <xref:System.Numerics.BigInteger> значения.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Этот метод соответствует <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Натуральный логарифм <paramref name="value" /> находится вне диапазона типа данных <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Число, логарифм которого должен быть найден.</param>
        <param name="baseValue">Основание логарифма.</param>
        <summary>Возвращает логарифм указанного числа в системе счисления с указанным основанием.</summary>
        <returns>Логарифм по основанию <paramref name="baseValue" /> числа <paramref name="value" />, как показано в таблице в разделе примечаний.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` И `baseValue` параметры задаются как десятичные основания.  
  
 Точную возвращают значение метода зависит от знака `value` и знака и значение `baseValue`, как показано в следующей таблице.  
  
|Параметр `value`|Параметр `baseValue`|Возвращаемое значение|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - или -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(любое значение)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(любое значение)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(любое значение)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(любое значение)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Для вычисления логарифм по основанию 10 числа <xref:System.Numerics.BigInteger> значения, вызовите <xref:System.Numerics.BigInteger.Log10%2A> метод. Чтобы вычислить натуральный логарифм числа, вызовите <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> метод.  
  
 Этот метод соответствует <xref:System.Math.Log%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Логарифм <paramref name="value" /> находится вне диапазона типа данных <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Число, логарифм которого должен быть найден.</param>
        <summary>Возвращает логарифм с основанием 10 указанного числа.</summary>
        <returns>Логарифм по основанию 10 числа <paramref name="value" />, как показано в таблице в разделе примечаний.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр указывается как десятичное число.  
  
 Точную возвращают значение метода зависит от знака `value`, как показано в следующей таблице.  
  
|Знак значения параметра|Возвращаемое значение|  
|-----------------------------|------------------|  
|Положительное число|Основание 10 логарифма `value`; то есть log10`value`.|  
|Нуль|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Отрицательное число|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Чтобы вычислить натуральный логарифм <xref:System.Numerics.BigInteger> значения, вызовите <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод. Чтобы вычислить логарифм числа в другой системе счисления, вызовите <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> метод.  
  
 Этот метод соответствует <xref:System.Math.Log10%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Десятичный логарифм <paramref name="value" /> находится вне диапазона типа данных <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает наибольшее из двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Большее из значений параметров <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод соответствует <xref:System.Math.Max%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.Max%2A> метод, чтобы выбрать наибольшее число в массиве <xref:System.Numerics.BigInteger> значения.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает наименьшее из двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Меньшее из значений параметров <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод соответствует <xref:System.Math.Min%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.Min%2A> метод, чтобы выбрать наименьшее число в массиве <xref:System.Numerics.BigInteger> значения.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее минус единицу (-1).</summary>
        <value>Целое число, равное минус единице (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A> Свойство используется для сравнения <xref:System.Numerics.BigInteger> значение-1 или -1, чтобы назначить <xref:System.Numerics.BigInteger> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Число, возведенное в степень <paramref name="exponent" />.</param>
        <param name="exponent">Показатель степени, в которую будет возведено значение <paramref name="value" />.</param>
        <param name="modulus">Число, на которое делится значение <paramref name="value" />, возведенное в степень <paramref name="exponent" />.</param>
        <summary>Выполняет модульное деление числа, возведенного в степень другого числа.</summary>
        <returns>Остаток от деления <paramref name="value" /><sup>exponent</sup> на <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A> Метод оценивает следующее выражение:  
  
 (базовое значение ^ экспоненты) Mod модуля  
  
 Для выполнения возведения в степень <xref:System.Numerics.BigInteger> использовать значения без Модульное деление <xref:System.Numerics.BigInteger.Pow%2A> метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует это вызова <xref:System.Numerics.BigInteger.ModPow%2A> метод.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> равен нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> является отрицательным значением.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое число для умножения.</param>
        <param name="right">Второе число для умножения.</param>
        <summary>Возвращает произведение двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Произведение параметров <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A> Метод реализуется для языков, не поддерживающих перегрузку операторов. Его поведение идентично поведению умножения, используя оператор умножения. Кроме того <xref:System.Numerics.BigInteger.Multiply%2A> метод является полезным заменой оператор умножения, при создании экземпляра <xref:System.Numerics.BigInteger> переменной, назначив ей продукта, полученный в результате умножения, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 При необходимости этот метод автоматически выполняет неявное преобразование для других целочисленных типов <xref:System.Numerics.BigInteger> объектов. Это показано в примере в следующем разделе, где <xref:System.Numerics.BigInteger.Multiply%2A> методу передается два <xref:System.Int64> значения.  
  
   
  
## Examples  
 В следующем примере предпринимается попытка выполнения умножения двух длинных целых чисел. Так как результат превышает диапазон типа данных long integer, <xref:System.OverflowException> возникает исключение и <xref:System.Numerics.BigInteger.Multiply%2A> метод вызывается для обработки умножения. Обратите внимание, что C# необходимо использовать либо `checked` ключевое слово (как в этом примере) или `/checked+` параметр компилятора, чтобы убедиться в том, создается исключение на переполнение числового значения.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Инвертируемое значение.</param>
        <summary>Меняет знак указанного значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Результат умножения параметра <paramref name="value" /> на минус единицу (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отрицание получает обратный добавочный номер. Аддитивная Инверсия числа — это число, которое выводит значение, равное нулю, если он добавляется в исходный номер.  
  
 <xref:System.Numerics.BigInteger.Negate%2A> Метод реализуется для языков, которые не поддерживают пользовательские операторы. Его поведение идентично поведению отрицания, с помощью оператора унарного отрицания. Кроме того <xref:System.Numerics.BigInteger.Negate%2A> метод является полезным заменой оператор отрицания при создании экземпляра <xref:System.Numerics.BigInteger> переменной, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 В следующем примере показано три способа Инвертируемое значение <xref:System.Numerics.BigInteger> объекта.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее единицу (1).</summary>
        <value>Целое число, равное единице (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A> Свойство обычно используется для сравнения <xref:System.Numerics.BigInteger> значение 1 или 1, чтобы назначить <xref:System.Numerics.BigInteger> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое из складываемых значений.</param>
        <param name="right">Второе из складываемых значений.</param>
        <summary>Складывает значения двух указанных объектов <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Сумма <paramref name="left" /> и <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Addition%2A> Метод определяет операцию сложения для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Add%2A> метод вместо этого.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое значение в вычитании.</param>
        <param name="right">Второе значение в вычитании.</param>
        <summary>Выполняет битовую операцию <see langword="And" /> для двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Результат битовой операции <see langword="And" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Метод определяет побитовое `And` операции для <xref:System.Numerics.BigInteger> значения. Побитовое `And` операция задает результирующий бит только тогда, когда соответствующие биты `left` и `right` также задаются, как показано в следующей таблице.  
  
|Бит в `left`|Бит в `right`|Бит в результате|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Метод включает следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Метод выполняет побитовое `And` операции над двумя <xref:System.Numerics.BigInteger> значения, как если бы они были в двух дополнением представление с расширением виртуального входа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое значение в вычитании.</param>
        <param name="right">Второе значение в вычитании.</param>
        <summary>Выполняет битовую операцию <see langword="Or" /> для двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Результат битовой операции <see langword="Or" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Метод определяет побитовое `Or` операции для <xref:System.Numerics.BigInteger> значения. Побитовое `Or` операция задает результирующий бит только тогда, когда один или оба соответствующих бита в `left` и `right` задаются, как показано в следующей таблице.  
  
|Бит в `left`|Бит в `right`|Бит в результате|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Метод включает следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Метод выполняет побитовое `Or` операции над двумя <xref:System.Numerics.BigInteger> значения, как если бы они были в двух дополнением представление с расширением виртуального входа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Уменьшаемое значение.</param>
        <summary>Уменьшает значение <see cref="T:System.Numerics.BigInteger" /> на 1.</summary>
        <returns>Значение параметра <paramref name="value" />, уменьшенное на 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Decrement%2A> Метода определяется операция декремента для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Subtract%2A> метод вместо этого. Например:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Так как <xref:System.Numerics.BigInteger> объекты являются неизменяемыми, <xref:System.Numerics.BigInteger.op_Decrement%2A> оператор создает новую <xref:System.Numerics.BigInteger> объект, значение которого является одним меньше, чем <xref:System.Numerics.BigInteger> объекта, представленного `value`. Это означает, что повторные вызовы <xref:System.Numerics.BigInteger.op_Decrement%2A> может быть затратным.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Значение, которое необходимо разделить.</param>
        <param name="divisor">Значение, на которое необходимо разделить.</param>
        <summary>Делит указанное значение <see cref="T:System.Numerics.BigInteger" /> на другое указанное значение <see cref="T:System.Numerics.BigInteger" />, используя целочисленное деление.</summary>
        <returns>Целочисленный результат деления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A> Метод определяет операцию деления для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Языки, которые не поддерживают пользовательские операторы и перегрузка операторов можно вызвать <xref:System.Numerics.BigInteger.Divide%2A> метод вместо этого.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается массив <xref:System.Numerics.BigInteger> значения. Затем он использует каждый элемент как частное в операции деления, которая использует <xref:System.Numerics.BigInteger.Divide%2A> метод, оператор деления (/) и <xref:System.Numerics.BigInteger.DivRem%2A> метод.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">Значение параметра <paramref name="divisor" /> равно нулю (0).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, равны ли два значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли длинное знаковое целое число и значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Метод определяет операцию сравнения на равенство для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> метод экземпляра.  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли значение <see cref="T:System.Numerics.BigInteger" /> и длинное знаковое целое число.</summary>
        <returns>Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Метод определяет операцию сравнения на равенство для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> метод экземпляра.  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли значения двух объектов <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Метод определяет операцию от оператора равенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод экземпляра.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли значение <see cref="T:System.Numerics.BigInteger" /> и длинное целое число без знака.</summary>
        <returns>Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Метод определяет операцию сравнения на равенство для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> метод экземпляра.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли длинное целое число без знака и значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Метод определяет операцию сравнения на равенство для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> метод экземпляра.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое значение в вычитании.</param>
        <param name="right">Второе значение в вычитании.</param>
        <summary>Выполняет битовую операцию исключающего <see langword="Or" /> (<see langword="XOr" />) для двух значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Результат битовой операции <see langword="Or" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат побитового исключающего `Or` операции `true` различны; в противном случае значения два бита, это `false`. В следующей таблице показано монопольной `Or` операции.  
  
|Бит x `left`|Бит x `right`|Возвращаемое значение|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Метод включает следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Метод выполняет побитовое исключающее `Or` операции над двумя <xref:System.Numerics.BigInteger> значения, как если бы они были в двух дополнением представление с расширением виртуального входа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет явное преобразование между объектом типа <see cref="T:System.Numerics.BigInteger" /> и другим типом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Decimal" /> в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается до преобразования.

 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Так как преобразование из <xref:System.Decimal> для <xref:System.Numerics.BigInteger> может включать в себя усечение дробная часть `value`, языковые компиляторы не выполняют это преобразование автоматически. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (например, `CType` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.   

 Для языков, которые не поддерживают пользовательские операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 В следующем примере преобразуется отдельных элементов в массиве <xref:System.Decimal> значения <xref:System.Numerics.BigInteger> объектов, а затем отображает результат каждого преобразования. Обратите внимание, что дробная часть <xref:System.Decimal> значение будет усечено во время преобразования.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет явное преобразование значения <see cref="T:System.Double" /> в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается до преобразования.

 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Так как преобразование из <xref:System.Double> для <xref:System.Numerics.BigInteger> может включать в себя усечение дробная часть `value`, языковые компиляторы не выполняют это преобразование автоматически. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (например, `CType` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.

 Для языков, которые не поддерживают пользовательские операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 В следующем примере преобразуется отдельных элементов в массиве <xref:System.Double> значения <xref:System.Numerics.BigInteger> объектов, а затем отображает результат каждого преобразования. Обратите внимание, что дробная часть <xref:System.Double> значение будет усечено во время преобразования.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> имеет значение <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> или <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Byte" />.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в байтовое значение без знака.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CByte` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.   

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Byte> тип данных. Отсутствие потери точности в итоговый <xref:System.Byte> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Byte> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Byte> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Значение <paramref name="value" /> меньше <see cref="F:System.Byte.MinValue" /> или больше <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Decimal" />.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение <see cref="T:System.Decimal" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CDec` в Visual Basic) используется.   

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Decimal> тип данных. 

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Decimal> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Decimal> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Значение <paramref name="value" /> меньше <see cref="F:System.Decimal.MinValue" /> или больше <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Double" />.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение <see cref="T:System.Double" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CDbl` в Visual Basic) используется.   

 Так как <xref:System.Numerics.BigInteger> значение может быть вне диапазона <xref:System.Double> тип данных, эта операция является сужающим преобразованием. Если преобразование завершается неудачно, он не создает исключение <xref:System.OverflowException>. Вместо этого Если <xref:System.Numerics.BigInteger> значение меньше, чем <xref:System.Double.MinValue?displayProperty=nameWithType>, полученный в результате <xref:System.Double> значение <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Если <xref:System.Numerics.BigInteger> больше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>, полученный в результате <xref:System.Double> значение <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Преобразование <xref:System.Numerics.BigInteger> для <xref:System.Double> может предполагать потерю точности. В некоторых случаях потеря точности может привести к для успешного выполнения операции приведения или преобразования даже в том случае, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Double> тип данных. Ниже приведен пример. Он назначает максимальное значение <xref:System.Double> до двух <xref:System.Numerics.BigInteger> переменные, с шагом один <xref:System.Numerics.BigInteger> переменной 9.999e291 и проверяет равенство двух переменных. Как и ожидалось, вызов <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод показывает, что они не равны. Однако преобразование большее <xref:System.Numerics.BigInteger> значение обратно <xref:System.Double> завершается успешно, несмотря на то что <xref:System.Numerics.BigInteger> теперь превышает значение <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Double> значения.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 16-разрядное знаковое целое число.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 16-битового знакового целого числа.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CShort` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.   

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int16> тип данных. Отсутствие потери точности в итоговый <xref:System.Int16> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Int16> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int16> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.Int16.MinValue" /> или больше <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 32-разрядное целое число со знаком.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 32-разрядного целого числа со знаком.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CInt` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.   

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int32> тип данных. Отсутствие потери точности в итоговый <xref:System.Int16> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Int32> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int32> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.Int32.MinValue" /> или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 64-разрядное знаковое целое число.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 64-разрядного целого числа со знаком.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CLng` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.  

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int64> тип данных. 

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Int64> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Int64> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.Int64.MinValue" /> или больше <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в значение 8-разрядного знакового числа.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 8-битового числа со знаком.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="T:System.Int16" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CSByte` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.  

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.SByte> тип данных. Отсутствие потери точности в итоговый <xref:System.SByte> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.SByte> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.SByte> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.SByte.MinValue" /> или больше <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в значение числа с плавающей запятой одиночной точности.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение числа с плавающей запятой одиночной точности.</summary>
        <returns>Объект, содержащий ближайшее возможное представление параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как оно может привести к потере данных или потере точности. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CSng` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.    

 Так как <xref:System.Numerics.BigInteger> значение может быть вне диапазона <xref:System.Single> тип данных, эта операция является сужающим преобразованием. Если преобразование завершается неудачно, он не создает исключение <xref:System.OverflowException>. Вместо этого Если <xref:System.Numerics.BigInteger> значение меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>, полученный в результате <xref:System.Single> значение <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Если <xref:System.Numerics.BigInteger> больше, чем <xref:System.Single.MaxValue?displayProperty=nameWithType>, полученный в результате <xref:System.Single> значение <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Преобразование <xref:System.Numerics.BigInteger> для <xref:System.Single> может предполагать потерю точности. В некоторых случаях потеря точности может привести к для успешного выполнения операции приведения или преобразования даже в том случае, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.Single> тип данных. Ниже приведен пример. Он назначает максимальное значение <xref:System.Single> до двух <xref:System.Numerics.BigInteger> переменные, с шагом один <xref:System.Numerics.BigInteger> переменной 9.999e291 и проверяет равенство двух переменных. Как и ожидалось, вызов <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод показывает, что они не равны. Однако преобразование большее <xref:System.Numerics.BigInteger> значение обратно <xref:System.Single> завершается успешно, несмотря на то что <xref:System.Numerics.BigInteger> теперь превышает значение <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.Single> значения.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 16-разрядное целое число без знака.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 16-битового целого числа без знака.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="T:System.Int32" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CUShort` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.    

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt16> тип данных. Отсутствие потери точности в итоговый <xref:System.UInt16> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.UInt16> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt16> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.UInt16.MinValue" /> или больше <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 32-разрядное целое число без знака.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 32-разрядного целого числа без знака.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="T:System.Int64" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CUInt` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.    

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt32> тип данных. Отсутствие потери точности в итоговый <xref:System.UInt32> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.UInt32> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt32> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.UInt32.MinValue" /> или больше <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в 64-разрядное целое число без знака.</param>
        <summary>Определяет явное преобразование объекта <see cref="T:System.Numerics.BigInteger" /> в значение 64-разрядного целого числа без знака.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="T:System.Double" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (такие как `CType` или `CULng` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.    

 Так как эта операция определяет сужающее преобразование, может возникнуть исключение <xref:System.OverflowException> во время выполнения, если <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt64> тип данных. Отсутствие потери точности в итоговый <xref:System.UInt64> значение, если преобразование прошло успешно.

## Examples
 В следующем примере показано преобразование <xref:System.Numerics.BigInteger> для <xref:System.UInt64> значения. Он также обрабатывает <xref:System.OverflowException> , возникает исключение, так как <xref:System.Numerics.BigInteger> значение выходит за пределы диапазона <xref:System.UInt64> тип данных.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> меньше <see cref="F:System.UInt64.MinValue" /> или больше <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет явное преобразование значения <see cref="T:System.Single" /> в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается до преобразования.
 
 Перегрузки <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> метод определения типов, в который или из которого <xref:System.Numerics.BigInteger> объект может быть преобразован. Так как преобразование из <xref:System.Single> для <xref:System.Numerics.BigInteger> может включать в себя усечение дробная часть `value`, языковые компиляторы не выполняют это преобразование автоматически. Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (например, `CType` в Visual Basic) используется. В противном случае они отображают ошибку компилятора.

 Для языков, которые не поддерживают пользовательские операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 В следующем примере преобразуется отдельных элементов в массиве <xref:System.Single> значения <xref:System.Numerics.BigInteger> объектов, а затем отображает результат каждого преобразования. Обратите внимание, что дробная часть <xref:System.Single> значение будет усечено во время преобразования.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> имеет значение <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, действительно ли заданное значение больше другого заданного значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно 64-разрядное знаковое целое число больше или равно значению <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Метод определяет операцию больше оператора для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод экземпляра. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> больше значения 64-битового знакового целого числа.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Метод определяет операцию больше оператора для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение типа <see cref="T:System.Numerics.BigInteger" /> больше другого значения типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Метод определяет операцию больше оператора для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее действительно ли значение <see cref="T:System.Numerics.BigInteger" /> больше 64-битового целого числа без знака.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Метод определяет операцию больше оператора для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее действительно ли значение <see cref="T:System.Numerics.BigInteger" /> больше 64-битового целого числа без знака.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Метод определяет операцию больше оператора для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, действительно ли заданное значение больше или равно другому заданному значению.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное знаковое целое число больше или равно значению <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Метод определяет операцию больше или равно-оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> больше или равно значению 64-битового знакового целого числа.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Метод определяет операцию больше или равно-оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение типа <see cref="T:System.Numerics.BigInteger" /> больше или равно другому значению типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Метод определяет операцию больше или равно-оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> больше или равно значению 64-битового целого числа без знака.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Метод определяет операцию больше или равно-оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное целое число без знака больше или равно значению <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Метод определяет операцию больше или равно-оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет неявное преобразование объекта типа <see cref="T:System.Numerics.BigInteger" /> в другой тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование значения типа byte без знака в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дробная часть `value` параметр усекается до преобразования.

 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Byte> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 16-битового знакового целого числа в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Int16> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 32-разрядного целого числа со знаком в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Int32> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 64-разрядного целого числа со знаком в значение <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Int64> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 8-битового знакового целого числа в значение <see cref="T:System.Numerics.BigInteger" />.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.SByte> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 16-битового целого числа без знака в значение <see cref="T:System.Numerics.BigInteger" />.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.UInt16> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 32-разрядного целого числа без знака в значение <see cref="T:System.Numerics.BigInteger" />.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.UInt32> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение, которое необходимо преобразовать в тип <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Определяет неявное преобразование 64-разрядного целого числа без знака в значение <see cref="T:System.Numerics.BigInteger" />.  
  
Этот интерфейс API CLS-несовместим. Совместимая альтернатива — <see cref="T:System.Double" />.</summary>
        <returns>Объект, содержащий значение параметра <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для языков, которые не поддерживают неявные операторы, является альтернативным методом <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Перегрузки <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> метод определения типов, в который или из которого компилятор поддерживает автоматическое преобразование <xref:System.Numerics.BigInteger> значение без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic). Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>. Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.UInt64> значение <xref:System.Numerics.BigInteger> значения, как показано в следующем примере.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Увеличиваемое значение.</param>
        <summary>Увеличивает значение <see cref="T:System.Numerics.BigInteger" /> на 1.</summary>
        <returns>Значение параметра <paramref name="value" />, увеличенное на 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A> Метод определяет операцию увеличения для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Некоторые языки (например, Visual Basic), не хватает оператора инкремента или не поддерживающих перегрузку операторов можно вызвать <xref:System.Numerics.BigInteger.op_Increment%2A> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Так как <xref:System.Numerics.BigInteger> объекты являются неизменяемыми, <xref:System.Numerics.BigInteger.op_Increment%2A> оператор создает новую <xref:System.Numerics.BigInteger> объект, значение которого является одним больше, чем <xref:System.Numerics.BigInteger> объекта, представленного `value`. Таким образом, повторные вызовы <xref:System.Numerics.BigInteger.op_Increment%2A> может быть затратным.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, действительно ли два числовых значения не равны.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное знаковое целое число и значение <see cref="T:System.Numerics.BigInteger" /> не равны.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства с помощью одного из следующих способов:  
  
-   Вызов <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> экземпляр метода, который указывает связь между <xref:System.Numerics.BigInteger> и длинное целое число со знаком.  
  
-   Вызов <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> экземпляр метода и изменение его значения.  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> и 64-разрядное знаковое целое число не равны.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства с помощью одного из следующих способов:  
  
-   Вызов <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод, который указывает на отношения между <xref:System.Numerics.BigInteger> и длинное целое число со знаком.  
  
-   Вызов <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> метод и изменение его значения.  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, различаются ли значения двух объектов <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства с помощью одного из следующих способов:  
  
-   Вызов <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> метод, который показывает связь между двумя <xref:System.Numerics.BigInteger> объектов.  
  
-   Вызов <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> метод и изменение его значения.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> и 64-разрядное целое число без знака не равны.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства с помощью одного из следующих способов:  
  
-   Вызов <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод, который указывает на отношения между <xref:System.Numerics.BigInteger> и значение длинное целое без знака.  
  
-   Вызов <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> метод и изменение его значения.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное целое число без знака и значение <see cref="T:System.Numerics.BigInteger" /> не равны.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства с помощью одного из следующих способов:  
  
-   Вызов <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод, который указывает на отношения между <xref:System.Numerics.BigInteger> и значение длинное целое без знака.  
  
-   Вызов <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> метод и изменение его значения.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение, для которого необходимо выполнить побитовый сдвиг.</param>
        <param name="shift">Количество битов, на которое необходимо сдвинуть влево значение <paramref name="value" />.</param>
        <summary>Сдвигает значение <see cref="T:System.Numerics.BigInteger" /> на указанное число битов влево.</summary>
        <returns>Значение, которое было сдвинуто влево на указанное число бит.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A> Метод определяет операцию побитового оператора сдвига влево для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  В отличие от Побитовая операция сдвига влево с примитивами целое число <xref:System.Numerics.BigInteger.op_LeftShift%2A> метод сохраняет входа исходного <xref:System.Numerics.BigInteger> значение.  
  
 Языки, не поддерживают пользовательские операторы могут выполнять операцию побитового сдвига влево путем умножения `value` по `BigInteger.Pow(2, shift)`. Следующий пример показывает, что результаты идентичны результатам с помощью этого оператора.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, действительно ли заданное значение меньше второго заданного значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно 64-разрядное знаковое целое число меньше значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Метод определяет операцию "меньше" оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> меньше 64-битового знакового целого числа.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Метод определяет операцию "меньше" оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение типа <see cref="T:System.Numerics.BigInteger" /> меньше другого значения типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Метод определяет операцию "меньше" оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> метод вместо этого. В некоторых языках можно также вызвать <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> меньше 64-битового целого числа без знака.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Метод определяет операцию "меньше" оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное целое число без знака меньше значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Метод определяет операцию "меньше" оператор для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, определяющее, действительно ли заданное значение меньше или равно другому заданному значению.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное знаковое целое число меньше или равно значению <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Метод определяет операцию меньше или равно оператору для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Если `left` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> меньше или равно 64-разрядному знаковому целому числу.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Метод определяет операцию меньше или равно оператору для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Если `right` — <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, или <xref:System.UInt32> , он неявно преобразуется в значение <xref:System.Int64> значение при выполнении операции.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение типа <see cref="T:System.Numerics.BigInteger" /> меньше или равно другому значению типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Метод определяет операцию меньше или равно оператору для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Compare%2A> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли значение <see cref="T:System.Numerics.BigInteger" /> меньше или равно 64-разрядному целому числу без знака.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Метод определяет операцию меньше или равно оператору для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, определяющее, действительно ли 64-разрядное целое число без знака меньше или равно значению <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Метод определяет операцию меньше или равно оператору для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> метод вместо этого. Они также могут вызывать <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> метод напрямую, как показано следующем примере.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Значение, которое необходимо разделить.</param>
        <param name="divisor">Значение, на которое необходимо разделить.</param>
        <summary>Возвращает остаток от деления двух заданных значений <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Остаток от деления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A> Метод определяет операцию оператор modulus для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> метод вместо этого.  
  
 Знак значения, возвращенного в операции получения модуля зависит от знака `dividend`: Если `dividend` задано положительное число, в операции получения модуля возвращает положительный результат; если оно отрицательное, в операции получения модуля отрицательного результата. Поведение операции получения модуля с <xref:System.Numerics.BigInteger> значения идентична операции модуля с другими целочисленными типами.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">Значение параметра <paramref name="divisor" /> равно нулю (0).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Первое значение для перемножения.</param>
        <param name="right">Второе значение для перемножения.</param>
        <summary>Умножает два заданных значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Произведение <paramref name="left" /> на <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Multiply%2A> Метод определяет операцию оператора умножения для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Целочисленное значение.</param>
        <summary>Возвращает результат битовой операции дополнения до единицы для значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Битовое дополнение значения <paramref name="value" /> до единицы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Метод определяет операцию побитового оператор дополнения для <xref:System.Numerics.BigInteger> значения. Побитовое обращает оператор дополнения каждый бит в числовое значение. То есть биты `value` , которые 0 присваивается значение 1, в результате, а биты, равные 1 задается значение 0, в результате. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Метод включает следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Языки, которые не поддерживают пользовательские операторы могут иметь возможность вызывать <xref:System.Numerics.BigInteger.op_OnesComplement%2A> метод напрямую для выполнения битовую операцию дополнения до единицы. Например:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение, для которого необходимо выполнить побитовый сдвиг.</param>
        <param name="shift">Количество битов, на которое необходимо сдвинуть <paramref name="value" /> вправо.</param>
        <summary>Сдвигает значение <see cref="T:System.Numerics.BigInteger" /> на указанное число битов вправо.</summary>
        <returns>Значение, которое было сдвинуто вправо на указанное число бит.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_RightShift%2A> Метод определяет операцию побитового оператора сдвига вправо для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Языки, не поддерживают пользовательские операторы могут выполнять операцию побитового сдвига вправо путем деления `value` по `BigInteger.Pow(2, shift)` и вычитается 1 раз `shift` для отрицательных значений. Следующий пример показывает, что результаты идентичны результатам с помощью этого оператора.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Если `shift` больше или равно числу битов в положительное <xref:System.Numerics.BigInteger> значение, результат операции сдвига вправо — <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Если `shift` больше, чем число битов в отрицательное <xref:System.Numerics.BigInteger> значение, результат операции сдвига вправо — <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Значение, из которого следует вычитать (уменьшаемое).</param>
        <param name="right">Значение для вычитания (вычитаемое).</param>
        <summary>Вычитает значение <see cref="T:System.Numerics.BigInteger" /> из другого значения <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Результат вычитания <paramref name="right" /> из <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A> Метод определяет операцию от оператора вычитания для <xref:System.Numerics.BigInteger> значения. В результате следующий код:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> метод вместо этого.  
  
 Эквивалентный метод для этого оператора является <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Инвертируемое значение.</param>
        <summary>Меняет знак указанного значения BigInteger.</summary>
        <returns>Результат умножения параметра <paramref name="value" /> на минус единицу (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Метод определяет операцию оператор унарного отрицания (или оператор аддитивную инверсию) для <xref:System.Numerics.BigInteger> значения. Операция создаст значение, которое приводит 0 (ноль), если он добавляется в исходный номер. Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.BigInteger.Negate%2A> метод вместо этого.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере показано три разных способа Инвертируемое значение <xref:System.Numerics.BigInteger> объекта.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Целочисленное значение.</param>
        <summary>Возвращает значение операнда <see cref="T:System.Numerics.BigInteger" />. (Знак операнда не изменяется.)</summary>
        <returns>Значение операнда <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Метод определяет операцию положительное унарный оператор для <xref:System.Numerics.BigInteger> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в его эквивалент типа <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая преобразуемое число.</param>
        <summary>Преобразует строковое представление числа в его эквивалент типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение, эквивалентное числу, которое задается параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр должен иметь строковое представление числа в следующей форме.  
  
 [*ws*] [*входа*]*цифр*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел.|  
|*sign*|Необязательный знак. Допустимые знаки определяются по <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойства текущего языка и региональных параметров.|  
|*digits*|Последовательность цифр в диапазоне от 0 до 9. Все начальные нули пропускаются.|  
  
> [!NOTE]
>  Строка, заданная `value` параметр интерпретируется с использованием <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> стиля. Он не может содержать разделители групп или десятичного разделителя, и он не может иметь дробную часть.  
  
 `value` Анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> , инициализируемый для текущего языка и региональных параметров системы. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Чтобы проанализировать строку с помощью сведений о форматировании для определенного языка и региональных параметров, используйте <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> метод.  
  
> [!IMPORTANT]
>  При использовании <xref:System.Numerics.BigInteger.Parse%2A> метод для обратного преобразования строкового представления объекта <xref:System.Numerics.BigInteger> значение, которое было выходные <xref:System.Numerics.BigInteger.ToString%2A> метод, следует использовать <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> метод с помощью описателя формата «R» для создания строкового представления <xref:System.Numerics.BigInteger> значение. В противном случае — строковое представление <xref:System.Numerics.BigInteger> сохраняет только 50 наиболее значимых цифр, исходное значение, и данные могут быть потеряны, если вы используете <xref:System.Numerics.BigInteger.Parse%2A> метод восстановления <xref:System.Numerics.BigInteger> значение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.Parse%28System.String%29> метод для создания экземпляра два <xref:System.Numerics.BigInteger> объектов. Умножает каждый объект на другое, а затем вызывает <xref:System.Numerics.BigInteger.Compare%2A> метод, чтобы определить связь между двумя значениями.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> имеет неправильный формат.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, которое показывает разрешенный формат параметра <paramref name="value" />.</param>
        <summary>Преобразует строковое представление числа с указанным стилем в его эквивалент в формате <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение, эквивалентное числу, которое задается параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (например, пробел, символ знак плюс или минус, символ-разделитель групп или символ десятичной запятой), которые разрешены в `value` параметр для успешного выполнения операции синтаксического анализа. `styles` должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. `style` Параметр делает этот метод перегрузки в полезно, когда `value` содержит строковое представление шестнадцатеричного значения, в том случае, если представленный в системе счисления (десятичное или шестнадцатеричное) `value` становится известным только во время выполнения, или если вы хотите запретить пробел или символ знака в `value`.  
  
 В зависимости от значения `style`, `value` параметр может содержать следующие элементы:  
  
 [*ws*] [*$*] [*входа*] [*цифр*,]*цифр*[. *цифры_дробной_части*] [E [*входа*]*экспоненциальные_цифры*] [*ws*]  
  
 Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` параметр может содержать следующие элементы:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут отображаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг и может отображаться в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойства текущего языка и региональных параметров. Символ валюты для текущего языка и региональных параметров может встречаться в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг и может отображаться в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать скобки в `value` указывает отрицательное значение, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Последовательность цифр от 0 до 9. Для *цифры_дробной_части*только из цифр 0 является допустимым.|  
|*,*|Символ разделителя групп, зависящий от языка и региональных параметров. Разделитель групп текущего языка и региональных параметров может встречаться в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной запятой текущего языка и региональных параметров может содержаться в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг. Только цифры 0 может отображаться в виде дробного числа синтаксического анализа для успешного выполнения операции; Если *цифры_дробной_части* включает любые другие цифры, <xref:System.FormatException> возникает исключение.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `value` Параметр может представлять число в экспоненциальном представлении, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*hexdigits*|Последовательность шестнадцатеричных цифр от 0 до f или от 0 до F.|  
  
> [!NOTE]
> Символы (от U + 0000) завершающий NUL в `s` пропускаются операцией анализа, независимо от значения `style` аргумент.

 Строка с только цифры (который соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиля) всегда успешно выполняет синтаксический анализ. Большинство оставшихся <xref:System.Globalization.NumberStyles> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. В следующей таблице показаны как отдельные <xref:System.Globalization.NumberStyles> члены влияют на элементы, которые могут присутствовать в `value`.  
  
|Значение`NumberStyles` |Элементы, допустимые в `value` помимо цифр|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Цифр* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичная точка (.) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» знаком, который указывает экспоненциальное представление, вместе с *экспоненциальные_цифры*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, заключив числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент группы разрядов ().|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `value`, *входа* в начале `value`и десятичной запятой (*.*) символов. `value` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Разделитель групп (*,*) и десятичной запятой (*.*) элементов.|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число.|  
  
> [!IMPORTANT]
>  При использовании <xref:System.Numerics.BigInteger.Parse%2A> метод для обратного преобразования строкового представления объекта <xref:System.Numerics.BigInteger> значение, которое было выходные <xref:System.Numerics.BigInteger.ToString%2A> метод, следует использовать <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> метод с помощью описателя формата «R» для создания строкового представления <xref:System.Numerics.BigInteger> значение. В противном случае — строковое представление <xref:System.Numerics.BigInteger> сохраняет только 50 наиболее значимых цифр, исходное значение, и данные могут быть потеряны, если вы используете <xref:System.Numerics.BigInteger.Parse%2A> метод восстановления <xref:System.Numerics.BigInteger> значение.  
  
 В отличие от других <xref:System.Globalization.NumberStyles> значения, которые позволяют, но не требуют наличия определенного стиля элементов в `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> значение стиля означает, что отдельные цифры в `value` всегда интерпретируется как шестнадцатеричные символы. Допустимые шестнадцатеричные цифры символы являются 0-9, A-F и a-f. Только другие флаги, которые могут быть объединены с `style` являются <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Перечисления включает стили составного числа, <xref:System.Globalization.NumberStyles.HexNumber>, включающий в себя оба флага пустого пространства.)  
  
> [!NOTE]
>  Если `value` является строковым представлением шестнадцатеричного числа, он не может начинаться с описателей (таких как `0x` или `&h`), отличающее его как шестнадцатеричное число. Это приводит к сбою преобразования.  
  
 Если `value` является шестнадцатеричной строки, <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метод интерпретирует `value` как отрицательное число, хранятся с помощью двух дополнением представление, в случае его первых двух шестнадцатеричных цифр больше или равно `0x80`. Другими словами, этот метод интерпретирует самого старшего бита первого байта в `value` называется знаковым битом. Чтобы убедиться в том, что шестнадцатеричной строки интерпретируется правильно как положительное число, первая цифра в `value` должен иметь нулевое значение. Например, этот метод интерпретирует `0x80` как отрицательное значение, но он интерпретирует либо `0x080` или `0x0080` как положительное значение. В следующем примере показано различие между шестнадцатеричных строк, представляющих положительные и отрицательные значения.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value` Анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Чтобы указать язык и региональные параметры, чье форматирования используется для синтаксического анализа, вызовите <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> перегрузки.  
  
   
  
## Examples  
 В следующем примере показано вызовы <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метод с несколько возможных значений для `style` параметра. Он показывает, как интерпретировать строку как шестнадцатеричное значение и запретить пробелы и подписать символы.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
-или- 
 <paramref name="style" /> включает флаги <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> и <see cref="F:System.Globalization.NumberStyles.HexNumber" /> вместе с другим значениями.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> не соответствует образцу ввода, заданному <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая преобразуемое число.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании параметра <paramref name="value" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа в указанном формате, связанном с определенным языком и региональными параметрами, в его эквивалент типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение, эквивалентное числу, которое задается параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр должен иметь строковое представление числа в следующей форме:  
  
 [*ws*] [*входа*]*цифр*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел.|  
|*sign*|Необязательный знак. Допустимые знаки определяются по <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойства <xref:System.Globalization.NumberFormatInfo> объект, возвращаемый `provider` объекта <xref:System.IFormatProvider.GetFormat%2A> метод.|  
|*digits*|Последовательность цифр в диапазоне от 0 до 9. Все начальные нули пропускаются.|  
  
> [!NOTE]
>  Строка, заданная `value` параметр интерпретируется с использованием <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> стиля. Он не может содержать разделители групп или десятичного разделителя, и он не может иметь дробную часть.  
  
> [!IMPORTANT]
>  При использовании <xref:System.Numerics.BigInteger.Parse%2A> метод для обратного преобразования строкового представления объекта <xref:System.Numerics.BigInteger> значение, которое было выходные <xref:System.Numerics.BigInteger.ToString%2A> метод, следует использовать <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> метод с помощью описателя формата «R» для создания строкового представления <xref:System.Numerics.BigInteger> значение. В противном случае — строковое представление <xref:System.Numerics.BigInteger> сохраняет только 50 наиболее значимых цифр, исходное значение, и данные могут быть потеряны, если вы используете <xref:System.Numerics.BigInteger.Parse%2A> метод восстановления <xref:System.Numerics.BigInteger> значение.  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации которого <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров. Когда <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> вызывается метод, он вызывает метод `provider` параметра <xref:System.IFormatProvider.GetFormat%2A> метод и передает его <xref:System.Type> , представляющий <xref:System.Globalization.NumberFormatInfo> типа. <xref:System.IFormatProvider.GetFormat%2A> Метод затем возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формате параметра `value` параметр. Существует три способа использования `provider` указать пользовательские сведения о форматировании для операции синтаксического анализа:  
  
-   Вы можете передать <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых для этого языка и региональных параметров.  
  
-   Вы можете передать фактический <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых. (Его реализации <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, форматирование `value` обрабатывается на основе <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров.  
  
   
  
## Examples  
 В следующих примерах показано два способа определения тильды (~) в качестве символа отрицательного для форматирования <xref:System.Numerics.BigInteger> значения. Обратите внимание, что для отображения <xref:System.Numerics.BigInteger> значения в тот же формат, что исходных строк, ваш код должен вызывать <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод и передать его <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 В первом примере определяется класс, реализующий <xref:System.IFormatProvider> и использует <xref:System.IFormatProvider.GetFormat%2A> метод для возврата <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Объект <xref:System.Numerics.BigInteger> объект может быть использован со следующим кодом:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Второй пример является более простым. Он передает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании для `provider` параметра.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> имеет неправильный формат.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, которое показывает разрешенный формат параметра <paramref name="value" />.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании параметра <paramref name="value" /> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и формате, связанном с определенным языком и региональными параметрами, в его эквивалент типа <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Значение, эквивалентное числу, которое задается параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (например, пробел, символ знак плюс или минус, символ-разделитель групп или символ десятичной запятой), которые разрешены в `value` параметр для успешного выполнения операции синтаксического анализа. `styles` должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. `style` Параметр делает этот метод перегрузки в полезно, когда `value` содержит строковое представление шестнадцатеричного значения, в том случае, если представленный в системе счисления (десятичное или шестнадцатеричное) `value` становится известным только во время выполнения, или если вы хотите запретить пробел или символ знака в `value`.  
  
 В зависимости от значения `style`, `value` параметр может содержать следующие элементы:  
  
 [*ws*] [*$*] [*входа*] [*цифр*,]*цифр*[*. цифры_дробной_части*] [E [*входа*]*экспоненциальные_цифры*] [*ws*]  
  
 Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` параметр может содержать следующие элементы:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут отображаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг и может отображаться в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> обозначается свойства языка и региональных параметров `provider` параметра. Символ валюты для текущего языка и региональных параметров может встречаться в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг и может отображаться в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать скобки в `value` указывает отрицательное значение, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Последовательность цифр от 0 до 9. Для *цифры_дробной_части*только из цифр 0 является допустимым.|  
|*,*|Символ разделителя групп, зависящий от языка и региональных параметров. Символ-разделитель групп языка и региональных параметров, заданные `provider` могут присутствовать в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной запятой, языка и региональных параметров, назначенному с помощью `provider` могут присутствовать в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг. Только цифры 0 может отображаться в виде дробного числа синтаксического анализа для успешного выполнения операции; Если *цифры_дробной_части* включает любые другие цифры, <xref:System.FormatException> возникает исключение.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `value` Параметр может представлять число в экспоненциальном представлении, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*hexdigits*|Последовательность шестнадцатеричных цифр от 0 до f или от 0 до F.|  
  
> [!NOTE]
> Символы (от U + 0000) завершающий NUL в `s` пропускаются операцией анализа, независимо от значения `style` аргумент.

 Строка с только цифры (который соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиля) всегда успешно выполняет синтаксический анализ. Большинство оставшихся <xref:System.Globalization.NumberStyles> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. В следующей таблице показаны как отдельные <xref:System.Globalization.NumberStyles> члены влияют на элементы, которые могут присутствовать в `value`.  
  
|Значение NumberStyles|Элементы, допустимые в значении помимо цифр|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Цифр* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичная точка (.) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или символ «E», который указывает на экспоненциальное представление. вместе с *экспоненциальные_цифры*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, заключив числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Элемент группы разрядов ().|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `value`, *входа* в начале `value`и символ десятичной точки (.). `value` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Разделитель групп (,) и элементы десятичной точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число.|  
  
> [!IMPORTANT]
>  При использовании <xref:System.Numerics.BigInteger.Parse%2A> метод для обратного преобразования строкового представления объекта <xref:System.Numerics.BigInteger> значение, которое было выходные <xref:System.Numerics.BigInteger.ToString%2A> метод, следует использовать <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> метод с помощью описателя формата «R» для создания строкового представления <xref:System.Numerics.BigInteger> значение. В противном случае — строковое представление <xref:System.Numerics.BigInteger> сохраняет только 50 наиболее значимых цифр, исходное значение, и данные могут быть потеряны, если вы используете <xref:System.Numerics.BigInteger.Parse%2A> метод восстановления <xref:System.Numerics.BigInteger> значение.  
  
 В отличие от других <xref:System.Globalization.NumberStyles> значения, которые позволяют, а не требуют наличия определенного стиля элементов в `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> значение стиля означает, что отдельные цифры в `value` всегда интерпретируется как шестнадцатеричные символы. Допустимые шестнадцатеричные цифры символы являются 0-9, A-F и a-f. Только другие флаги, которые могут быть объединены с `style` являются <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Перечисления включает стили составного числа, <xref:System.Globalization.NumberStyles.HexNumber>, включающий в себя оба флага пустого пространства.)  
  
> [!NOTE]
>  Если `value` является строковым представлением шестнадцатеричного числа, он не может начинаться с описателей (таких как `0x` или `&h`), отличающее его как шестнадцатеричное число. Это приводит к сбою преобразования.  
  
 Если `value` является шестнадцатеричной строки, <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метод интерпретирует `value` как отрицательное число, хранятся с помощью двух дополнением представление, в случае его первых двух шестнадцатеричных цифр больше или равно `0x80`. Другими словами, этот метод интерпретирует самого старшего бита первого байта в `value` называется знаковым битом. Чтобы убедиться в том, что шестнадцатеричной строки интерпретируется правильно как положительное число, первая цифра в `value` должен иметь нулевое значение. Например, этот метод интерпретирует `0x80` как отрицательное значение, но он интерпретирует либо `0x080` или `0x0080` как положительное значение. В следующем примере показано различие между шестнадцатеричных строк, представляющих положительные и отрицательные значения.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, который предоставляет зависящие от культуры сведения о формате параметра `value`. Как правило `provider` может принимать одно из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании числовых. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании. (Его реализации <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Пользовательский объект, реализующий <xref:System.IFormatProvider> и использует <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> метод для создания экземпляра и вернуть <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример выполняет несколько обращений к <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метода с использованием различных сочетаний значений для `style` и `provider` параметров.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Ряд отдельные вызовы, чтобы <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метод передать экземпляр из следующих `BigIntegerFormatProvider` класс, который определяет как отрицательный знак тильды (~).  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
-или- 
 <paramref name="style" /> включает флаги <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> и <see cref="F:System.Globalization.NumberStyles.HexNumber" /> вместе с другим значениями.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> не соответствует образцу ввода, заданному <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Число, возведенное в степень <paramref name="exponent" />.</param>
        <param name="exponent">Показатель степени, в которую будет возведено значение <paramref name="value" />.</param>
        <summary>Возводит значение <see cref="T:System.Numerics.BigInteger" /> в заданную степень.</summary>
        <returns>Результат возведения <paramref name="value" /> в степень <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Pow%2A> Метод возвращает значение 1, если значение экспоненты параметра является 0, или в том случае, если значения `value` и `exponent` параметров равны 0. Если `exponent` -1, <xref:System.Numerics.BigInteger.Pow%2A> возвращает метод `value`. Если `value` является отрицательным, метод возвращает отрицательный результат.  
  
 Этот метод соответствует <xref:System.Math.Pow%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
   
  
## Examples  
 В следующем примере показано возведение в степень, с помощью <xref:System.Numerics.BigInteger> значение и показателя степени, в которых значение в диапазоне от 0 до 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> является отрицательным значением.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Значение, которое необходимо разделить.</param>
        <param name="divisor">Значение, на которое необходимо разделить.</param>
        <summary>Выполняет целочисленное деление двух значений <see cref="T:System.Numerics.BigInteger" /> и возвращает остаток.</summary>
        <returns>Остаток от деления <paramref name="dividend" /> на <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак остатка является знак `dividend` параметра.  
  
 <xref:System.Numerics.BigInteger.Remainder%2A> Метод реализуется для языков, которые не поддерживают пользовательские операторы. Его поведение идентично поведению деления, используя оператор модуля.  
  
 При необходимости метод автоматически выполняет неявное преобразование для других целочисленных типов <xref:System.Numerics.BigInteger> объекты перед выполнением операции получения модуля.  
  
   
  
## Examples  
 В следующем примере сравниваются остаток от <xref:System.Numerics.BigInteger.DivRem%2A> метод дальнейшим, возвращенный <xref:System.Numerics.BigInteger.Remainder%2A> метод, чтобы установить, что два метода расчета идентичные остатков.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">Значение параметра <paramref name="divisor" /> равно нулю (0).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число, указывающее знак (минус, плюс или нуль) текущего объекта <see cref="T:System.Numerics.BigInteger" />.</summary>
        <value>Число, которое указывает знак объекта <see cref="T:System.Numerics.BigInteger" />, как показано в следующей таблице.  
  
 <list type="table"><listheader><term> Число 
 </term><description> Описание 
 </description></listheader><item><term> -1 
 </term><description> Этот объект имеет отрицательное значение.  
  
 </description></item><item><term> 0 
 </term><description> Этот объект имеет значение 0 (нуль).  
  
 </description></item><item><term> 1 
 </term><description> Этот объект имеет положительное значение.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A> Свойство является аналогом <xref:System.Math.Sign%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Значение, из которого следует вычитать (уменьшаемое).</param>
        <param name="right">Значение для вычитания (вычитаемое).</param>
        <summary>Вычитает одно значение <see cref="T:System.Numerics.BigInteger" /> из другого и возвращает результат.</summary>
        <returns>Результат вычитания <paramref name="right" /> из <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать языки, которые не поддерживают пользовательские операторы <xref:System.Numerics.BigInteger.Subtract%2A> метод для выполнения вычитания с помощью <xref:System.Numerics.BigInteger> значения.  
  
 <xref:System.Numerics.BigInteger.Subtract%2A> Метод является полезным заменой оператор вычитания, при создании экземпляра <xref:System.Numerics.BigInteger> переменной, назначив ей разницу, полученный в результате вычитания, как показано в следующем примере.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует значение <see cref="T:System.Numerics.BigInteger" /> в массив байтов.</summary>
        <returns>Значение текущего объекта <see cref="T:System.Numerics.BigInteger" />, преобразованное в массив байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отдельные байты в массив, возвращаемый этим методом отображаются в прямом порядке. То есть младшие байты значения предшествуют байты высокого порядка. Первый байт в массиве отражает первые восемь бита <xref:System.Numerics.BigInteger> значение, второй байт отражает следующие восемь бит и т. д. Например значение 1024 или 0x0400, хранится в виде следующий массив из двух байтов:  
  
|Элемент|Байтовое значение|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Отрицательные значения записываются в массиве, с использованием двух дополнением представления в компактной форме. Например, -1 представляется как один байт, значение которого равно `0xFF` вместо как массив, содержащий несколько элементов, таких как `0xFF`, `0xFF` или `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Так как дополнение до двух представление всегда интерпретирует старший бит последнего байта в массиве (байт в позиции <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) как бит знака, метод возвращает массив байтов, в дополнительный элемент, значение которого равно нулю для устранить неоднозначность положительные значения, которые в противном случае может быть интерпретирован как с установленным битом знака. Например, значение 120 или `0x78` представляется как массив однобайтовых: `0x78`. Тем не менее, 128, или `0x80`, представляется как массив размером 2 байта: `0x80`, `0x00`.  
  
 Вы можете приема-передачи <xref:System.Numerics.BigInteger> значение, сохранив его в массив байтов и восстановления с помощью <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> конструктор.  
  
> [!CAUTION]
>  Если код изменяет значение отдельных байтов в массиве, возвращенное этим методом, прежде чем он восстанавливает значение, необходимо убедиться в том, что вы не изменен знаковым битом. Например если ваши изменения увеличивают положительное значение, чтобы старший бит в последнем элементе массива байтов становится установленным, можно добавить новый байт, значение которого равно нулю, в конец массива.  
  
   
  
## Examples  
 В следующем примере показано, как некоторые <xref:System.Numerics.BigInteger> значения представлены в массивы байтов.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует числовое значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> в эквивалентное ему строковое представление.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует числовое значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> в эквивалентное ему строковое представление.</summary>
        <returns>Строковое представление значения текущего объекта <see cref="T:System.Numerics.BigInteger" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString> Форматы метода <xref:System.Numerics.BigInteger> значение «R» или приема-передачи, формата текущего языка и региональных параметров. Если вы хотите указать другой формат или язык и региональные параметры, используйте другие перегрузки <xref:System.Numerics.BigInteger.ToString%2A> метода, как показано ниже:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат Round-Trip ("R")|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Определенный формат|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Строковое представление <xref:System.Numerics.BigInteger> значение включает знак минус, если его значение является отрицательным числом и последовательность цифр в диапазоне от 0 до 9 без предшествующих нулей. Знак минус определяется <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере отображается <xref:System.Numerics.BigInteger> значение по умолчанию <xref:System.Numerics.BigInteger.ToString> метод. Она также отображает строковые представления <xref:System.Numerics.BigInteger> значение, в результате использования некоторых описателей стандартного формата. Примеры отображаются с использованием соглашений о форматировании языка и региональных параметров en US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> в эквивалентное ему строковое представление, используя указанные сведения об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения текущего объекта <see cref="T:System.Numerics.BigInteger" /> в формате, заданном параметром <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Форматы метода <xref:System.Numerics.BigInteger> значение «R» или приема-передачи, отформатировать с помощью <xref:System.Globalization.NumberFormatInfo> объект указанного языка и региональных параметров. Если вы хотите указать другой формат или текущего языка и региональных параметров, используйте другие перегрузки <xref:System.Numerics.BigInteger.ToString%2A> метода, как показано ниже:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат Round-Trip ("R")|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString>|  
|Определенный формат|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формате строки, возвращаемой этим методом для конкретного языка и региональных параметров. Если `provider` — `null`, <xref:System.Numerics.BigInteger> значение форматируется с использованием <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров. Свойство только <xref:System.Globalization.NumberFormatInfo> объект, управляющий строковым представлением <xref:System.Numerics.BigInteger> значение с помощью спецификатора общего формата <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, который определяет символ, который представляет отрицательный знак.  
  
 `provider` Параметр может принимать одно из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании.  
  
-   <xref:System.Globalization.NumberFormatInfo> Объект, предоставляющий сведения о форматировании.  
  
-   Пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
   
  
## Examples  
 В следующем примере создается пользовательский <xref:System.Globalization.NumberFormatInfo> объект, который определяет как отрицательный знак тильды (~). <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Метод использует пользовательский <xref:System.Globalization.NumberFormatInfo> объект для отображения отрицательное <xref:System.Numerics.BigInteger> значение.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Стандартная или пользовательская строка числового формата.</param>
        <summary>Преобразует числовое значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> в эквивалентное строковое представление с использованием указанного формата.</summary>
        <returns>Строковое представление значения текущего объекта <see cref="T:System.Numerics.BigInteger" /> в формате, заданном параметром <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%29> Форматы метода <xref:System.Numerics.BigInteger> значение в указанном формате, с помощью <xref:System.Globalization.NumberFormatInfo> , представляющий соглашения текущих региональных параметров. Если вы хотите использовать «R», то есть цикл обработки, форматирования или укажите другой язык и региональные параметры, использовать другие перегрузки <xref:System.Numerics.BigInteger.ToString%2A> метода, как показано ниже:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат Round-Trip ("R")|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString>|  
|Формат Round-Trip ("R")|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format` Параметр может быть любым допустимым [строка стандартного числового](~/docs/standard/base-types/standard-numeric-format-strings.md), или любое сочетание [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Если `format` равен <xref:System.String.Empty?displayProperty=nameWithType> или `null`, возвращаемое значение текущего <xref:System.Numerics.BigInteger> объект форматируется с помощью описателя формата приема-передачи («R»). Если `format` задано любое другое значение, вызывает метод <xref:System.FormatException>.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о поддержке для форматирования в .NET Framework, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Формат возвращаемой строки определяется <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров. В зависимости от `format` параметр, этот объект определяет символы, такие как знак минус, разделитель групп и символ десятичной запятой в выходной строке. Чтобы предоставить сведения о форматировании для языков и региональных параметров, отличных от текущего языка и региональных параметров, вызовите <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> перегрузки.  
  
   
  
## Examples  
 В следующем примере инициализируется <xref:System.Numerics.BigInteger> значение и отображает его с помощью каждой строки стандартного формата и некоторых строк настраиваемого формата.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> не является допустимым форматом строки.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Стандартная или пользовательская строка числового формата.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует значение текущего объекта <see cref="T:System.Numerics.BigInteger" /> в эквивалентное ему строковое представление с использованием указанного формата и сведений об особенностях формата для определенного языка и региональных параметров.</summary>
        <returns>Строковое представление текущего значения <see cref="T:System.Numerics.BigInteger" /> в виде, заданном параметрами <paramref name="format" /> и <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Форматы метода <xref:System.Numerics.BigInteger> значение в указанном формате, с помощью <xref:System.Globalization.NumberFormatInfo> объект указанного языка и региональных параметров. Если вы хотите использовать формата приема-передачи или параметры языка и региональных параметров по умолчанию, использовать другие перегрузки <xref:System.Numerics.BigInteger.ToString%2A> метода, как показано ниже:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат Round-Trip ("R")|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString>|  
|Формат Round-Trip ("R")|Определенного языка и региональных параметров|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Определенный формат|(Текущего) язык и региональные параметры по умолчанию|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format` Параметр может быть любым допустимым [строка стандартного числового](~/docs/standard/base-types/standard-numeric-format-strings.md), или любое сочетание [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Если `format` равен <xref:System.String.Empty?displayProperty=nameWithType> или `null`, возвращаемое значение текущего <xref:System.Numerics.BigInteger> объект форматируется с помощью описателя формата приема-передачи («R»). Если `format` задано любое другое значение, вызывает метод <xref:System.FormatException>.  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения о описатели стандартного числового формата, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о поддержке для форматирования в .NET Framework, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формате строки, возвращаемой этим методом для конкретного языка и региональных параметров. Когда <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> вызывается метод, он вызывает метод `provider` параметра <xref:System.IFormatProvider.GetFormat%2A> метод и передает его <xref:System.Type> , представляющий <xref:System.Globalization.NumberFormatInfo> типа. <xref:System.IFormatProvider.GetFormat%2A> Метод затем возвращает <xref:System.Globalization.NumberFormatInfo> объект, который предоставляет информацию о форматировании `value` параметра, например символ знака минус, символ-разделитель групп или символ десятичной запятой. Существует три способа использования `provider` указать сведения о форматировании для <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> метод:  
  
-   Вы можете передать <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых для этого языка и региональных параметров.  
  
-   Вы можете передать фактический <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых. (Его реализации <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Можно передать пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, форматированием возвращаемой строки зависит от <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере инициализируется <xref:System.Numerics.BigInteger> значение и отображает его на консоль с помощью строки стандартного формата и <xref:System.Globalization.NumberFormatInfo> объект, который определяет как отрицательный знак тильды (~).  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> не является допустимым форматом строки.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предпринимает попытку преобразования строкового представления числа в его эквивалент типа <see cref="T:System.Numerics.BigInteger" /> и возвращает значение, позволяющее определить, успешно ли выполнено преобразование.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Строковое представление числа.</param>
        <param name="result">После выполнения этого метода содержит эквивалент типа <see cref="T:System.Numerics.BigInteger" /> числа, содержащегося в параметре <paramref name="value" />, или нуль (0), если выполнить преобразование не удалось. Преобразование не удается выполнить, если значение параметра <paramref name="value" /> равно <see langword="null" /> или задано в неверном формате, Этот параметр передается неинициализированным.</param>
        <summary>Предпринимает попытку преобразования строкового представления числа в его эквивалент типа <see cref="T:System.Numerics.BigInteger" /> и возвращает значение, позволяющее определить, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Метод аналогичен <xref:System.Numerics.BigInteger.Parse%28System.String%29> за тем исключением, что он не создания исключения, если преобразование завершается неудачей. Этот метод исключает необходимость использовать обработку исключений для проверки <xref:System.FormatException> Если `value` является недопустимым и не может быть успешно обработан.  
  
 `value` Параметр должен иметь строковое представление десятичного числа в следующей форме:  
  
 [*ws*] [*входа*]*цифр*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел.|  
|*sign*|Необязательный знак. Допустимые знаки определяются по <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойства текущего языка и региональных параметров.|  
|*digits*|Последовательность десятичных цифр от 0 до 9.|  
  
> [!NOTE]
>  Строкой, указанной параметром `value` параметр не может содержать разделители групп или десятичного разделителя, и он не может иметь дробную часть.  
  
 `value` Параметр интерпретируется с использованием <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> стиля. Помимо десятичных разрядов допускаются только начальные и конечные пробелы, со знаком в начале. Чтобы явно определить элементы стиля с языком и региональными параметрами сведения об особенностях форматирования, могут быть представлены в `value`, вызовите <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> метод.  
  
 `value` Анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Эта перегрузка интерпретирует все цифры `value` параметра в виде десятичных цифр. Чтобы проанализировать строковое представление шестнадцатеричного числа, вызовите <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> перегрузку.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> метод для создания экземпляра два <xref:System.Numerics.BigInteger> объектов. В случае успешного выполнения преобразования умножает каждый объект на другое, а затем вызывает <xref:System.Numerics.BigInteger.Compare%2A> метод, чтобы определить связь между двумя объектами.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Строковое представление числа. Строка интерпретируется с использованием стиля, указанного в <paramref name="style" />.</param>
        <param name="style">Побитовое сочетание значений перечисления, обозначающих элементы стиля, которые могут быть представлены в параметре <paramref name="value" />. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <paramref name="value" /> в зависимости от языка и региональных параметров.</param>
        <param name="result">После выполнения этого метода содержит эквивалент типа <see cref="T:System.Numerics.BigInteger" /> числа, содержащегося в параметре <paramref name="value" />, или <see cref="P:System.Numerics.BigInteger.Zero" />, если выполнить преобразование не удалось. Преобразование не удается выполнить, если параметр <paramref name="value" /> имеет значение <see langword="null" /> или имеет формат, несовместимый со значением <paramref name="style" />, Этот параметр передается неинициализированным.</param>
        <summary>Предпринимает попытку преобразования числа в формате, который определяется заданным стилем и языком и региональными параметрами, в эквивалент типа <see cref="T:System.Numerics.BigInteger" /> и возвращает значение, определяющее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Метод аналогичен <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> за тем исключением, что он не создания исключения, если преобразование завершается неудачей. Этот метод исключает необходимость использовать обработку исключений для проверки <xref:System.FormatException> Если `value` является недопустимым и не может быть успешно обработан.  
  
 `style` Параметр определяет элементы стиля (например, пробелы и знак плюс или минус), которые разрешены в `value` параметр для успешного выполнения операции синтаксического анализа. Он должен представлять собой сочетание битовых флагов из <xref:System.Globalization.NumberStyles> перечисления. В зависимости от значения `style`, `value` параметр может содержать следующие элементы:  
  
 [*ws*] [*$*] [*входа*] [*цифр*,]*цифр*[. *цифры_дробной_части*] [E [*входа*]*экспоненциальные_цифры*] [*ws*]  
  
 Если `style` включает параметр <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` параметр может содержать следующие элементы:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут отображаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, или в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> свойство <xref:System.Globalization.NumberFormatInfo> объект, возвращаемый <xref:System.IFormatProvider.GetFormat%2A> метод `provider` параметра. Символ валюты может встречаться в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг и может отображаться в конце `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать скобки в `value` указывает отрицательное значение, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*digits*|Последовательность цифр от 0 до 9.|  
|*,*|Разделитель групп, зависящий от языка и региональных параметров. Разделитель групп, языка и региональных параметров, заданные `provider` могут присутствовать в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной запятой, языка и региональных параметров, заданные `provider` могут присутствовать в `value` Если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*fractional_digits*|Один или несколько вхождений цифры 0. Дробных разрядов может встречаться в `value` только если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `value` Параметр может представлять число в экспоненциальном представлении, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*exponential_digits*|Последовательность цифр от 0 до 9. `value` Параметр может представлять число в экспоненциальном представлении, если `style` включает в себя <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*hexdigits*|Последовательность шестнадцатеричных цифр от 0 до f или от 0 до F.|  
  
> [!NOTE]
> Символы (от U + 0000) завершающий NUL в `s` пропускаются операцией анализа, независимо от значения `style` аргумент.

 Строка только десятичных знаков (который соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> флаг) всегда успешно выполняет синтаксический анализ. Большинство оставшихся <xref:System.Globalization.NumberStyles> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать в этом входной строки. В следующей таблице показаны как отдельные <xref:System.Globalization.NumberStyles> члены влияют на элементы, которые могут присутствовать в `value`.  
  
|Простые `NumberStyles` значения|Элементы, допустимые в значении помимо цифр|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Только десятичные цифры.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичной запятой (*.*) и *цифры_дробной_части* элементов. Тем не менее *цифры_дробной_части* должен включать только один или несколько цифр 0, или этот метод возвращает `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» знаком, который указывает экспоненциальное представление, вместе с *экспоненциальные_цифры*. Если `value` представляет число в экспоненциальном представлении, он не может иметь ненулевое значение дробного компонента.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент перед *цифр*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* после элемента *цифр*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, заключив числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Разделитель групп (*,*) элемент.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Валюта (*$*) элемент.|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `value`, *входа* в начале `value`и десятичной запятой (*.*) символов. `value` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*, *входа*, разделитель групп (*,*) и десятичной запятой (*.*) элементов.|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Тем не менее `value` не может представлять шестнадцатеричное число.|  
  
> [!IMPORTANT]
>  При использовании <xref:System.Numerics.BigInteger.TryParse%2A> метод для обратного преобразования строкового представления объекта <xref:System.Numerics.BigInteger> значение, которое было выходные <xref:System.Numerics.BigInteger.ToString%2A> метод, следует использовать <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> метод с помощью описателя формата «R» для создания строкового представления <xref:System.Numerics.BigInteger> значение. В противном случае — строковое представление <xref:System.Numerics.BigInteger> сохраняет только 50 наиболее значимых цифр, исходное значение, и данные могут быть потеряны, если вы используете <xref:System.Numerics.BigInteger.TryParse%2A> метод восстановления <xref:System.Numerics.BigInteger> значение.  
  
 Если <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> флага `value` должен представлять собой шестнадцатеричное значение. Только другие флаги, которые могут быть представлены в `style` являются <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Перечисление имеет составной стиль <xref:System.Globalization.NumberStyles.HexNumber>, включающий в себя оба флага пустого пространства.)  
  
> [!NOTE]
>  Если `value` является строковым представлением шестнадцатеричного числа, он не может начинаться с описателей (таких как `0x` или `&h`), отличающее его как шестнадцатеричное число. Это приводит к сбою преобразования.  
  
 Если `value` является шестнадцатеричной строки, <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> метод интерпретирует `value` как отрицательное число, хранятся с помощью двух дополнением представление, в случае его первых двух шестнадцатеричных цифр больше или равно `0x80`. Другими словами, этот метод интерпретирует самого старшего бита первого байта в `value` называется знаковым битом. Чтобы убедиться в том, что шестнадцатеричной строки интерпретируется правильно как положительное число, первая цифра в `value` должен иметь нулевое значение. Например, этот метод интерпретирует `0x80` как отрицательное значение, но он интерпретирует либо `0x080` или `0x0080` как положительное значение. В следующем примере показано различие между шестнадцатеричных строк, представляющих положительные и отрицательные значения.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, который предоставляет зависящие от культуры сведения о формате параметра `value`. `provider` Параметр может принимать одно из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых для этого языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых. (Его реализации <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам себя.)  
  
-   Пользовательский объект, реализующий <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает экземпляр и возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере происходит несколько вызовов <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> метода с использованием различных сочетаний значений для `style` и `provider` параметров.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Ряд отдельные вызовы, чтобы <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> метод передать экземпляр из следующих `BigIntegerFormatProvider` класс, который определяет как отрицательный знак тильды (~).  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  
  
-или- 
 <paramref name="style" /> включает флаги <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> и <see cref="F:System.Globalization.NumberStyles.HexNumber" /> вместе с другим значениями.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее 0 (нуль).</summary>
        <value>Целое число, равное нулю (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Объект, возвращаемый этим свойством предоставляет удобный источник нулевое значение для использования в назначениях и сравнения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>