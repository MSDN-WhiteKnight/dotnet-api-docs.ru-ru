<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dbc0f7ae686463d4772e0cdd1f503f889472ddd" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56779386" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет базовый класс для службы, которая будет существовать в рамках служебного приложения. При создании нового класса службы необходимо наследовать от класса <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Являются производными от <xref:System.ServiceProcess.ServiceBase> при определении класса службы в приложении службы. Любая используемая служба переопределяет <xref:System.ServiceProcess.ServiceBase.OnStart%2A> и <xref:System.ServiceProcess.ServiceBase.OnStop%2A> методы. Для получения дополнительных возможностей, можно переопределить <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> с особое поведение в ответ на изменения в состоянии службы.  
  
 Служба — длительно исполняемом файле, который не поддерживает пользовательский интерфейс, и может не запускаться под учетной записью пользователя, выполнившего вход. Эта служба может работать без вмешательства пользователя, вход на компьютер.  
  
 По умолчанию службы работают с учетной записью System, который не совпадает с учетной записью администратора. Невозможно изменить права учетной записи System. Кроме того, можно использовать <xref:System.ServiceProcess.ServiceProcessInstaller> для указания учетной записи пользователя, под которой будет выполняться служба.  
  
 Исполняемый файл может содержать более одной службы, но может содержать отдельный <xref:System.ServiceProcess.ServiceInstaller> для каждой службы. <xref:System.ServiceProcess.ServiceInstaller> Регистрирует экземпляр службы в системе. Установщик также связывает каждой службы, можно использовать для записи команды службы журнала событий. `main()` Функция в исполняемом файле, определяет, какие службы должны выполняться. Текущий рабочий каталог службы — каталог системы, а не от каталога, в котором находится исполняемый файл.  
  
 При запуске службы, система находит исполняемый файл и запускает <xref:System.ServiceProcess.ServiceBase.OnStart%2A> метод для этой службы, содержащихся в исполняемый файл. Тем не менее со службой не так же, как выполнение исполняемого объекта. Исполняемый файл загружает только служба. Службе осуществляется через диспетчер управления службами в (например, остановки и запуска).  
  
 Исполняемый файл вызывает <xref:System.ServiceProcess.ServiceBase> производного класса конструктор первое время вызвать Start в службе. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Обработки команд метод вызывается сразу после выполнения конструктора. Конструктор не выполняется после первой загрузки службы, поэтому необходимости в разделении обработки, выполняемой с помощью конструктора от выполнения <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Все ресурсы, которые могут быть сняты по <xref:System.ServiceProcess.ServiceBase.OnStop%2A> должны создаваться в <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Создание ресурсов в конструкторе предотвращает их создание при запуске службы после <xref:System.ServiceProcess.ServiceBase.OnStop%2A> выпустила ресурсы.  
  
 Диспетчер управления службами (SCM) предоставляет способ взаимодействия со службой. Диспетчер управления Службами можно использовать для передачи в службу Start, Stop, Pause, продолжить или пользовательские команды. Диспетчер управления Службами использует значения <xref:System.ServiceProcess.ServiceBase.CanStop%2A> и <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> для определения, принимает ли служба остановки, приостановки или продолжения работы команды. Остановить, приостановить и продолжить включены в контекст SCM меню, только если соответствующее свойство <xref:System.ServiceProcess.ServiceBase.CanStop%2A> или <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> является `true` в классе службы. Если параметр включен, команда передается в службу, и <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, или <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> вызывается. Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, или <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `false`, соответствующий метод обработки команд (таких как <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) не будут обрабатываться, даже если вы уже был реализован.  
  
 Можно использовать <xref:System.ServiceProcess.ServiceController> класс можно сделать программным образом какие SCM делает, с помощью пользовательского интерфейса. Можно автоматизировать задачи, доступные в консоли. Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, или <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `true` , но не реализовали соответствующий метод обработки команд (таких как <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) система создает исключение и игнорирует команду.  
  
 Необходимо реализовать <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, или любой другой метод в <xref:System.ServiceProcess.ServiceBase>. Тем не менее, поведение службы описана в <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, поэтому как минимум, следует переопределить этот член. `main()` Функция исполняемого файла регистрирует службу в исполняемый файл с помощью диспетчера службы путем вызова <xref:System.ServiceProcess.ServiceBase.Run%2A> метод. <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Свойство <xref:System.ServiceProcess.ServiceBase> объект, передаваемый в <xref:System.ServiceProcess.ServiceBase.Run%2A> метод должен соответствовать <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> свойство установщика службы для этой службы.  
  
 Можно использовать `InstallUtil.exe` для установки служб в вашей системе.  
  
> [!NOTE]
>  Можно указать журнал, отличный от журнала событий приложения для получения уведомлений о вызовов службы, но ни один <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ни <xref:System.ServiceProcess.ServiceBase.EventLog%2A> свойство можно написать пользовательский журнал. Задайте <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `false` Если вы не хотите использовать автоматического ведения журнала.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр класса <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не создавайте экземпляр <xref:System.ServiceProcess.ServiceBase> класса. Вместо этого являются производными от <xref:System.ServiceProcess.ServiceBase> и создание экземпляра производного класса. Минимальное, вам нужно реализовать конструктор для класса, производного от <xref:System.ServiceProcess.ServiceBase> является установка <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> в компоненте. Требуется дополнительная обработка в конструкторе. Должен обрабатывать большинство инициализации в <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , а не в конструкторе. В противном случае нет никакой гарантии, которые объекты повторной инициализации при перезагрузке службы после ее остановки.  
  
 При переопределении в производном классе конструктор, вызовите конструктор базового класса в коде.  
  
 <xref:System.ServiceProcess.ServiceBase> Конструктора задает <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `true`. Если вы не хотите автоматически записывать вызовы к службе из диспетчера управления службами (SCM), задайте <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `false`.  
  
 Если исполняемый файл содержит одну службу, система вызывает конструктор службы при выборе из диспетчера управления Службами Start.  
  
 Если исполняемый файл содержит несколько служб, вызов запуска для одной службы вызывает конструкторы для вызова для всех служб в исполняемом файле, но запускается только указанную службу. Деструкторы для служб, выполняются друг с другом, когда все службы были остановлены, не по отдельности при остановке каждой службы.  
  
> [!NOTE]
>  Если конструктор базового класса, необходимо явно вызвать его в конструкторе производного класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет необходимость записи в журнал событий команд запуска, останова, паузы и возобновления.</summary>
        <value><see langword="true" /> — данные должны записываться в журнал событий; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `true` указывает службе журнала событий приложений, ошибки команд, а также информацию об изменении состояния для запустить, остановить, приостановить и продолжить события в службе. Имя службы используется в качестве журнала <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Чтобы сообщить сведения настраиваемый журнал событий, а не в журнале приложений, задайте <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `false` и записать инструкции в методах обработки команд <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A> для публикации в соответствующий журнал.  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Является строкой источника для журнала событий, необходимо задать, прежде чем служба пытается выполнить запись в журнал событий. Исключение при попытке доступ к журналу событий, прежде чем задать имя источника.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли служба обрабатывать уведомления об изменениях состояния питания компьютера.</summary>
        <value><see langword="true" />, если служба обрабатывает изменения состояния питания, указанные в классе <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменениях состояния питания компьютера, диспетчер управления службами (SCM) проверяет, принимает ли служба по значение <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> — `true`, команда передается в службу и <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> метод вызывается в том случае, если определено. Если <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> не реализован в производном классе, SCM обрабатывает события питания с помощью пустой базовый класс <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Это свойство изменено после запуска службы.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, может ли служба обрабатывать события изменения сеанса, принимаемые от сеанса сервера терминалов.</summary>
        <value><see langword="true" />, если служба может обрабатывать события изменения сеанса сервера терминалов; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Это свойство изменено после запуска службы.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее возможность приостановки и возобновления работы службы.</summary>
        <value><see langword="true" />, если работу службы можно приостановить; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установите для параметра <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> свойства в конструкторе для службы.  
  
 Если служба приостановлена, она останавливается, это происходит. При продолжении работы службы (через диспетчер управления службами или программным способом), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> выполняется.  
  
 При передаче запроса на приостановку службе сэкономить системные ресурсы. Приостановка освобождаются все системные ресурсы, но не Stop. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> часто применяется для уменьшения обработки, чем <xref:System.ServiceProcess.ServiceBase.OnStop%2A> и <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Когда <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `true`, переопределить <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> для указания обработки, которое должно выполняться, когда диспетчер управления службами (SCM) передает запрос на приостановку или остановку службы. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> должен быть реализован, чтобы отменить обработку в <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `false`, не будут передаваться приостановить или продолжить запросов в службу, поэтому <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> методы не вызываются, даже если они реализованы. В диспетчер управления Службами `Pause` и `Continue` элементы будут отключены при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> является `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Служба уже запущена. После запуска службы свойство <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> изменить нельзя.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее необходимость уведомления службы о завершении работы системы.</summary>
        <value><see langword="true" />, если служба должна получать уведомление о завершении работы системы; в противном случае — <see langword="false" />.  Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> является `true`, служба является уведомление о завершении работы системы. При завершении работы <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> метод вызывается в том случае, если он был реализован в производном классе.  
  
> [!NOTE]
>  Только системой <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> методом, выполняемым; служба может вызывать его, но это не рекомендуется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Служба уже запущена. После запуска службы свойство <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> изменить нельзя.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, можно ли остановить работу службы после ее запуска.</summary>
        <value><see langword="true" />, если возможны останов службы и вызов метода <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове службы, диспетчер управления службами (SCM) проверяет, принимает ли служба команды Stop, используя значение <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Для большинства служб, значение <xref:System.ServiceProcess.ServiceBase.CanStop%2A> является `true`, но некоторые службы операционной системы, например, не позволяет пользователю выпадов.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A> — `true`, команда Stop передается в службу и <xref:System.ServiceProcess.ServiceBase.OnStop%2A> метод вызывается в том случае, если он определен. Если <xref:System.ServiceProcess.ServiceBase.OnStop%2A> не реализован в производном классе обрабатывает SCM, команды Stop через пустой базовый класс <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Служба уже запущена. После запуска службы свойство <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> изменить нельзя.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.ServiceProcess.ServiceBase.Dispose%2A> в производном классе (и с его помощью в <xref:System.ServiceProcess.ServiceBase> класс) когда вы закончите, с помощью производного класса. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> Метод оставляет производного класса окажется в неработоспособном состоянии. После вызова метода <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, необходимо освободить все ссылки в производный класс и <xref:System.ServiceProcess.ServiceBase> , они резервирует память может быть освобожден при коллекцией мусора.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.ServiceProcess.ServiceBase.Dispose%2A> перед освобождением последней ссылки на класс, производный от <xref:System.ServiceProcess.ServiceBase>. В противном случае ресурсы <xref:System.ServiceProcess.ServiceBase> и производного класса при использовании будет не должна освобождаться до сбора мусора вызывает деструкторы объектов.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> часто применяется для обработки кода в <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, вместе с вызовом <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Если вы решили сделать это в производном классе, обычно реализуют <xref:System.ServiceProcess.ServiceBase.OnStart%2A> выделить все, что <xref:System.ServiceProcess.ServiceBase.Dispose%2A> выпуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает журнал событий, который можно использовать для записи в журнал событий приложения уведомлений о вызовах команд службы, например, команд запуска и останова.</summary>
        <value>Экземпляр <see cref="T:System.Diagnostics.EventLog" />, источник которого регистрируется в журнале приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор инициализирует <xref:System.ServiceProcess.ServiceBase.EventLog%2A> свойство для экземпляра с <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> заданными свойствами. Источником является <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> службы, и журнал — журнал приложения на компьютере. Эти значения задаются автоматически и для автоматического ведения журнала команд службы невозможно изменить.  
  
 Когда <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> является `true`, Start, Stop, Pause, продолжить и пользовательские команды автоматически записываются в журнал событий приложений. Можно использовать <xref:System.ServiceProcess.ServiceBase.EventLog%2A> свойство для записи журнала, а также дополнительные сообщения. Компонент вызывает метод <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> с помощью этого <xref:System.ServiceProcess.ServiceBase.EventLog%2A> член.  
  
 Чтобы сообщить сведения настраиваемый журнал событий, а не в журнале приложений, задайте <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> для `false` и записать инструкции в методах обработки команд <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A> для публикации в соответствующий журнал.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает код завершения для службы.</summary>
        <value>Код завершения для службы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> ненулевое значение перед остановкой службы в случае ошибки к диспетчеру управления службами.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Указывает максимальный размер имени службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName и DisplayName имеют ограничения на размер, необходимо соблюдать при задании свойств для класса службы.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если метод <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> реализован в производном классе, он запускается при передаче службе команды возобновления диспетчером служб. Задает действия, подлежащие выполнению при возобновлении нормальной работы службы после ее приостановки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализуйте <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> отражения ответ приложения <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. При продолжении работы службы (через консоль служб или программным способом), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> обработки выполняется и служба снова становится активным.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> свойство `true`.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `false`, не будут передаваться приостановить или продолжить запросов в службу, поэтому <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> методы не вызываются, даже если они реализованы. В диспетчер управления Службами `Pause` и `Continue` элементы будут отключены при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> является `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Сообщение команды, направляемое службе.</param>
        <summary>Если метод <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> реализован в производном классе, он выполняется при передаче службе пользовательской команды диспетчером служб. Задает действия, подлежащие выполнению при появлении команды с указанным значением параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> позволяет указать дополнительные функции, запуск, остановка, приостановка и возобновление службы.  
  
 Диспетчер управления Службами не проверяет пользовательскую команду, чтобы проверить, поддерживает ли служба `command` переданный параметр. Он передает пользовательскую команду непосредственно к службе. Если служба не распознает `command` параметр, он не выполняет никаких действий.  
  
 Пользовательские команды вызываются <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> инструкции в <xref:System.ServiceProcess.ServiceController> компонента. Использование оператора switch или, если... Выберите условие для обработки команды, которые задаются в службе.  
  
 Только значения для пользовательских команд, которые можно определить в вашем приложении или использовать в <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> распространяются от 128 до 255. Целые числа меньше 128 соответствуют значениям резервируемых системой.  
  
 Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> свойство `true`, пользовательские команды, как и другие команды, записи в журнал событий, чтобы сообщить, успешно ли завершилось выполнение метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если этот метод реализован в производном классе, он выполняется при передаче службе команды паузы диспетчером служб. Задает действия, подлежащие выполнению при приостановке работы службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceProcess.ServiceBase.OnPause%2A> для указания действий, выполняемых, когда служба получает команды приостановки. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> свойство `true`.  
  
 Когда вы продолжение работы приостановленной службы (либо через консоль служб или программным способом) <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> обработки запускается, и служба снова становится активным.  
  
 Данная команда приостановки только позволяет приложению реагировать на определенное событие. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> не выполняет никаких действий не определить его, чтобы сделать службу.  
  
 При передаче запроса на приостановку службе сохранения ресурсов системы, так как паузы не требует освобождения всех системных ресурсов. Например если потоки открытых процессом, приостановка службы, а не ее остановки потоки оставаться открытым, поэтому не нужно перераспределить их, если служба по-прежнему. Если вы определяете приостановить, чтобы освободить все ресурсы системы, он ведет себя как команды остановки.  
  
 Задайте <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> для `true`и Переопределите <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> для указания обработки, которое должно выполняться, когда диспетчер управления Службами передает запрос на приостановку или остановку службы. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> должен быть реализован, чтобы отменить обработку в <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> — `false`, не будут передаваться приостановить или продолжить запросов в службу, поэтому <xref:System.ServiceProcess.ServiceBase.OnPause%2A> и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> методы не вызываются, даже если реализованы. В диспетчер управления Службами `Pause` и `Continue` элементы будут отключены при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> является `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Класс <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />, определяющий выдаваемое системой уведомление о состоянии питания.</param>
        <summary>Если этот метод реализован в производном классе, он выполняется при изменении состояния питания компьютера. Это применимо для переносных компьютеров, когда они переходят в режим приостановки (этот режим отличается от режима завершения работы системы).</summary>
        <returns>Если этот метод реализован в производном классе, возвращаемое значение определяется требованиями приложения. Например, если передается состояние широковещания <see langword="QuerySuspend" />, можно заставить приложение отклонять запрос с возвратом значения <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> для указания действий, выполняемых при системного события, определенного в <xref:System.ServiceProcess.PowerBroadcastStatus> происходит перечисления — например, когда компьютер находится в режиме приостановки или разрядке батареи.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> свойство `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Структура, определяющая тип изменения.</param>
        <summary>Выполняется при получении события изменения от сеанса сервера терминалов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> свойства `true` для запуска этого метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если этот метод реализован в производном классе, он выполняется при завершении работы системы. Задает действия, выполняемые непосредственно перед завершением работы системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> для указания действий, выполняемых при завершении работы системы.  
  
 Это событие происходит только в том случае, когда операционная система завершает работу, не в том случае, если компьютер выключен.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> свойство `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Данные, передаваемые командой запуска.</param>
        <summary>Если этот метод реализован в производном классе, он выполняется при передаче службе команды запуска диспетчером служб или при запуске операционной системы (для служб, запускаемых автоматически). Задает действия, подлежащие выполнению при запуске службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceProcess.ServiceBase.OnStart%2A> для указания действий, выполняемых, когда служба получает команды запуска. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> — метод, в котором задается поведение службы. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> может принимать аргументы, как способ передачи данных, но такое использование возникает редко.  
  
> [!CAUTION]
>  Не используйте конструктор для выполнения обработки, который должен быть в <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Используйте <xref:System.ServiceProcess.ServiceBase.OnStart%2A> для обработки инициализации службы. Конструктор вызывается в том случае, когда приложение в исполняемый файл выполняется, не в том случае, при запуске службы. Исполняемый объект запускается перед <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. При продолжении, например, конструктор не вызывается снова, поскольку диспетчер управления Службами объект уже находится в памяти. Если <xref:System.ServiceProcess.ServiceBase.OnStop%2A> освобождает ресурсы, выделенные в конструкторе, а не в <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, необходимые ресурсы не приведет к созданию еще раз во второй раз вызове службы.  
  
 Службы можно задать для автоматического запуска после перезапуска компьютера, задав <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> на установщику службы <xref:System.ServiceProcess.ServiceStartMode.Automatic>. В таком случае <xref:System.ServiceProcess.ServiceBase.OnStart%2A> будет вызываться при запуске системы.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> должен переопределяться в производном классе. Для службы быть полезным <xref:System.ServiceProcess.ServiceBase.OnStart%2A> и <xref:System.ServiceProcess.ServiceBase.OnStop%2A> следует реализовать в классе службы.  
  
 Обработать аргументы инициализации для службы в <xref:System.ServiceProcess.ServiceBase.OnStart%2A> метод, не в методе Main. Аргументы в `args` массива параметров можно задать вручную в окне «Свойства» для службы в консоли службы. Аргументы, введенные в консоль, не сохраняются; они передаются в службу единовременно при запуске службы с помощью панели управления. Аргументы, которые должны присутствовать автоматически при запуске служба может размещаться в ImagePath строковое значение для ключа реестра службы (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< Имя службы >*). Аргументы можно получить из реестра с помощью <xref:System.Environment.GetCommandLineArgs%2A> метода, например: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если этот метод реализован в производном классе, он выполняется при передаче службе команды останова диспетчером служб. Задает действия, подлежащие выполнению при останове службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceProcess.ServiceBase.OnStop%2A> для указания действия, выполняемые при получении службой команды остановки.  
  
 Когда диспетчер управления Службами получает команды остановки, она использует значение <xref:System.ServiceProcess.ServiceBase.CanStop%2A> Чтобы проверить, принимает ли служба команды Stop. Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A> — `true`, команда Stop передается в службу и <xref:System.ServiceProcess.ServiceBase.OnStop%2A> метод вызывается в том случае, если он определен. Если <xref:System.ServiceProcess.ServiceBase.OnStop%2A> не реализован в службе, SCM обрабатывает команду остановки.  
  
 Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A> является `false`, диспетчер управления Службами не обрабатывает команду остановки. Не передается в службу. Возвращает команду остановки и создает исключение.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> должен переопределяться в производном классе. Для службы быть полезным <xref:System.ServiceProcess.ServiceBase.OnStart%2A> и <xref:System.ServiceProcess.ServiceBase.OnStop%2A> следует реализовать в классе службы.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Запрашиваемое время в миллисекундах.</param>
        <summary>Запрашивает дополнительное время для отложенной операции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Метод предназначен для вызова переопределенным <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A> методы, чтобы запросить дополнительное время для отложенной операции, чтобы предотвратить маркировки диспетчера управления службами (SCM) Служба как не отвечает.  Если ожидающая операция не продолжить, пауза, запуска или остановки, <xref:System.InvalidOperationException> возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Служба не находится в состоянии ожидания.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предоставляет основную точку входа для исполняемого файла службы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Класс <see cref="T:System.ServiceProcess.ServiceBase" />, определяющий службу для запуска.</param>
        <summary>Регистрирует исполняемый файл для службы с помощью диспетчера служб.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывают эту перегрузку `main()` функция исполняемый файл, чтобы зарегистрировать службу с помощью диспетчера службы Service. После вызова метода <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, диспетчер управления службами выдает команды запуска, который приводит к вызову для <xref:System.ServiceProcess.ServiceBase.OnStart%2A> метод в службе. Служба не запущена, пока не будет выполнена команда запуска.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Так же, как вызывается метод <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> для приложений Windows Forms.  
  
 Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> — `true`, запись записывается в журнал событий, если указанной службы `service` параметра не запускается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Массив экземпляров ServiceBase, определяющих службы для запуска.</param>
        <summary>Регистрирует исполняемый файл для нескольких служб с помощью диспетчера служб.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывают эту перегрузку `main()` функции службы для регистрации служб с помощью диспетчера служб. После вызова метода <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, диспетчер управления службами выдает команды запуска, которые приводят к вызовы <xref:System.ServiceProcess.ServiceBase.OnStart%2A> методы в службах. Службы не запущены, пока не будут выполнены команды запуска.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Так же, как вызывается метод <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> метод для приложений Windows Forms.  
  
 Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> является `true`, запись записывается в журнал событий, если происходит сбой запуска любой службы в массиве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Отсутствует служба для запуска. Массив может иметь значение <see langword="null" /> или быть пустым.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дескриптор управления службой.</summary>
        <value>Структура <see cref="T:System.IntPtr" />, содержащая дескриптор управления службой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескриптор управления службой используется для взаимодействия с диспетчера управления службами (SCM).  Дескриптор может использоваться для обновления сведений о состоянии диспетчера управления службами для вызова службы с помощью неуправляемых `SetServiceStatus` функции.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для доступа к неуправляемому коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">Число аргументов в массиве аргументов.</param>
        <param name="argPointer">Структура <see cref="T:System.IntPtr" />, указывающая на массив аргументов.</param>
        <summary>Регистрирует обработчик команд и запускает службу.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает короткое имя, используемое для идентификации службы в системе.</summary>
        <value>Имя службы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Определяет службу к диспетчеру управления службами. Значение этого свойства должно быть идентично имени службы в <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> свойства соответствующего класса установщика. В коде <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> службы обычно задается в `main()` функция исполняемого файла.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Также используется для указания <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> связанные с <xref:System.ServiceProcess.ServiceBase.EventLog%2A> свойство. Это <xref:System.ServiceProcess.ServiceBase.EventLog%2A> — это экземпляр, который записывает сведения о командах службы в журнал приложений.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Является строкой источника для журнала событий, необходимо задать перед началом записи в журнал событий. Пытается получить доступ к журналу событий, прежде чем задать имя источника вызывает исключение, исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Служба уже запущена. После запуска службы свойство <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> изменить нельзя.</exception>
        <exception cref="T:System.ArgumentException">Указанное имя представляет собой строку нулевой длины или больше, чем <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, либо указанное имя содержит прямую или обратную косую черту.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Останавливает работающую службу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A> Метод устанавливает состояние службы, чтобы указать, находится в состоянии ожидания остановки и вызовы <xref:System.ServiceProcess.ServiceBase.OnStop%2A> метод.  После остановки приложения состояния службы переходит в остановленное. Если приложение является размещенной службы, будет выгружен домен приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>