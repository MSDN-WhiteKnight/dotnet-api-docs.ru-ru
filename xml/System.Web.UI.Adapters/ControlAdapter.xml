<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d208ab52c1bde494504568095da9ff62fddda974" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55317695" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Настраивает отрисовку производного элемента управления, к которому присоединен адаптер, предназначенного для изменения стандартной разметки или поведения определенных браузеров, и является базовым классом, из которого наследуются все адаптеры элементов управления.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Адаптеры элементов управления, компоненты, которые переопределяют определенных <xref:System.Web.UI.Control> класса методам и событиям в цикле выполнения для обозревателя или обработки разметки. Адаптер одного производного элемента управления для сопоставления в .NET Framework <xref:System.Web.UI.Control> объекта для каждого запроса клиента.  
  
 Адаптер изменяет элемент управления для конкретного браузера или класса браузеров или выступает в качестве произвольный фильтр с некоторыми возможностями. Обычно адаптер определяется язык разметки, который использует браузер (например, XHTML или HTML 3.2). Большая часть адаптируемости поведения отрисовки может быть инкапсулирована в специальных классов, производных от <xref:System.Web.UI.HtmlTextWriter> класса. Таким образом, вполне вероятно, что один адаптер может использоваться для нескольких классов поведения обозревателя или что включение адаптируемости в <xref:System.Web.UI.HtmlTextWriter> классов может сделать ненужные использование адаптера элемента управления.  
  
 Адаптер для класса элемента управления применяется ко всем элементам управления, которые наследуют от этого класса, если отсутствуют более специализированные адаптеры. Например, адаптер для <xref:System.Web.UI.WebControls.BaseValidator> класс может использоваться для всех `Validator` объектов.  
  
 Адаптеры обычно не наследуют непосредственно от <xref:System.Web.UI.Adapters.ControlAdapter> класс, но из одного адаптера целевыми базовых классов, которые предоставляют функции, характерные для элемента управления типа и целевого браузера или необходимые для определенной отрисовки.  
  
 Сами элементы управления не требующими адаптер. Если элементы управления расширяются посредством композиции, обычно достаточно адаптеров дочерних элементов управления.  
  
 Каждый элемент управления имеет явные сопоставления с адаптерами посредством файлов определения типа BROWSER. Таким образом, любое обращение к <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> используется в свойстве <xref:System.Web.HttpBrowserCapabilities> объектов, извлеченных из файлов определения браузера для выполнения поиска для сопоставления адаптера элемента управления.  
  
 Во время обработки, платформа .NET перехватывает вызовы переопределяемых методов элемента управления, который может быть целевыми. Если присоединен адаптер элемента управления, .NET Framework вызывает методы связанного адаптера.  
  
 Адаптер выполняет отрисовку элемента управления через <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> метод. Если переопределено, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> потенциально не следует вызывать реализацию базового класса, так как в, который выполняет вызов <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> метод. Это может привести к отрисовке дважды, один раз адаптером и один раз с помощью элемента управления.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Основу вызовы методов <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> метод элемента управления. Таким образом Если переопределить <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, не следует вызывать реализацию базового класса, если подготовки, реализации, предоставляемой <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> элемента управления.  
  
 Необходимо убедиться, что платформа .NET Framework выполняет перехват для адаптеров дочерних элементов управления. Это можно сделать, вызвав <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> базовый метод, который вызывает <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> метод элемента управления, из вашего <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> переопределить.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> И <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> методы вызываются с помощью элемента управления, непосредственно перед и после (соответственно) управления вызывает <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> метод. Если до и после подготовки к просмотру только конкретного браузера обработке задач с помощью <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> может сделать его не нужно переопределить <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. По умолчанию <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> методы — вызвать соответствующие методы <xref:System.Web.UI.HtmlTextWriter>.  
  
 Чтобы поддерживать собственную информацию о состоянии, можно переопределить адаптер элемента управления <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, и <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> методы. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, и <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> вызываются, когда закрытый элемент управления и представление состояния и загрузки, соответственно.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, И <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> базовый вызов методов обратно на соответствующей <xref:System.Web.UI.Control> методы класса. Таким образом, любое из этих <xref:System.Web.UI.Adapters.ControlAdapter> методы, которые переопределяются следует вызывать их базовых методов; в противном случае связанные события с <xref:System.Web.UI.Control> не будет вызываться метод класса.  
  
 Элементы управления и адаптеры при необходимости реализовать <xref:System.Web.UI.IPostBackDataHandler> и <xref:System.Web.UI.IPostBackEventHandler> интерфейсов. .NET Framework определяет, существует ли адаптер и реализует ли эти интерфейсы. В этом случае адаптер должен переопределить <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, и <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> методов, при необходимости. Если данные обратной передачи, не распознается в адаптере, его необходимо вызвать элемент управления для его обработки. Последующие обработчики также должен выполнить обратный вызов в элементе управления.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс, элемент управления, который требует функциональных возможностей адаптера общие должен иметь базовый класс, указанный в шаблоне соответствующим адаптером <paramref name="ControlType" /> <see langword="Adapter" /> (например, <see langword="TextBoxAdapter" />). Как минимум адаптер должен возвращать строго типизированный экземпляр элемента управления с помощью его <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> свойство.  
  
1.  Адаптеры элементов управления для заданного элемента управления типа и языка разметки должен быть именован в шаблоне <paramref name="MarkupControlType" /> <see langword="Adapter" /> (например, <see langword="XhtmlTextBoxAdapter" />). Адаптеры для элемента управления, следует реализовать <see langword="Adapters" /> subnamespace.  
  
Адаптеры элементов управления должны наследовать от соответствующего базового класса и выполните ту же модель наследования, что элемент управления. Например, адаптер для наследования от элемента управления <see cref="T:System.Web.UI.Control" /> базовый класс должен наследовать от любого <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класса или соответствующие <paramref name="ControlType" /> <see langword="Adapter" /> класса.  
  
Любые специализированные адаптеры должны быть определены для специализированного элемента управления в группе все узлы в файлах конфигурации обозревателя устройств.  
  
Правильно реализованный элемент управления не следует предполагать, что адаптер подключен, или что присоединенный адаптер реализует определенный интерфейс. Вместо этого оно должно проверить перед вызовом.  
  
Можно имитировать, переопределения методов защищенное событие в элементе управления, такие как <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> метод <see cref="T:System.Web.UI.WebControls.LinkButton" />. Во-первых, создайте класс адаптера с <c>OnClick</c> метод. Затем создайте новый элемент управления, производный от <see cref="T:System.Web.UI.WebControls.LinkButton" /> и переопределить <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> метод. Переопределенное <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> вызовы методов <c>OnClick</c> метод адаптера. К объекту адаптера доступна через защищенный <see cref="P:System.Web.UI.Control.Adapter" /> свойство <see cref="T:System.Web.UI.Control" /> класса. <see cref="P:System.Web.UI.Control.Adapter" /> Свойство элемента управления является <see langword="null" /> при отсутствии связанного адаптера, поэтому следует проверить код для этого условия перед вызовом методов адаптера.</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework внутренне конструирует этот адаптер при создании соответствующего <xref:System.Web.UI.Control> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, содержащий методы отрисовки целевого вывода.</param>
        <summary>Вызывается до отрисовки элемента управления. В производном классе адаптеров генерируются открывающие теги, которые необходимы для определенной цели, но не требуются для HTML-браузеров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> Метод вызывается непосредственно перед вызовом <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> метод и используется для выполнения конкретных целевых объектов предварительной обработки перед отрисовкой элемента управления.  
  
 Используйте <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> метод в сочетании с <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> метод, чтобы гарантировать Открытие и закрытие тега согласованности.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс, <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> базового вызовы методов <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> метод. Таким образом, переопределяет из <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> метод должен вызывать <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> базовый метод только в том случае, если его обработка в дополнение к, а не вместо <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> метод.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на возможности клиентского браузера, создающего текущий HTTP-запрос.</summary>
        <value>Объект <see cref="T:System.Web.HttpBrowserCapabilities" /> определяет возможности клиентского браузера и разметки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Web.UI.Adapters.ControlAdapter> определяет возможности клиентского браузера из <xref:System.Web.HttpBrowserCapabilities> объект, возвращаемый <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> свойство. Это позволяет <xref:System.Web.UI.Adapters.ControlAdapter> отображения разметки в конкретном браузере или в противном случае изменения поведения объекта <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> свойство для доступа к сведения запрашивающего браузера. В этом примере код проверяет ли браузер, совместимый с JavaScript и затем позволяет разработчику в этом случае отображают настраиваемые выходные данные.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на элемент управления, к которому присоединен адаптер элемента управления.</summary>
        <value>Объект <see cref="T:System.Web.UI.Control" />, к которому присоединен этот элемент <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда адаптер производный элемент управления подключается к элементу управления, платформа .NET Framework вызывает определенные члены адаптера вместо набора элементов управления.  
  
   
  
## Examples  
 В следующем примере кода показано, как получение пользовательского элемента управления из <xref:System.Web.UI.Control> класса, а затем создать соответствующий адаптер, который наследует от <xref:System.Web.UI.Adapters.ControlAdapter> класса. Переопределяет адаптер <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> свойства и возвращает строго типизированную ссылку на элемент управления.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класса, как минимум, следует реализовать <see langword="Control" /> свойство для возвращения строго типизированный экземпляр элемента управления, как показано в разделе "Пример".</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает целевые дочерние элементы управления для составного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если имеется адаптер производного элемента управления присоединены к <xref:System.Web.UI.Control> объекта и <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> переопределяется метод, переопределенный метод вызывается вместо <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> метод. Таким образом <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> может использоваться для создания набора целевые дочерние элемента управления.  
  
 Дополнительные сведения об объединении элементов управления, чтобы создать новый элемент управления, см. в разделе [составных элементов управления](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если создание наследуемого класса и переопределить <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> метод не вызов базового метода, если вы не хотите добавлять элементы управления тем, созданным с помощью базового метода. В противном случае можно создать два набора дочерних элементов управления.</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, содержащий методы отрисовки целевого вывода.</param>
        <summary>Вызывается после отрисовки элемента управления. В производном классе адаптеров генерируются закрывающие теги, которые необходимы для определенной цели, но не требуются для HTML-браузеров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Метод вызывается сразу после <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> метод и используется для выполнения конкретных целевых объектов postprocessing после отрисовки элемента управления.  
  
 Используйте <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> метод в сочетании с <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> метод, чтобы гарантировать Открытие и закрытие тега согласованности.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс, <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> базового вызовы методов <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> метод. Таким образом, переопределяет из <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> метод должен вызывать <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> базовый метод только в том случае, если его обработка в дополнение к, а не вместо <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> метод.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Object" />содержащий сведения о состоянии адаптера элемента управления, такие. как <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Загружает сведения о состоянии адаптера элемента управления, которые были сохранены <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> во время предыдущего запроса страницы, на которой размещен элемент управления, связанный с адаптером элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние управления — важные сведения о состоянии необходимы, даже если состояние просмотра отключено. Когда адаптер должен поддерживать собственную информацию о состоянии элемента управления, его можно переопределить <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> методы.  
  
 Адаптер может потребоваться поддерживать сведения о состоянии управления, когда нет компонентов, которые должны иметь состояния между запросами, независимо от состояния связанного элемента управления. Например, составной элемент управления состоящий из большого текстового дисплея и группой <xref:System.Web.UI.WebControls.RadioButton> элементы управления могут отображать как отдельное представление браузеры для настольных компьютеров. В других браузерах можно разделять свою отрисовку - одно представление для текстового дисплея, а другой — для группы переключателей. Адаптер должен обслуживать собственный целевой информации о текущему активному представлению.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Метод вызывается сразу после <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> метод в `LoadState` этапе жизненного цикла. Состояние адаптера элемента управления, отдельные и состояние элемента управления элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Object" />, содержащий сведения о состоянии просмотра адаптера, такие как <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Загружает сведения о состоянии просмотра адаптера, сохраненные объектом <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> во время предыдущего запроса страницы, на которой размещен элемент управления, связанный с адаптером элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда адаптер должен поддерживать свои собственные сведения о состоянии представления, оно может заменить <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> методы.  
  
 Адаптер должен поддерживать сведения о состоянии представления, когда есть данные, которые должны сохраняться между запросами, независимо от состояния представления связанного элемента управления. Например элемент управления сетки на браузеры для настольных компьютеров могут отображать как единое представление строк и столбцов. В других браузерах можно разделять его подготовки к просмотру на несколько отдельных представлений, такой как список строк и сведения об одной строки. Адаптер должен обслуживать данные для представления, которые неактивны в настоящее время в состоянии представления.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Метод вызывается непосредственно перед <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> метод в `LoadState` этапе жизненного цикла. Состояние просмотра адаптера является отдельным и помимо состояния представления элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Переопределяет метод <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> для связанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если адаптер подключен к <xref:System.Web.UI.Control> объекта и <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> переопределяется метод, переопределенный метод вызывается вместо <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> метод.  
  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> для выполнения в целевой обработки `Initialize` Этап жизненного цикла элемента управления. Как правило имеются функции, которые выполняются при создании элемента управления.  
  
   
  
## Examples  
 В следующем образце кода производный адаптер пользовательского элемента управления из <xref:System.Web.UI.Adapters.ControlAdapter> класса. Затем он переопределяет <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> метод задания свойства сопоставленного элемента управления и вызвать базовый метод для завершения инициализации элемента управления.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс и переопределения адаптера <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> метод, адаптер необходимо вызвать соответствующий метод базового класса, который в свою очередь вызывает <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> метод. Если <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> не вызывается метод, <see cref="E:System.Web.UI.Control.Init" /> событие не возникнет.</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Переопределяет метод <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> для связанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если адаптер подключен к <xref:System.Web.UI.Control> объекта и <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> переопределяется метод, переопределенный метод вызывается вместо <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> метод.  
  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> метод для выполнения в целевой обработки `Load` Этап жизненного цикла элемента управления. Как правило это функции, которые должны выполняться для каждого запроса клиента.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс и переопределения адаптера <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> метод, адаптер необходимо вызвать соответствующий метод базового класса, который в свою очередь вызывает <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> метод. Если <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> не вызывается, <see cref="E:System.Web.UI.Control.Load" /> событие не возникнет.</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Переопределяет метод <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> для связанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если адаптер подключен к <xref:System.Web.UI.Control> объекта и <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> переопределяется метод, переопределенный метод вызывается вместо <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> метод.  
  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> метод для выполнения в целевой обработки `PreRender` Этап жизненного цикла элемента управления. Как правило имеются функции, непосредственно предшествующие визуализации выходных данных элемента управления.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс и переопределения адаптера <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> метод, адаптер необходимо вызвать соответствующий метод базового класса, который в свою очередь вызывает <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> метод. Если <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> не вызывается метод, <see cref="E:System.Web.UI.Control.PreRender" /> событие не возникнет.</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Переопределяет метод <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> для связанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если адаптер подключен к <xref:System.Web.UI.Control> объекта и <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> переопределяется метод, переопределенный метод вызывается вместо <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> метод.  
  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> метод для выполнения целевой обработки `Unload` Этап жизненного цикла элемента управления. Как правило имеются функции очистки, которые выполняются до удаления элемента управления.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс и переопределения адаптера <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> метод, адаптер необходимо вызвать соответствующий метод базового класса, который в свою очередь вызывает <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> метод. Если <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> не вызывается, <see cref="E:System.Web.UI.Control.Unload" /> событие не возникнет.</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на страницу, на которой располагается элемент управления, связанный с данным адаптером.</summary>
        <value>Объект <see cref="T:System.Web.UI.Page" />, обеспечивающий доступ к экземпляру страницы, на которой располагается связанный элемент управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> Свойство предоставляет доступ к <xref:System.Web.UI.Page?displayProperty=nameWithType> объекта, где расположен элемент управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на адаптер страницы для страницы, на которой располагается связанный элемент управления.</summary>
        <value>Объект <see cref="T:System.Web.UI.Adapters.PageAdapter" /> для страницы, на которой располагается элемент управления, связанный с текущим адаптером <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Свойство предоставляет доступ к <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> для объекта <xref:System.Web.UI.Page> объекта где <xref:System.Web.UI.Control> объект, связанный с текущим <xref:System.Web.UI.Adapters.ControlAdapter> располагается объект.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Свойство может использоваться для доступа к другим элементам на уровне страницы адаптера, такие как общие функции для конкретных целевых объектов, которые могут применяться к нескольким типам элементов управления на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, применяющийся для отображения целевого вывода.</param>
        <summary>Создает для элемента управления, к которому присоединен соответствующий адаптер, особую разметку, характерную для целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> метод для генерации целевую разметку для отправки в браузер клиента. <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Был вызван вместо <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> метод Если <xref:System.Web.UI.Adapters.ControlAdapter> объект присоединяется к <xref:System.Web.UI.Control> объекта.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс, <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> базового вызовы методов <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> метод. Таким образом, переопределяет из <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> метод должен вызывать <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> базовый метод только в том случае, если его обработка в дополнение к, а не вместо <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> метод.  
  
Для составного элемента управления разработчик адаптера необходимо убедиться, что дочерние элементы управления визуализируются. Если <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> метода заставляет дочерние элементы управления для отображения, но не создается разметки, может быть удобно для <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> метод для вызова базового метода. При необходимости в конкретных целевых объектов отрисовки дочерних элементов управления должны реализовывать адаптер <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> метод и вызвать <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> метода из <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> метод.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, применяющийся для отображения целевого вывода.</param>
        <summary>Создает целевую разметку для дочерних элементов управления в составном элементе управления, к которому присоединяется адаптер элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределить <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> метод, когда это необходимо создать целевую разметку для в наборе дочерних элементов управления из составного элемента управления, в дополнение к разметке для отдельных дочерних элементов управления.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> класс для составного элемента управления, разработчик адаптера необходимо убедиться, что дочерние элементы управления визуализируются. Если адаптер переопределяет <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> метод, он должен вызывать <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> метод из переопределения <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> метод.  
  
Если <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> метода заставляет дочерние элементы управления для отображения, но сам не создает разметку, может быть удобно для <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> метод для вызова его базовый метод, который вызывает <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> вместо реализации переопределение для метода <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> метод.</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет сведения о состоянии элемента управления для адаптера элемента управления.</summary>
        <returns>Объект <see cref="T:System.Object" />содержащий сведения о состоянии адаптера элемента управления, такие. как <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние управления — важные сведения о состоянии необходимы, даже если состояние просмотра отключено. Когда адаптер должен поддерживать собственную информацию о состоянии элемента управления, его можно переопределить <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> методы.  
  
 Адаптер может потребоваться поддерживать сведения о состоянии управления, когда нет компонентов, которые должны иметь состояния между запросами, независимо от состояния связанного элемента управления. Например, составной элемент управления состоящий из большого текстового дисплея и группой <xref:System.Web.UI.WebControls.RadioButton> элементы управления могут отображать как отдельное представление браузеры для настольных компьютеров. В других браузерах можно разделять свою отрисовку - одно представление для текстового дисплея, а другой — для группы переключателей. Адаптер должен обслуживать собственный целевой информации о текущему активному представлению.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Метод вызывается сразу после <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> метод в `SaveState` этапе жизненного цикла. Состояние адаптера элемента управления, отдельные и состояние элемента управления элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет сведения о состоянии просмотра для адаптера элемента управления.</summary>
        <returns>Объект <see cref="T:System.Object" />, содержащий сведения о состоянии просмотра адаптера, такие как <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда адаптер должен поддерживать свои собственные сведения о состоянии представления, оно может заменить <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> и <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> методы.  
  
 Адаптер должен поддерживать сведения о состоянии представления, когда есть данные, которые должны сохраняться между запросами, независимо от состояния просмотра связанного элемента управления. Например элемент управления сетки на браузеры для настольных компьютеров могут отображать как единое представление строк и столбцов. В других браузерах можно разделять его подготовки к просмотру на несколько отдельных представлений, такой как список строк и сведения об одной строки. Адаптер должен обслуживать данные для представления, которые неактивны в настоящее время в состоянии представления.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Метод вызывается непосредственно перед <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> метод в `SaveState` этапе жизненного цикла. Состояние просмотра адаптера является отдельным и помимо состояния представления элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>