<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="150d892884e4958b20bdde55fc1889994ef6ee77" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52604883" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Абстрактный базовый класс для обработчиков токенов безопасности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс является базовым классом, от которого все параметры безопасности наследуются обработчиков маркеров. Обработчик токенов безопасности отвечает за:  
  
-   Проверка маркеров безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>) типа, он предназначен для процесса и упаковки, утверждения, содержащиеся в маркере в <xref:System.Security.Claims.ClaimsIdentity> объекта.  
  
-   Сериализация и десериализация токены безопасности типа, в которой оно разработано для обработки.  
  
-   Сериализация и десериализация предложений идентификатора ключа (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), указывают на маркеры типа, он предназначен для обработки и обратно `<wsse:SecurityTokenReference>` элементов.  
  
-   Создание маркеров безопасности из <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> объекта, передаваемого по реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
-   Создание предложений идентификатора ключа с токеном безопасности для реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Windows Identity Foundation (WIF) поставляется следующие обработчики маркеров безопасности:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Большую часть этих классов предоставляют дополнительные члены, которые реализации функциональных возможностей, специфичную для обработки токенов, для которых предназначен этот класс. Во многих случаях может быть лучше быть производным от одного из этих классов, а не непосредственно из <xref:System.IdentityModel.Tokens.SecurityTokenHandler> класса.  
  
 Обработчик токенов безопасности можно добавлять или удалять из коллекции обработчиков токена, указав [ &lt;добавить&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;удалить&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), или [ &lt;снимите&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) элементов под [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) элемент в файле конфигурации. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Объект, который содержит параметры конфигурации для коллекции обработчиков может осуществляться через <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойства и в коллекцию обработчиков, членом которых является обработчик токенов может осуществляться из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> свойство. Можно переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> метод для обработки любого пользовательские элементы конфигурации, который принимает ваш обработчик.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс предоставляет несколько свойств и методов. В зависимости от функций, вы решили реализовать может переопределить некоторые или все из этих членов.  
  
 Необходимо переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> метод для предоставления сведений о типе маркера безопасности, ваш класс инфраструктуры WIF предназначена для обработки.  
  
 Проверка, сериализации и десериализации предоставляется через свойства или методы, которые указывают, может ли обработчик выполнять определенную функцию в сочетании с метод или методы, которые реализуют функциональные возможности. Следующий список пар ", свойства или методы, которые указывают функциональные возможности с методами, которые реализуют функциональные возможности:  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> Свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод: проверяет токен и упаковывает утверждений, содержащихся в маркере в <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> методы: маркер сериализации.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Методы и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> методы: маркер десериализации.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> Метод и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> метод: десериализации предложения идентификатора ключа.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Метод и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> метод: сериализации предложения идентификатора ключа.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> И <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> методы вызываются из конвейера в реализациях <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Метод вызывается инфраструктурой WIF, чтобы определить, является ли указанный токен уже получен. По умолчанию этот метод возвращает `false`, который указывает, что токен еще не были получены. Можно переопределить метод и предоставить логику для обнаружения переигранных токенов.  
  
   
  
## Examples  
 В примерах кода во всех <xref:System.IdentityModel.Tokens.SecurityTokenHandler> разделы берутся из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md). Следующий код XML показано, как добавить обработчик токенов SWT в коллекцию обработчиков токенов.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах для инициализации класса <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, предложением идентификатора ключа, которое может десериализоваться этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `false` для указания, что не удается прочитать предложение идентификатора ключа.  
  
 Производном классе проверяет элемент, который ссылается на чтения для определения, может ли экземпляр десериализовать предложения идентификатора ключа. Обычно это выполняется посредством вызова <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> метод со соответствующий элемент и пространство имен строками, указанными. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> метод, чтобы предоставить логику для десериализации предложения идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, показывающее, может ли указанный токен десериализоваться как токен типа, обработанного этим экземпляром.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка токена для чтения</param>
        <summary>Возвращает значение, показывающее, может ли указанная строка десериализоваться как токен типа, обработанного этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод для предоставления логики нужно десериализовать токен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, считываемым, как токен типа, обрабатываемого этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 Производном классе проверяет элемент, который ссылается на чтения для определения, может ли экземпляр десериализовать маркер безопасности. Обычно это выполняется посредством вызова <xref:System.Xml.XmlReader.IsStartElement%2A> метод со соответствующий элемент и пространство имен строками, указанными. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод или <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод, чтобы предоставить логику для десериализации предложения идентификатора ключа.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> метод, чтобы определить, может ли токен быть считан обработчиком. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик поддерживать проверку токенов безопасности.</summary>
        <value>Значение <see langword="true" />, если класс может проверять токены безопасности; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для проверки реализации в производном классе, переопределить это свойство для возврата `true` и переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод, чтобы реализовать логику проверки.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> свойство, указывающее, что настраиваемый обработчик может проверять токены. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Предложение идентификатора ключа для проверки.</param>
        <summary>Возвращает значение, показывающее, может ли указанная конструкция идентификатора ключа быть сериализована этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если можно сериализовать конструкцию идентификатора ключа; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> метод, чтобы предоставить логику для сериализации предложения идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик сериализовать токены безопасности.</summary>
        <value><see langword="true" />, если класс может выполнять сериализацию токенов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для сериализации реализации в производном классе, переопределить это свойство для возврата `true` и переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> методы для реализации логики сериализации.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство, указывающее, что настраиваемый обработчик может сериализовать маркеры. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" />, который предоставляет конфигурацию для текущего экземпляра.</summary>
        <value>Объект конфигурации для текущего экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Свойство обычно задается в инфраструктуре конфигурации из [ &lt;securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) запускаются в файле конфигурации во время приложения.  
  
 В производных классах, использовании <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство для доступа к параметрам конфигурации, например реестр имен издателей для использования в <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод может быть организован <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> свойства объекта конфигурации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию обработчиков токена, содержащую текущий экземпляр.</summary>
        <value>коллекция обработчиков токена, содержащая текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При добавлении обработчика токенов <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> экземпляр, это свойство автоматически устанавливается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Токен, для которого требуется создать ссылку.</param>
        <param name="attached">Значение <see langword="true" />, если должна быть создана присоединенная ссылка; значение <see langword="false" />, если должна быть создана неприсоединенная ссылка.</param>
        <summary>При переопределении в производном классе создает ссылку токена безопасности для токенов, обрабатываемых этим классом. Этот метод обычно вызывается службой токенов безопасности (STS).</summary>
        <returns>Предложение идентификатора ключа, ссылающееся на указанный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Производные классы переопределить этот метод для возврата конструкцию идентификатора ключа (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), может быть использован для создания `<wsse:SecurityTokenReference>` элемент для указанного токена.  
  
 Вызывается из реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Как правило <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> не нужно будет использовать только при создании пользовательской службы маркеров безопасности. Когда служба маркеров безопасности возвращает маркер безопасности, выданный маркер безопасности содержит ссылки на прикрепленные и неприкрепленные маркеры безопасности. Прикрепленные ссылки указывают на маркеры безопасности, содержащиеся в заголовке безопасности сообщения SOAP, а неприкрепленные ссылки указывают на маркеры безопасности, не входящие в заголовок безопасности сообщения SOAP. Обычно эти ссылки подтверждают подлинность выданного маркера безопасности.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> метод, чтобы создать предложение идентификатора ключа с указанным токеном. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Дескриптор токена безопасности, на основании которого создается токен. Свойства дескриптора токена задаются до вызова этого метода.</param>
        <summary>При переопределении в производном классе создает токен безопасности с помощью заданного дескриптора токена. Этот метод вызывается службой токенов безопасности (STS).</summary>
        <returns>токен безопасности, соответствующий свойствам дескриптора токена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Вызывается из реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> метод для создания и вернуть маркер из дескриптора токена. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки воспроизведения.</param>
        <summary>При переопределении в производном классе вызывает исключение, если обнаруживается, что указанный токен используется повторно.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию не выполняет никаких действий.  
  
 Производные классы должны вызывать <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> Если токен уже используется.  
  
 Windows Identity Foundation (WIF) предоставляет <xref:System.IdentityModel.Tokens.TokenReplayCache> класс, из какой воспроизведения может быть получен кэши и [ &lt;tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) элемента конфигурации, который может использоваться для настройки кэш воспроизведения, используемый для обработчиков маркеров в приложении; Тем не менее конкретно <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> метод зависит от конструктора производного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает набор универсальных кодов ресурса (URI), которые используются в запросах для идентификации токена обрабатываемого этим классом типа.</summary>
        <returns>Набор универсальных кодов ресурсов (URI), определяющих тип токенов, поддерживаемый этим обработчиком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> Токен, обрабатываемый текущим экземпляром осуществляется через <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Метод возвращает набор допустимых идентификаторов, которые могут быть использованы в сообщениях для ссылки на тип токена. Например, значение URI используется в `<wst:TokenType>` элемента под `<wst:RequestSecurityToken>` элемент для запроса определенного типа маркера (представленный <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> свойства в модели объектов).  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> метод для возврата идентификаторов тип маркера для пользовательского маркера. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">XML-элемент конфигурации. Каждый узел в списке имеет тип <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>При переопределении в производном классе загружает пользовательскую конфигурацию из XML-кода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Метод вызывается в инфраструктуре конфигурации. При вызове этого метода, `nodelist` будет содержать верхнего уровня дочерние элементы данного обработчика токенов, [ &lt;добавить&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) элемент из файла конфигурации. Каждый из них может в свою очередь, содержит атрибуты или дочерние элементы в зависимости от конфигурации схемы, определяемые для производного класса.  
  
 Реализация по умолчанию вызывает <xref:System.NotImplementedException>. Переопределите этот метод в производном классе позволяет включить инициализацию обработчика маркеров безопасности из файла конфигурации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, расположенный в начальном элементе XML, который десериализуется в предложение идентификатора ключа.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в конструкцию идентификатора ключа, который ссылается на токен, обрабатываемый производным классом.</summary>
        <returns>Предложение идентификатора ключа, десериализованное из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления логики для десериализации предложения идентификатора ключа из XML. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе десериализует заданный XML-код в токен обрабатываемого этим производным классом типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка, подлежащая десериализации.</param>
        <summary>При переопределении в производном классе десериализует заданную строку в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из указанной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления функций, который может десериализовать маркер безопасности из строки. Если переопределить, этот метод необходимо переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <summary>При переопределении в производном классе десериализует десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления логики для десериализации из XML маркера безопасности. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не может десериализовать маркер на основе XML, на которую указывает ссылка, он выдает <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> метод для чтения пользовательский маркер из указанного средства чтения XML. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <param name="tokenResolver">сопоставитель токена, содержащий внештатные и кэшированных токены.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен, обрабатываемый производным классом, путем использования заданного сопоставителя токенов.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Реализация по умолчанию игнорирует `tokenResolver` параметр и делегирует вызов <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод.  
  
 Переопределите этот метод для предоставления логики для десериализации из XML маркера безопасности. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не может десериализовать маркер на основе XML, на которую указывает ссылка, он выдает <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает тип токена безопасности, обрабатываемого этим экземпляром.</summary>
        <value>Тип токена безопасности, обрабатываемого этим экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо переопределить это свойство в производных классах и вернуть <xref:System.Type> маркера безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>) обрабатывается производным классом.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> возвращаемое свойство <xref:System.Type> , обрабатываемых пользовательским обработчиком маркеров безопасности. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Токен безопасности, который проверяется.</param>
        <param name="errorMessage">Сообщение для записи в трассировку.</param>
        <summary>Трассирует событие сбоя во время проверки токенов безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод при сбое проверки токена.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Проверенный токен.</param>
        <summary>Трассирует успешную проверку событий токен безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод после успешной проверки маркера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки.</param>
        <summary>При переопределении в производном классе проверяет указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Идентификаторы, содержащееся в токене.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Метод вызывается инфраструктурой для проверки и извлекает утверждения из маркера десериализованные безопасности. Эти утверждения возвращаются в коллекцию <xref:System.Security.Claims.ClaimsIdentity> объектов, возвращаемых методом. В типичной ситуации эта коллекция будет содержать единую идентификацию.  
  
 В производных классах, проверки обычно включает в себя проверку аудитория, указанный в токене от кодов URI, заданных в аудитории <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> свойства объекта конфигурации обработчика токенов, указанные на <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство. Эти URI обычно задаются в файле конфигурации в узле [ &lt;audienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) элемент. Если не удается проверить аудитории, <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> необходимость создания исключения.  
  
 При обработке лексемы, поставщик обычно проверяется путем передачи маркера издателя к одному из <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> методы <xref:System.IdentityModel.Tokens.IssuerNameRegistry> , настроенный для обработчика через <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство. Реестр имен издателей обычно настраивается с помощью [ &lt;issuerNameRegistry&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) элемент в файле конфигурации. <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Возвращает имя издателя. Это имя должно использоваться для задания <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> свойство в утверждения, содержащиеся в маркере. Если реестр имен издателей не содержит запись для издателя маркера, <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> возвращает `null`. В этом случае <xref:System.IdentityModel.Tokens.SecurityTokenException> обычно вызывается в производных классах, но это поведение зависит от конструктора класса.  
  
   
  
## Examples  
 В следующем коде показано переопределение <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода для обработчика маркеров безопасности, который обрабатывает простой веб-маркеры (SWT). Код взят из `CustomToken` образца. Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 В следующем коде показан `CreateClaims` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод в предыдущем примере. Этот метод возвращает <xref:System.Security.Claims.ClaimsIdentity> объект, созданный на основе утверждений в маркере. Код взят из `CustomToken` образца. Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 В следующем коде показан `ValidateSignature` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод в обработчике простой веб-маркера. Этот метод проверяет подпись маркера, используя настроенный <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Код взят из `CustomToken` образца. Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 В следующем коде показан `ValidateAudience` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод в обработчике простой веб-маркера. Этот метод проверяет аудитории, содержащихся в маркере с URI аудитории, были указаны в конфигурации. Код взят из `CustomToken` образца. Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="securityKeyIdentifierClause">Конструкция идентификатора ключа для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанную конструкцию идентификатора ключа в формат XML. Предложения идентификатора ключа должно иметь тип, поддерживаемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления логики для сериализации конструкции идентификатора ключа в XML. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в строку. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Сериализованный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления логики для сериализации токена безопасности в XML. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в формат XML. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод вызывает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления логики для сериализации токена безопасности в XML. Если вы Переопределите этот метод, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
   
  
## Examples  
 Ниже показано, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> метод сериализации пользовательского маркера. Код взят из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения об этом образце и других примеров, доступных для WIF и где их можно скачать, см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>