<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c9a486faca32942b613bb0f56059ee6c2c59528" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57955222" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет событие синхронизации потока.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle> Класс позволяет потокам взаимодействовать друг с другом, обмениваясь сигналами. Как правило, один или несколько потоков блокируются в <xref:System.Threading.EventWaitHandle> пока незаблокированный поток не вызовет <xref:System.Threading.EventWaitHandle.Set%2A> метод, освобождения одного или нескольких заблокированных потоков. Поток может сообщить <xref:System.Threading.EventWaitHandle> и затем заблокировать на нем, вызвав `static` (`Shared` в Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle> Класс предоставляет доступ к именованные системные события синхронизации.  
  
 Поведение <xref:System.Threading.EventWaitHandle> , было сообщено зависит от режима его сброса. <xref:System.Threading.EventWaitHandle> Созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флаг сбрасывается автоматически после освобождения одиночного потока ожидания. <xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>, находится в сигнальном состоянии, пока не будет вызван его метод <xref:System.Threading.EventWaitHandle.Reset%2A>.  
  
 События с автоматическим сбросом предоставляют эксклюзивный доступ к ресурсу. Если событие с автоматическим сбросом создается при отсутствии потоков в состоянии ожидания, оно сохраняет свой статус, пока не получит обращение от потока. Тогда событие освобождает поток и немедленно сбрасывается, блокируя следующие потоки.  
  
 Ручной Сброс событий как шлюзы. Когда событие не создано, потоки, ожидающие его блокирует. Если событие сигнализирует, все ожидающие потоки освобождаются и событие получает сигнал (то есть последующие не блокируется) пока его <xref:System.Threading.EventWaitHandle.Reset%2A> вызывается метод. Ручной сброс события полезны, когда один поток должен завершить действие, прежде чем будет продолжена других потоков.  
  
 <xref:System.Threading.EventWaitHandle> объекты, которые могут использоваться с `static`(`Shared` в Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы.  
  
 Дополнительные сведения см. в разделе [потоков взаимодействия, или передачи сигнала](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) раздел [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md) статьи.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегруженный метод, чтобы разрешить основному потоку сигнала заблокированный поток и затем подождите, пока поток завершает задачу.  
  
 В примере запускается пять потоков и позволяет им блокировать на <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флаг, а затем времени одним потоком выпусков, пользователь нажимает клавишу ВВОД. Затем ставит в очередь другой пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">Значение <see langword="true" /> для задания начального состояния сигнальным; <see langword="false" /> для задания несигнального начального состояния.</param>
        <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяя, получает ли сигнал, ожидающий дескриптор, и производится ли сброс автоматически или вручную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если начальное состояние события является несигнальным, будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние и <xref:System.Threading.EventResetMode.ManualReset> установлен флаг для `mode`, не будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние, и `mode` является <xref:System.Threading.EventResetMode.AutoReset>, первый поток, который ожидает событие освобождается немедленно, после чего событие сбрасывается, и последующие потоки блокируются.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегруженный метод, чтобы разрешить основному потоку сигнала заблокированный поток и затем подождите, пока поток завершает задачу.  
  
 В примере запускается пять потоков и позволяет им блокировать на <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флаг, а затем времени одним потоком выпусков, пользователь нажимает клавишу ВВОД. Затем ставит в очередь другой пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</param>
        <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
        <param name="name">Имя события синхронизации на уровне системы.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяющего получает ли сигнал дескриптор ожидания, если он был создан в результате данного вызова, сбрасывается ли он автоматически или вручную, а также имя системного события синхронизации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` — `null` или является пустой строкой, локальный <xref:System.Threading.EventWaitHandle> создается.  
  
 Если системное событие с именем, указанным для `name` параметр уже существует, `initialState` параметр учитывается.  
  
> [!IMPORTANT]
>  При использовании этого конструктора для именованного системного события, укажите `false` для `initialState`. Этот конструктор предоставляет не может определить, было ли создано именованное системное событие, поэтому нельзя делать никаких предположений о состоянии именованного события. Чтобы определить, был ли создан именованного события, используйте <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> конструктор или <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> конструктор.  
  
 Если начальное состояние события является несигнальным, будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние и <xref:System.Threading.EventResetMode.ManualReset> установлен флаг для `mode`, не будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние, и `mode` является <xref:System.Threading.EventResetMode.AutoReset>, первый поток, который ожидает событие освобождается немедленно, после чего событие сбрасывается, и последующие потоки блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</param>
        <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
        <param name="name">Имя события синхронизации на уровне системы.</param>
        <param name="createdNew">Когда данный метод возвращает значение, он содержит <see langword="true" />, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение <see langword="null" /> или пустую строку) или было создано системное событие с заданным именем; либо значение <see langword="false" />, если указанное именованное событие уже существовало. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" /> и указывает следующие сведения: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова; выполнять ли сброс автоматически или вручную; имя системного события синхронизации; логическая переменная для сохранения информации о том, было ли создано именованное системное событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если системное событие с именем, указанным для `name` параметр уже существует, `initialState` параметр учитывается. После вызова этого конструктора, используйте значение в переменной, указанной для `ref` параметра (`ByRef` в Visual Basic)`createdNew` определить именованное системное событие уже существует или был создан.  
  
 Если начальное состояние события является несигнальным, будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние и <xref:System.Threading.EventResetMode.ManualReset> установлен флаг для `mode`, не будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние, и `mode` является <xref:System.Threading.EventResetMode.AutoReset>, первый поток, который ожидает событие освобождается немедленно, после чего событие сбрасывается, и последующие потоки блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState">Значение <see langword="true" /> обозначает, что именованное событие получит исходное сигнальное состояние, если такое событие создается в результате этого вызова; значение <see langword="false" /> устанавливает несигнальное состояние.</param>
        <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" />, которое определяет, выполняется ли сброс события автоматически или вручную.</param>
        <param name="name">Имя события синхронизации на уровне системы.</param>
        <param name="createdNew">Когда данный метод возвращает значение, он содержит <see langword="true" />, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение <see langword="null" /> или пустую строку) или было создано системное событие с заданным именем; либо значение <see langword="false" />, если указанное именованное событие уже существовало. Этот параметр передается неинициализированным.</param>
        <param name="eventSecurity">Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, определяющий настройки управления доступом для применения к именованному системному событию.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.EventWaitHandle" /> с указанием следующих сведений: передавать ли сигнал в дескриптор ожидания при первичном запуске в результате этого вызова, выполнять ли сброс автоматически или вручную, имя системного события синхронизации, логическая переменная для сохранения информации о том, было ли создано именованное системное событие, правила управления доступом для именованного события, если оно создается.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется для применения управления доступом для именованного системного события при его создании, чтобы предотвратить возможность управления события другого кода.  
  
 Этот конструктор инициализирует <xref:System.Threading.EventWaitHandle> объект, представляющий системное событие. Вы можете создать несколько <xref:System.Threading.EventWaitHandle> объектов, представляющих одно и то же событие системы.  
  
 Если системное событие не существует, он создается с указанного элемента управления доступом. Если событие существует, указанный управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над только что созданный <xref:System.Threading.EventWaitHandle> объект, даже если `eventSecurity` запрещает или не удалось предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.EventWaitHandle> объекта представляют одинаковую меру с именем события, с помощью конструктора или <xref:System.Threading.EventWaitHandle.OpenExisting%2A> метод применения управления доступом Windows.  
  
 Если системное событие с именем, указанным для `name` параметр уже существует, `initialState` параметр учитывается. После вызова этого конструктора, используйте значение в переменной, указанной для `ref` параметра (`ByRef` в Visual Basic) `createdNew` определить именованное системное событие уже существует или был создан.  
  
 Если начальное состояние события является несигнальным, будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние и <xref:System.Threading.EventResetMode.ManualReset> установлен флаг для `mode`, не будет блокировать потоки, ожидающие события. Если начальное состояние переводится в сигнальное состояние, и `mode` является <xref:System.Threading.EventResetMode.AutoReset>, первый поток, который ожидает событие освобождается немедленно, после чего событие сбрасывается, и последующие потоки блокируются.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованное системное событие с помощью управления доступом. В примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного события.  
  
 Если событие не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает право использовать события для текущего пользователя, но не дает право на чтение и изменение разрешений события.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегруженный метод для ожидания события с помощью прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, событие открыт с помощью прав, необходимых для ожидания и сигнал. При запуске скомпилированный пример в третьем окне команды в этом примере запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует и имеет настройки управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, представляющий управление доступом для именованного системного события, представленного объектом <see cref="T:System.Threading.EventWaitHandle" />.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, представляющий управление доступом для именованного системного события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> Методе используется комбинация флагов (в сочетании с помощью побитовой операции OR) для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> права для вызова этого метода и события должен быть открыт с <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> флаг.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованное системное событие с помощью управления доступом. В примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного события.  
  
 Если событие не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает право использовать события для текущего пользователя, но не дает право на чтение и изменение разрешений события.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегруженный метод для ожидания события с помощью прав, необходимых для чтения и изменения разрешений.  
  
 После разрешения были прочитаны с помощью <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> метод, и изменении события открыт с помощью прав, необходимых для ожидания и сигнал. При запуске скомпилированный пример в третьем окне команды в этом примере запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> представляет именованное системное событие, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
-или- 
Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> представляет именованное системное событие, но оно не было открыто с правами <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался метод <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанное именованное событие синхронизации, если оно уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
        <summary>Открывает указанное именованное событие синхронизации, если оно уже существует.</summary>
        <returns>Объект, представляющий именованное системное событие.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Метод пытается открыть заданное именованное системное событие. Если системное событие не существует, этот метод выдает исключение вместо создания системного события. Чтобы создать системное событие, если он еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.EventWaitHandle> объекта, несмотря на то, что объекты, возвращаемые представляют один и то же именованное системное событие.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегрузку метода с указанием <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.  
  
 Указание <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на именованное системное событие с указанием <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A> методы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованное системное событие с помощью управления доступом. В примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного события.  
  
 Если событие не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает право использовать события для текущего пользователя, но не дает право на чтение и изменение разрешений события.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегруженный метод для ожидания события с помощью прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, событие открыт с помощью прав, необходимых для ожидания и сигнал. При запуске скомпилированный пример в третьем окне команды в этом примере запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное системное событие не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, но у пользователя нет необходимых для его использования прав доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа.</summary>
        <returns>Объект, представляющий именованное системное событие.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания события и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A> методы.  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Метод пытается открыть существующее именованное системное событие. Если системное событие не существует, этот метод выдает исключение вместо создания системного события. Чтобы создать системное событие, если он еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.EventWaitHandle> объекта, несмотря на то, что объекты, возвращаемые представляют один и то же именованное системное событие.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованное системное событие с помощью управления доступом. В примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного события.  
  
 Если событие не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает право использовать события для текущего пользователя, но не дает право на чтение и изменение разрешений события.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегруженный метод для ожидания события с помощью прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, событие открыт с помощью прав, необходимых для ожидания и сигнал. При запуске скомпилированный пример в третьем окне команды в этом примере запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное системное событие не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает несигнальное состояние события, вызывая блокирование потоков.</summary>
        <returns><see langword="true" />, если операция прошла успешно; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался метод <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает сигнальное состояние события, позволяя одному или нескольким ожидающим потокам продолжить.</summary>
        <returns><see langword="true" />, если операция прошла успешно; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (включая <xref:System.Threading.AutoResetEvent>), <xref:System.Threading.EventWaitHandle.Set%2A> метод освобождает один поток. Если нет ожидающих потоков, дескриптор ожидания остается сигнальным до поток попытается ожидать его, или до его <xref:System.Threading.EventWaitHandle.Reset%2A> вызывается метод.  
  
> [!IMPORTANT]
>  Нет никакой гарантии, при каждом вызове <xref:System.Threading.EventWaitHandle.Set%2A> метод выпустит поток из <xref:System.Threading.EventWaitHandle> чей режим сброса <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Если два вызова, слишком близко друг к другу, что второй вызов происходит до выпустила поток освобождается только один поток. Это не так, как если произошел второй вызов. Кроме того Если <xref:System.Threading.EventWaitHandle.Set%2A> вызывается, когда нет ожидающих потоков и <xref:System.Threading.EventWaitHandle> уже есть сигнал, вызов не оказывает влияния.  
  
 Для <xref:System.Threading.EventWaitHandle> с <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (включая <xref:System.Threading.ManualResetEvent>), вызов <xref:System.Threading.EventWaitHandle.Set%2A> метод оставляет дескриптор ожидания в сигнальном состоянии до ее <xref:System.Threading.EventWaitHandle.Reset%2A> вызывается метод.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> перегруженный метод, чтобы разрешить основному потоку сигнала заблокированный поток и затем подождите, пока поток завершает задачу.  
  
 В примере запускается пять потоков и позволяет им блокировать на <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> флаг, а затем времени одним потоком выпусков, пользователь нажимает клавишу ВВОД. Затем ставит в очередь другой пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle> созданные с помощью <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> флаг.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался метод <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Объект <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" />, определяющий настройки управления доступом для применения к именованному системному событию.</param>
        <summary>Задает настройки управления доступом для именованного системного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользователь должен иметь <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> права для вызова этого метода и события должен быть открыт с <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> флаг.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованное системное событие с помощью управления доступом. В примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного события.  
  
 Если событие не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает право использовать события для текущего пользователя, но не дает право на чтение и изменение разрешений события.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегруженный метод для ожидания события с помощью прав, необходимых для чтения и изменения разрешений.  
  
 После изменения разрешений, с помощью <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> метод события открыт с помощью прав, необходимых для ожидания и сигнал. При запуске скомпилированный пример в третьем окне команды в этом примере запускается с помощью новых разрешений.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventSecurity" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
-или- 
Событие не было открыто с <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Текущий объект <see cref="T:System.Threading.EventWaitHandle" /> не представляет именованное системное событие.</exception>
        <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="M:System.Threading.WaitHandle.Close" /> ранее вызывался метод <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Общие сведения о примитивах синхронизации</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
        <param name="result">При возврате этого метода содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованное событие синхронизации открылось успешно. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованное событие синхронизации не существует, этот метод не создает его. Чтобы создать системное событие, если он еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если неизвестно, существует ли именованное событие синхронизации, используйте эту перегрузку метода вместо <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> перегрузку метода, который создает исключение, если событие синхронизации не существует.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> перегрузку метода с указанием <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или. Указание <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на именованное системное событие с указанием <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A> методы.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.EventWaitHandle> объекта, несмотря на то, что объекты, возвращаемые представляют один и то же именованное системное событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного события синхронизации, которое нужно открыть.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">При возврате этого метода содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает заданное именованное событие синхронизации, если оно уже существует, с требуемыми правами доступа и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованное событие синхронизации открылось успешно. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованное событие синхронизации не существует, этот метод не создает его. Чтобы создать системное событие, если он еще не существует, используйте один из <xref:System.Threading.EventWaitHandle.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если неизвестно, существует ли именованное событие синхронизации, используйте эту перегрузку метода вместо <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> перегрузку метода, который создает исключение, если событие синхронизации не существует.  
  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания события и <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.EventWaitHandle.Set%2A> и <xref:System.Threading.EventWaitHandle.Reset%2A> методы.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.EventWaitHandle> объекта, несмотря на то, что объекты, возвращаемые представляют один и то же именованное системное событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованное событие уже существует, но пользователь не имеет требуемых прав для безопасного доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>