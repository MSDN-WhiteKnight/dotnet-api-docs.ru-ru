<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="405e3d2ae723a795a5dc6cc955e36cfb6ca813b7" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48747874" /></Metadata><TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Определяет блокировку, которая поддерживает один пишущий поток и несколько читающих.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Класс [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] использует две блокировки чтения и записи: <xref:System.Threading.ReaderWriterLockSlim> и <xref:System.Threading.ReaderWriterLock>. Мы рекомендуем применять <xref:System.Threading.ReaderWriterLockSlim> при любых новых разработках. <xref:System.Threading.ReaderWriterLockSlim> действует так же, как и <xref:System.Threading.ReaderWriterLock>, но с более простыми правилами рекурсии и изменения состояния блокировки. <xref:System.Threading.ReaderWriterLockSlim> позволяет избежать многих ситуаций взаимоблокировки. Кроме того, производительность <xref:System.Threading.ReaderWriterLockSlim> значительно выше, чем у <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> используется для синхронизации доступа к ресурсу. В любой момент времени она позволяет одновременный доступ на чтение для нескольких потоков или доступ на запись для одного потока. В ситуации, когда ресурс изменяется нечасто `ReaderWriterLock` предоставляет большую производительность, чем простой один во время блокировки, например <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock` лучше всего работает, где большинство обращений к операции чтения, случаются операций записи и с короткой продолжительностью. Несколько читающих сменяются один пишущий поток, таким образом, чтобы не заблокированы в течение длительных периодов времени.  
  
> [!NOTE]
>  Удержание блокировок чтения или блокировки записи в течение длительных периодов времени будет препятствовать работе других потоков. Для наилучшей производительности рекомендуется реструктуризации приложение, чтобы свести к минимуму продолжительность операции записи.  
  
 Поток может удерживать считывателя блокировку или блокировку записи, но не оба одновременно. Вместо снятия блокировки чтения, чтобы получить блокировку записи, вы можете использовать <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> и <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Рекурсивные запросы блокировки увеличивают счетчик блокировок данной блокировки.  
  
 Модули чтения и записи помещаются в очередь отдельно. Когда поток освобождает блокировку записи, все потоки, ожидающие в очереди модуля чтения в данный момент времени предоставляются блокировки чтения. Когда все эти блокировки были выпущены, далее ожидающих потоков в модуль записи в очередь, если имеется, предоставляется блокировка записи и так далее. Другими словами `ReaderWriterLock` переключается между коллекцию читателей и одного модуля записи.  
  
 Пока поток в очереди модуля записи ожидает снятия блокировок активный модуль чтения, потоки, запрашивающие новые блокировки чтения накапливаются в очереди модуля чтения. Их запросы не предоставляются, несмотря на то, что они могут совместно использовать параллельный доступ с существующей владельцами блокировок чтения; Это позволяет защитить записи от неопределенного читающими.  
  
 Большинство методов для получения блокировки на `ReaderWriterLock` принимают значения времени ожидания. Используйте значения времени ожидания, чтобы избежать взаимоблокировок в приложении. Например поток может получить блокировку записи для одного ресурса, а затем запросить блокировку чтения для второй ресурс; в то же время другой поток может получить блокировку записи на второй ресурс и запрос на блокировку чтения, на первой. Если не используется время ожидания, взаимоблокировка потоков.  
  
 Если истечет время ожидания и не было предоставлено запроса на блокировку, метод возвращает управление в вызывающий поток, выдав <xref:System.ApplicationException>. Поток может перехватить это исключение и определить, какое действие следует предпринять далее.  
  
 Время ожидания выражается в миллисекундах. Если вы используете <xref:System.TimeSpan?displayProperty=nameWithType> чтобы указать время ожидания, используется значение общего количества полных миллисекунд, представленного <xref:System.TimeSpan>. В следующей таблице показаны допустимые значения времени ожидания в миллисекундах.  
  
|Значение|Описание:|  
|-----------|-----------------|  
|-1|Поток ожидает получения блокировки, независимо от того, сколько времени занимает. Для методов, которые указывают параметры времени ожидания целое число, константа <xref:System.Threading.Timeout.Infinite> может использоваться.|  
|0|Поток ожидает получения блокировки. Если невозможно получить блокировку немедленно, метод возвращает.|  
|>0|Время ожидания в миллисекундах.|  
  
 За исключением -1 не допускаются отрицательные значения времени ожидания. Если указано отрицательное целое число, отличным от -1, вместо него используется значение времени ожидания, равное нулю. (То есть, метод возвращает без ожидания, если блокировка не может быть получена немедленно.) Если указать <xref:System.TimeSpan> , представляющий отрицательное число миллисекунд, отличным от -1, <xref:System.ArgumentOutOfRangeException> возникает исключение.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Threading.ReaderWriterLock> для защиты общих ресурсов, целочисленное значение с именем `resource`, то есть одновременно считываются и записываются только в рамках нескольких потоков. Обратите внимание, что <xref:System.Threading.ReaderWriterLock> объявлен на уровне класса, так как это видимым для всех потоков.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано создание нового экземпляра класса <xref:System.Threading.ReaderWriterLock>.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает блокировку чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
        <summary>Получает блокировку чтения, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> блокируется, если другой поток получает блокировку записи, или в том случае, если хотя бы один поток, ожидающий блокировки записи.  
  
> [!NOTE]
>  Если текущий поток уже имеет блокировку записи, нет блокировки чтения. Вместо этого увеличивается счетчик блокировок данной блокировки записи. Это предотвращает блокировку свой собственный модуль записи потока. Результат будет точно так же, как вызов <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>и дополнительный вызов <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> является обязательным при освобождении блокировки записи.  
  
 `AcquireReaderLock` поддерживает рекурсивные запросы на блокировку чтения. То есть поток может вызывать метод AcquireReaderLock несколько раз, который каждый раз счетчик блокировок. Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> один раз для каждый раз при вызове `AcquireReaderLock`. Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> чтобы уменьшить количество блокировок до нуля немедленно.  
  
 Рекурсивные запросы блокировок всегда выполняются немедленно, без помещения запрашивающего потока в очередь средство чтения. Используйте рекурсивные блокировки с осторожностью, чтобы избежать длительного блокирования запросов на блокировку записи.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить и освободить блокировку чтения и как обрабатывать исключение, создаваемое при истечении времени ожидания запроса.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
        <summary>Получает блокировку чтения, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> блокируется, если другой поток получает блокировку записи, или в том случае, если хотя бы один поток, ожидающий блокировки записи.  
  
> [!NOTE]
>  Если текущий поток уже имеет блокировку записи, нет блокировки чтения. Вместо этого увеличивается счетчик блокировок данной блокировки записи. Это предотвращает блокировку свой собственный модуль записи потока. Результат будет точно так же, как вызов <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>и дополнительный вызов <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> является обязательным при освобождении блокировки записи.  
  
 `AcquireReaderLock` поддерживает рекурсивные запросы на блокировку чтения. То есть поток может вызывать метод AcquireReaderLock несколько раз, который каждый раз счетчик блокировок. Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> один раз для каждый раз при вызове `AcquireReaderLock`. Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> чтобы уменьшить количество блокировок до нуля немедленно.  
  
 Рекурсивные запросы блокировок всегда выполняются немедленно, без помещения запрашивающего потока в очередь средство чтения. Используйте рекурсивные блокировки с осторожностью, чтобы избежать длительного блокирования запросов на блокировку записи.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает блокировку записи.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
        <summary>Получает блокировку записи, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется, если другой поток содержит блокировку чтения или записи. Описание способа блокировки записи чередуется с нескольких параллельных блокировки, см. в разделе <xref:System.Threading.ReaderWriterLock> класса.  
  
 Поток, который уже имеет блокировку чтения может получить блокировку записи в одном из двух способов: путем освобождения блокировки чтения до вызова метода <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, или путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Если поток вызывает `AcquireWriterLock` хотя она по-прежнему имеет блокировку чтения, он заблокирует на них отдельной блокировкой чтения; если задано бесконечное время ожидания, то поток заблокируется. Чтобы избежать такой взаимоблокировки, используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> для определения, имеет ли текущий поток уже блокировку чтения.  
  
 `AcquireWriterLock` поддерживает рекурсивные запросы блокировки записи. То есть, что поток может вызывать `AcquireWriterLock` несколько раз, который увеличивает на единицу счетчик блокировок каждый раз. Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> один раз для каждый раз при вызове `AcquireWriterLock`. Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> чтобы уменьшить количество блокировок до нуля немедленно.  
  
 Рекурсивные запросы блокировок всегда выполняются немедленно, без помещения запрашивающего потока в очереди модуля записи.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить и освободить блокировку записи и как обрабатывать исключение, создаваемое при истечении времени ожидания запроса.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
        <summary>Получает блокировку записи, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется, если другой поток содержит блокировку чтения или записи. Описание способа блокировки записи чередуется с нескольких параллельных блокировки, см. в разделе <xref:System.Threading.ReaderWriterLock> класса.  
  
 Поток, который уже имеет блокировку чтения может получить блокировку записи в одном из двух способов: путем освобождения блокировки чтения до вызова метода <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, или путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Если поток вызывает `AcquireWriterLock` хотя она по-прежнему имеет блокировку чтения, он заблокирует на них отдельной блокировкой чтения; если задано бесконечное время ожидания, то поток заблокируется. Чтобы избежать такой взаимоблокировки, используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> для определения, имеет ли текущий поток уже блокировку чтения.  
  
 `AcquireWriterLock` поддерживает рекурсивные запросы блокировки записи. То есть, что поток может вызывать `AcquireWriterLock` несколько раз, который увеличивает на единицу счетчик блокировок каждый раз. Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> один раз для каждый раз при вызове `AcquireWriterLock`. Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> чтобы уменьшить количество блокировок до нуля немедленно.  
  
 Рекурсивные запросы блокировок всегда выполняются немедленно, без помещения запрашивающего потока в очереди модуля записи.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">Порядковый номер.</param>
        <summary>Показывает, была ли предоставлена блокировка записи какому-либо потоку со времени получения последовательного номера.</summary>
        <returns>Значение <see langword="true" />, если блокировка записи была предоставлена какому-либо потоку с момента получения порядкового номера; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> и `AnyWritersSince` для повышения производительности приложения. Например поток может кэшировать данные, которые он получает при удерживании блокировки чтения. После освобождения и более поздней версии нового получения блокировки, поток может использовать `AnyWritersSince` для определения ли запись других потоков в ресурс до этого времени; если нет, можно использовать кэшированные данные. Этот метод полезен, где он считывает данные, защищенные блокировкой ресурсоемким; например выполнение запроса к базе данных.  
  
 Вызывающий объект должен удерживать блокировку чтения или записи в порядке для порядкового номера быть полезным.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> метод и <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> свойства, чтобы определить ли другой поток получить блокировку записи для защищенного ресурса с текущим потоком последнего удерживаются блокировки записи.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock :  -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Освобождает блокировку записи, независимо от числа рекурсивных запросов на блокировку и восстанавливает блокировку чтения, содержащая потоком, перед обновлением до блокировки записи. Счетчик блокировок данной блокировки чтения восстанавливается.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` принимает <xref:System.Threading.LockCookie> получен путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Не используйте `LockCookie` возвращаемый <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Поток блокируется при понижении от блокировки записи, даже если другие потоки ожидают блокировки записи, так как все запросы на блокировку чтения предоставляются при выпуске блокировкой записи.  
  
   
  
## Examples  
 В следующем примере кода показано, как запросить блокировку чтения, обновления блокировки чтения до блокировки записи и понизить до блокировки чтения еще раз.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Поток не владеет блокировкой записи.</exception>
        <exception cref="T:System.NullReferenceException">Адрес <paramref name="lockCookie" /> является пустым указателем.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает освобождение ресурсов и выполнение других завершающих операций, когда сборщик мусора восстанавливает объект <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборщик мусора вызывает <xref:System.Threading.ReaderWriterLock.Finalize%2A> при текущего <xref:System.Threading.ReaderWriterLock> объект готов к завершению.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, владеет ли текущий поток блокировкой чтения.</summary>
        <value>Значение <see langword="true" />, если текущий поток владеет блокировкой чтения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода демонстрируется использование `IsReaderLockHeld` избежание взаимоблокировок.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, владеет ли текущий поток блокировкой записи.</summary>
        <value>Значение <see langword="true" />, если текущий поток владеет блокировкой записи; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, что при попытке получить блокировку чтения в потоке, который имеет блокировку записи `ReaderWriterLock` не предоставляет блокировку чтения, но вместо этого увеличивает счетчик блокировок данной блокировки записи.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает блокировку, независимо от количества ее получений потоком.</summary>
        <returns>Объект <see cref="T:System.Threading.LockCookie" />, представляющий освобожденную блокировку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Освобождает блокировку чтения или записи, независимо от счетчика рекурсивных. Чтобы восстановить состояние блокировки, включая число блокировок, передайте <xref:System.Threading.LockCookie> для <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> метод для освобождения блокировки, независимо от того, сколько раз она была получена, поток и восстановление состояния блокировки.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает на единицу счетчик блокировок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Уменьшает счетчик блокировок. Когда счетчик достигает нуля, то блокировка снимается.  
  
> [!NOTE]
>  Если поток получает блокировку записи, при вызове метода `ReleaseReaderLock` имеет тот же эффект, что и вызов метода <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Если поток не имеет блокировок, вызов метода `ReleaseReaderLock` вызывает <xref:System.ApplicationException>.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить и освободить блокировку чтения и как обрабатывать исключение, создаваемое при истечении времени ожидания запроса.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Поток не владеет блокировкой чтения или записи.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает на единицу счетчик блокировок данной блокировки записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> уменьшает счетчик блокировки модуля записи. Когда счетчик достигает нуля, снятия блокировки модуля записи.  
  
> [!NOTE]
>  Если поток имеет блокировку чтения, или отсутствует, вызов метода `ReleaseWriterLock` вызывает <xref:System.ApplicationException>.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить и освободить блокировку записи и как обрабатывать исключение, создаваемое при истечении времени ожидания запроса.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Поток не владеет блокировкой записи.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock :  -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние, восстановить, `RestoreLock` включает счетчик блокировок рекурсивной.  
  
 Поток блокируется, если он пытается восстановить блокировку чтения после другой поток получил блокировку записи, или если он пытается восстановить блокировку записи после другой поток получил блокировку чтения или записи. Так как `RestoreLock` не принимает тайм-аут, следует позаботиться для избежания взаимоблокировок.  
  
> [!CAUTION]
>  Перед вызовом `RestoreLock`, убедитесь, что вы выпустили все блокировки, полученные после вызова <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Например поток взаимоблокировки, если он получает блокировку чтения, а затем пытается восстановить прежнюю блокировку записи. Используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> и <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> для обнаружения подобных блокировок.  
  
 Не используйте <xref:System.Threading.LockCookie> возвращаемые <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> метод для освобождения блокировки, независимо от того, сколько раз она была получена, поток и восстановление состояния блокировки.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Адрес <paramref name="lockCookie" /> является пустым указателем.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Повышает уровень блокировки чтения до блокировки записи.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах.</param>
        <summary>Повышает уровень блокировки чтения до блокировки записи, используя значение <see langword="Int32" /> для задания времени ожидания.</summary>
        <returns>Значение <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток вызывает `UpgradeToWriterLock` снятия блокировки чтения, независимо от того, количество блокировок, и поток помещается в конец очереди блокировки записи. Таким образом другие потоки могут писать в ресурс, прежде чем поток, который запросил обновление будет предоставлена блокировка записи.  
  
> [!IMPORTANT]
>  Исключение не создается до потоке, который вызвал <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод можно повторить запрос блокировки чтения. Если нет других потоков, ожидающих блокировки записи, это происходит немедленно. Тем не менее, если другой поток помещается в очередь блокировки записи, поток, вызвавший <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод не сможет повторно получить блокировку чтения, пока все текущего средства чтения освободят свои блокировки, и один поток получит и освободит блокировку записи. Это справедливо, даже если другой поток, запросившего блокировку записи требуется после вызова текущего потока <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод.  
  
 Чтобы восстановить состояние блокировки, вызовите <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> с помощью <xref:System.Threading.LockCookie> возвращаемый `UpgradeToWriterLock`. Не используйте этот `LockCookie` с <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Если поток имеет блокировка чтения, не используйте `UpgradeToWriterLock`. Взамен рекомендуется использовать <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 В следующем примере кода показано, как запросить блокировку чтения, обновления блокировки чтения до блокировки записи и понизить до блокировки чтения еще раз.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see langword="TimeSpan" />, задающий время ожидания.</param>
        <summary>Повышает уровень блокировки чтения до блокировки записи, используя значение <see langword="TimeSpan" /> для задания времени ожидания.</summary>
        <returns>Значение <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток вызывает `UpgradeToWriterLock` снятия блокировки чтения, независимо от того, количество блокировок, и поток помещается в конец очереди блокировки записи. Таким образом другие потоки могут писать в ресурс, прежде чем поток, который запросил обновление будет предоставлена блокировка записи.  
  
> [!IMPORTANT]
>  Исключение не создается до потоке, который вызвал <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод можно повторить запрос блокировки чтения. Если нет других потоков, ожидающих блокировки записи, это происходит немедленно. Тем не менее, если другой поток помещается в очередь блокировки записи, поток, вызвавший <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод не сможет повторно получить блокировку чтения, пока все текущего средства чтения освободят свои блокировки, и один поток получит и освободит блокировку записи. Это справедливо, даже если другой поток, запросившего блокировку записи требуется после вызова текущего потока <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> метод.  
  
 Чтобы восстановить состояние блокировки, вызовите <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> с помощью <xref:System.Threading.LockCookie> возвращаемый `UpgradeToWriterLock`. Не используйте этот `LockCookie` с <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Если поток имеет блокировка чтения, не используйте `UpgradeToWriterLock`. Взамен рекомендуется использовать <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Допустимые значения времени ожидания, см. в разделе <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий последовательный номер.</summary>
        <value>Текущий последовательный номер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядковый номер увеличивается каждый раз, когда поток получает блокировку записи. Можно сохранить порядковый номер и передать его в <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> позже, если вы хотите определить ли другие потоки получена блокировка записи в то же время.  
  
 Можно использовать `WriterSeqNum` для повышения производительности приложения. Например поток может кэшировать данные, которые он получает при удерживании блокировки чтения. После освобождения и более поздней версии нового получения блокировки, поток может определить ли запись других потоков к ресурсу, вызвав `AnyWritersSince`; Если нет, можно использовать кэшированные данные. Этот метод полезен при чтении сведений, защищенные блокировкой ресурсоемким; например выполнение запроса к базе данных.  
  
 Вызывающий объект должен удерживать блокировку чтения или записи в порядке для порядкового номера быть полезным.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> свойство и <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> метод для определения ли другой поток получить блокировку записи для защищенного ресурса с текущим потоком последнего удерживаются блокировки записи.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLock> класса.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md">ReaderWriterLock</related>
      </Docs>
    </Member>
  </Members>
</Type>