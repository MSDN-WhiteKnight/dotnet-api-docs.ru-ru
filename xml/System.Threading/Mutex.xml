<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="30925d1ed481842882180e068760ea83b7059bc8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57920473" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Примитив синхронизации, который также может использоваться в межпроцессорной синхронизации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда два или больше потоков требуется доступ к общему ресурсу одновременно, системе необходим механизм синхронизации, чтобы убедиться, что только один поток за раз использует ресурс. <xref:System.Threading.Mutex> — Это синхронизации примитив, который предоставляет эксклюзивный доступ к общему ресурсу, чтобы только один поток. Если поток получает семафор, второй поток, желающий получить этот мьютекс приостанавливается, пока первый поток освобождает мьютекс.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 Можно использовать <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод, который запросит владение мьютексом. Вызывающий поток блокируется, пока не произойдет одно из следующих событий:  
  
-   Чтобы указать, что он не принадлежит получает сигнал мьютекса. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true`, и вызывающий поток принимает на себя владение мьютексом и получает доступ к ресурсу, защищенные объектом mutex. После завершения доступ к ресурсу, поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения мьютексом. В первом примере в разделе «примеры» показан этот шаблон.  
  
-   Интервал времени ожидания, указанное в вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метод, который имеет `millisecondsTimeout` или `timeout` параметре. В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `false`, и вызывающий поток не предпринимает дальнейших получить права владельца мьютекса. В этом случае следует структурировать код таким образом, чтобы доступ к ресурсу, защищенные объектом mutex запрещен в вызывающий поток. Так как поток никогда не получить права владельца мьютекса, он не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. В разделе «примеры» во втором примере показана схема работы.  
  
 <xref:System.Threading.Mutex> Класс выполняет идентификацию потоков, поэтому мьютекс может быть освобожден только тем потоком, который получил его. Напротив <xref:System.Threading.Semaphore> класса не обеспечивают идентификацию потоков. Мьютекс также могут передаваться через границы домена приложения.  
  
 Поток, который владеет мьютекс может запросить его в повторные вызовы <xref:System.Threading.WaitHandle.WaitOne%2A> не прерывая выполнение. Тем не менее, необходимо вызвать поток <xref:System.Threading.Mutex.ReleaseMutex%2A> метод такое же количество раз, чтобы освободить права владения мьютексом.  
  
 Так как <xref:System.Threading.Mutex> класс наследует от <xref:System.Threading.WaitHandle>, также можно вызвать статический <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы для синхронизации доступа к защищенному ресурсу.  
  
 Если поток завершается владея мьютексом, мьютекс считается брошенным. Состояние мьютекса задается сигнальным и получает следующий ожидающий поток. Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который получает Брошенный мьютекс. До версии 2.0 платформы .NET Framework исключение не создано.  
  
> [!CAUTION]
>  Брошенный мьютекс часто является признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии. Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
 Мьютексы бывают двух типов: локальные мьютексы неименованные и именованные системные мьютексы. Локальный мьютекс существует только в вашем процессе. Он может использоваться любой поток в вашем процессе, имеющий ссылку на <xref:System.Threading.Mutex> объект, представляющий мьютекс. Каждый неименованный <xref:System.Threading.Mutex> объект представляет собой отдельный Локальный мьютекс.  
  
 Именованные системные мьютексы доступны во всей операционной системы и может использоваться для синхронизации действий процессов. Можно создать <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс с помощью конструктора, который принимает имя. Объект операционной системы может быть создан в то же время, или он может существовать до создания <xref:System.Threading.Mutex> объекта. Вы можете создать сразу несколько объектов <xref:System.Threading.Mutex>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <xref:System.Threading.Mutex.OpenExisting%2A>.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 В этом примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поскольку каждый вызывающий поток блокируется, пока не получит права владельца мьютекса, он должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения потока.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 В следующем примере каждый поток вызывает <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> способ занять объект взаимного исключения. Если по истечении интервала времени ожидания, метод возвращает `false`, и поток не завладеет этим мьютексом и не получает доступ к ресурсу, позволяет защитить мьютексом. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод вызывается только тем потоком, который получает мьютекс.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> стандартными свойствами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого перегруженного конструктора — равносилен вызову метода <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> перегрузку конструктора и указав `false` для изначальным владельцем мьютекса. То есть вызывающий поток не имеет собственного мьютекса.  
  
   
  
## Examples  
 В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютексом не владеет его изначально.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, является ли вызывающий поток изначальным владельцем мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий <xref:System.Threading.Mutex> изначально им владеет.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> с логическим значением, показывающим необходимость наличия начального владения семафором у вызывающего потока, и строкой, являющейся именем семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` является `true`, вызывающий поток является владельцем мьютекса только в том случае, если именованный системный мьютекс был создан в результате этого вызова. Так как отсутствует механизм для определения, был ли создан именованный системный мьютекс, рекомендуется указать `false` для `initiallyOwned` при вызове перегрузки конструктора. Можно использовать <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> конструктор, если вам нужно определить изначальным владельцем.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Следующий пример показывает использование именованного мьютекса для передачи сигналов между потоками, выполняющимися в два отдельных процесса.  
  
 Запустите эту программу из двух или нескольких команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс `MyMutex`. Именованный мьютекс является системным объектом, время существования которых ограничивается временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается в том случае, когда первый процесс создает его <xref:System.Threading.Mutex> объект; в этом примере мьютексом владеет первый процесс, выполняющий программу. Именованный мьютекс уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены.  
  
 Перегрузку конструктора, используемый в этом примере не может определить вызывающий поток, предоставлен ли изначальное владение мьютексом. Этот конструктор не следует использовать для запроса изначальным владельцем, если только вы можете быть уверены, что поток будет создавать именованный мьютекс.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода. В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> прав, возникает исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 В следующем примере кода показано использование именованного мьютекса для сигнала между потоками или процессами. Запустите эту программу из двух или нескольких команд windows. Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс «MyMutex». Именованный мьютекс является системным объектом. В этом примере его время жизни ограничено временем жизни <xref:System.Threading.Mutex> объекты, представляющие его. Именованный мьютекс создается в том случае, когда первый процесс создает ее локальных <xref:System.Threading.Mutex> объекта и уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены. Именованный мьютекс изначально принадлежит первый процесс. Второй и все последующие процессы ожидания для более ранних процессов для освобождения именованного мьютекса.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя системного мьютекса. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом, а также безопасность управления доступом для применения к именованному мьютексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода. В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор используется для применения управления доступом к именованному системному мьютексу при его создании, чтобы предотвратить возможность управления мьютексом другой код.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс. Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.  
  
 Если именованный системный мьютекс не существует, он создается с указанного элемента управления доступом. Если именованный мьютекс существует, указанный управления доступом учитывается.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над только что созданный <xref:System.Threading.Mutex> объект, даже если `mutexSecurity` запрещает или не удалось предоставить некоторые права доступа для текущего пользователя. Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Mutex> объекта представляют одинаковую меру с именем мьютекса, с помощью конструктора или <xref:System.Threading.Mutex.OpenExisting%2A> метод применения управления доступом Windows.  
  
 Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение. Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.  
  
 Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор. В этом случае `createdNew` всегда `true`.  
  
 Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.  
  
> [!NOTE]
>  На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан. В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем. Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«. В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов. То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> Методе используется комбинация флагов (в сочетании с помощью побитовой операции OR) для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
-или- 
Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но он не был открыт с правами <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть указанный именованный системный мьютекс. Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.  
  
 Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не требует владения мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть существующий именованный мьютекс. Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не требует владения мьютексом.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет необходимой безопасности доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый раз, когда поток получает семафор (например, путем вызова его <xref:System.Threading.WaitHandle.WaitOne%2A> метод), он должен впоследствии вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> передать владение мьютексом и разблокировать другие потоки, которые пытаются получить права владельца мьютекса. Если произошел сбой попытки получить права владельца мьютекса (например, когда вызов <xref:System.Threading.WaitHandle.WaitOne%2A> метод с `millisecondsTimeout` или `timeout` параметр возвращает `false` из-за тайм-аута запроса), поток не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A>, в этом регистр, поток также не должны получить доступ к ресурсу, защищенные объектом mutex, как показано в следующем примере.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Поток, который является владельцем мьютекса можно указать его в повторных вызовах функции ожидания, не прерывая выполнение. Число вызовов хранится в среде CLR. Поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> такое же количество раз, чтобы освободить права владения мьютексом.  
  
 Если поток завершается владея мьютексом, мьютекс считается брошенным. Состояние мьютекса задается сигнальным, и получает следующий ожидающий поток. Если никто не является владельцем мьютекса, состояние мьютекса переводится в сигнальное состояние. Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который завладеет этим мьютексом. До версии 2.0 платформы .NET Framework исключение не создано.  
  
> [!CAUTION]
>  Брошенный мьютекс часто является признаком серьезной ошибки в коде. Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии. Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
   
  
## Examples  
 В следующем примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютексом не владеет его изначально. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод позволяет освободить мьютекс, когда он больше не нужен.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Вызывающий поток не является владельцем мьютекса.</exception>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Задает безопасность управления доступом для именованного системного мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> права для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом. В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.  
  
 Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.  
  
 Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.  
  
 После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его. При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
-или- 
Мьютекс не был открыт с <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Текущий объект <see cref="T:System.Threading.Mutex" /> не представляет именованный системный мьютекс.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузку метода, который создает исключение, если мьютекс не существует.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или. Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Этот метод не требует владения мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс существует, этот метод не создает его. Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.  
  
 Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода, который создает исключение, если мьютекс не существует.  
  
 `rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.  
  
 Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не требует владения мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
-или- 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>