<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e65fca211a4a1f4c9c921a6969f03a8fa5bc029a" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58685413" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет класс обертки для дескрипторов операционной системы. Этот класс должен наследоваться.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle> Класс предоставляет критическое завершение для ресурсов дескрипторов, предотвращая дескрипторы преждевременное при сборке мусора освобождение и уничтожение по Windows для ссылки на непредусмотренные неуправляемые объекты.  
  
 Этот раздел включает следующие подразделы:  
  
 [Почему SafeHandle?](#Why)   
 [Что делает класс SafeHandle](#Does)   
 [Классы, производные от SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Почему SafeHandle?  
 До .NET Framework версии 2.0 все операционной системы, обрабатывает только может быть инкапсулирована в <xref:System.IntPtr> управляемую оболочку объекта. При это удобный способ взаимодействия с машинным кодом, возможна утечка дескрипторов за асинхронных исключений, например неожиданного прерывания потока или переполнение стека. Эти асинхронные исключения, являющиеся препятствием для очистки ресурсов операционной системы, и они должны происходить практически везде, где в приложении.  
  
 Несмотря на то что для переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод разрешить очистки неуправляемых ресурсов, если объект процесса сбора мусора, в некоторых случаях, Завершаемые объекты могут быть удалены сборщиком мусора во время выполнения метода в вызов Ошибка при вызове. Если метод завершения освобождает дескриптор, переданный вызову неуправляемого кода, это может привести к повреждению дескриптора. Также можно освободить дескриптор, пока ваш метод заблокирован во время вызова неуправляемого кода, например, при чтении файла.  
  
 Более важно так как Windows агрессивно удаляет дескрипторы, дескриптор может повторно использовать и указывать на другой ресурс, могут содержать конфиденциальные данные. Это называется атака путем повторного использования и могут привести к повреждению данных и представлять угрозу безопасности.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Что делает класс SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> Класс упрощает несколько эти проблемы времени существования объекта и интегрирована с платформой вызова, чтобы не утечки ресурсов операционной системы. <xref:System.Runtime.InteropServices.SafeHandle> Класс разрешает проблемы времени существования объекта, назначая и освобождая дескрипторы без прерываний. Он содержит критический метод завершения, который гарантирует, что дескриптор закрывается и обязательно выполняется во время Непредвиденная <xref:System.AppDomain> выгрузки, даже в случаях, когда вызова платформы предполагается, что в поврежденном состоянии.  
  
 Так как <xref:System.Runtime.InteropServices.SafeHandle> наследует от <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, все некритические методы завершения вызываются перед критическими. Методы Finalizer вызываются для объектов, которые больше не динамической во время прохода же сбора мусора. Например <xref:System.IO.FileStream> объект можно запустить обычный метод завершения, чтобы сбросить существующие буферизованные данные без риска утечки или уничтожен. Это очень слабое упорядочение критических и некритических методов завершения не предназначен для общего использования. Он существует, главным образом, чтобы помочь в процессе переноса существующих библиотек, позволяя этим библиотекам использовать <xref:System.Runtime.InteropServices.SafeHandle> без изменения их семантики. Кроме того, критический метод завершения и все, что она вызывает, такие как <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> метод, должен быть в области ограниченного выполнения. Это накладывает ограничения на какой код могут записываться в графе вызовов метода завершения.  
  
 Операции вызова неуправляемого автоматически приращение счетчика ссылок дескрипторов, инкапсулированных в <xref:System.Runtime.InteropServices.SafeHandle> и уменьшения их после завершения. Это гарантирует, что дескриптор не будет уничтожен или было неожиданно закрыто.  
  
 Владение базовый дескриптор можно указать при создании <xref:System.Runtime.InteropServices.SafeHandle> объектов путем указания значения для `ownsHandle` аргумента в <xref:System.Runtime.InteropServices.SafeHandle> конструктора класса. Этот параметр управляет ли <xref:System.Runtime.InteropServices.SafeHandle> объекта будет освобождать этот дескриптор, после удаления объекта.  Это полезно для дескрипторов требованиям необычное время существования или для использования дескриптора, время существования которых управляется другим пользователем.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Классы, производные от SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> является абстрактным классом-оболочкой для дескрипторов операционной системы. Наследовать от этого класса сложно. Вместо этого используйте производные классы в пространстве имен <xref:Microsoft.Win32.SafeHandles>, которые предоставляют безопасные дескрипторы для следующих элементов.  
  
-   Файлы ( <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> класса).  
  
-   Файлы распределения памяти ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> класса).  
  
-   Каналы ( <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> класса).  
  
-   Представления в памяти ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> класса).  
  
-   Конструкции шифрования ( <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> классы).  
  
-   Процессы ( <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> класса).  
  
-   Разделы реестра ( <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> класса).  
  
-   Дескрипторы ожидания ( <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> класса).  
  
   
  
## Examples  
 В следующем примере кода создается пользовательский безопасный дескриптор для дескриптор файла операционной системы, производное от <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Считывает байт из файла и выводятся их шестнадцатеричные значения. Он также содержит средство проверки отказов, приводит к прерыванию потока, но значение дескриптора освобождается.  При использовании <xref:System.IntPtr> для представления дескрипторов, дескриптор иногда происходит утечка из-за асинхронного прерывания потока.  
  
 Вам потребуется в текстовый файл в той же папке, что скомпилированное приложение. Предположим, что в качестве имени приложения «HexViewer», является использование командной строки:  
  
 `HexViewer <filename> -Fault`  
  
 При необходимости укажите `-Fault` чтобы намеренно попытаться вызвать утечку дескриптор путем прерывания потока в конкретном окне. Используйте средство Windows Perfmon.exe для отслеживания количества дескриптора во время внесения ошибок.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться кодом с частичным доверием.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
    <block subset="none" type="overrides"><para>Чтобы создать класс, производный от <see cref="T:System.Runtime.InteropServices.SafeHandle" />, необходимо знать, как создать и освободить дескриптор операционной системы. Этот процесс отличается для разных дескриптор типов, так как некоторые используют [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) функции, другие используют более конкретные функции, такие как [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) или [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). По этой причине необходимо создать класс, производный от <see cref="T:System.Runtime.InteropServices.SafeHandle" /> для каждого типа дескриптора операционной системы, которую необходимо включить в безопасном дескрипторе.  
  
При наследовании от класса <see cref="T:System.Runtime.InteropServices.SafeHandle" /> необходимо переопределить следующие члены: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> и <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
Вы также должны предоставить конструктор по умолчанию, который вызывает базовый конструктор со значением, которое представляет недопустимое значение дескриптора, и <see cref="T:System.Boolean" /> значение, указывающее, принадлежит ли собственный дескриптор <see cref="T:System.Runtime.InteropServices.SafeHandle" /> и поэтому должен быть освобожден при <see cref="T:System.Runtime.InteropServices.SafeHandle" /> был удален.</para></block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Значение недопустимого дескриптора (обычно 0 или -1).  Реализация <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> должна возвращать <see langword="true" /> для этого значения.</param>
        <param name="ownsHandle">Значение <see langword="true" />, чтобы наверняка позволить <see cref="T:System.Runtime.InteropServices.SafeHandle" /> освободить дескриптор на стадии завершения; в противном случае — значение <see langword="false" /> (не рекомендуется).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.InteropServices.SafeHandle" /> с заданным значением недопустимого дескриптора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `ownsHandle` параметр `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> никогда не вызывается; таким образом, не рекомендуется использовать значение этого параметра, как ваш код может вызвать утечку ресурсов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">Производный класс находится в сборке без разрешения на доступ к неуправляемому коду.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться кодом с частичным доверием.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помечает дескриптор для освобождения самого дескриптора и соответствующих ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод позволяет освобождения ресурсов. Это может происходить не сразу, если другие потоки используют один и тот же объект безопасный дескриптор, но будет происходить, как только это не так. Несмотря на то, что большинство классов, которые используют <xref:System.Runtime.InteropServices.SafeHandle> класс не нужно предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память). В этом случае класс может предоставить метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.SafeHandle> запусков критический метод завершения.  
  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод, когда вы закончите с помощью <xref:System.Runtime.InteropServices.SafeHandle> объекта.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.SafeHandle> объекта. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.SafeHandle> метод <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">Значение <see langword="true" />, если счетчик ссылок был успешно увеличен; в противном случае — значение <see langword="false" />.</param>
        <summary>Вручную увеличивает счетчик ссылок для экземпляров <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Метод помешает среда CLR освобождать память, занятая дескриптор (которая возникает, когда среда выполнения вызывает <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> метод). Можно использовать этот метод увеличите вручную, счетчик ссылок для <xref:System.Runtime.InteropServices.SafeHandle> экземпляра. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Возвращает логическое значение, используя `ref` параметра (`success`), указывает ли счетчик ссылок был успешно увеличен. Это позволяет выполнить откат в случае сбоя в логике программы. Необходимо задать `success` для `false` перед вызовом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Если `success` — `true`, предотвращение утечек ресурсов, сопоставляя вызов <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> с соответствующим вызовом метода <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Этот метод предназначен для опытных пользователей и всегда следует использовать осторожно. Во избежание утечки ресурсов, следует всегда вызывайте этот метод внутри области ограниченного выполнения (CER), где прерывание потока не может прервать обработку.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение поля <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>Указатель <see langword="IntPtr" />, представляющий значение поля <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Если дескриптор был помечен как неправильный с помощью <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, этот метод, тем не менее, возвращает исходное значение дескриптора, которое может быть устаревшим.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для получения значения фактический маркер из экземпляра <xref:System.Runtime.InteropServices.SafeHandle> производного класса. Этот метод является необходимым для обратной совместимости, так как многие свойства в .NET Framework возвращают `IntPtr` обработки типов. `IntPtr` типы дескрипторов, типы платформы, используемые для представления указателя или дескриптора.  
  
> [!CAUTION]
>  С помощью <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> метод может представлять угрозу безопасности, поскольку, если дескриптор был помечен как недопустимый с <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> по-прежнему возвращает значение исходного, потенциально устаревший дескриптора. Возвращенный дескриптор может быть также очищен в любой момент. В лучшем случае это означает, что дескриптор может неожиданно прекратить работу. В худшем случае если дескриптор или ресурс, который представляет дескриптор предоставляется ненадежного кода, это может привести к нарушению безопасности, при повторном использовании или возвращаемый дескриптор. К примеру ненадежный вызывающий объект может запрашивать данные с дескриптором просто возвращается и получать сведения для полностью несвязанного ресурса. См. в разделе <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> и <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Дополнительные сведения об использовании <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вручную уменьшает счетчик ссылок для экземпляра <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Метод является аналогом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Всегда должна соответствовать вызов <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> метод с успешным вызовом <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Этот метод предназначен для опытных пользователей и всегда следует использовать осторожно. Во избежание утечки ресурсов, следует всегда вызывайте этот метод внутри области ограниченного выполнения (CER), где прерывание потока не может прервать обработку. В том же способом, то несопоставленные <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> вызовов может вызвать утечку ресурсов, несовпадающие <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> вызовов может привести к недопустимым дескриптором состояния становятся видимыми для других потоков. Не предоставляйте <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> или <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> вызовы ненадежного кода.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождение ресурсов, используемых классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод позволяет освобождения ресурсов. Это может происходить не сразу, если другие потоки используют один и тот же экземпляр безопасный дескриптор, но будет происходить, как только это не так. Несмотря на то что наиболее классов, использующих <xref:System.Runtime.InteropServices.SafeHandle> не нужно предоставлять метод завершения, иногда это необходимо (например, чтобы очистить буферы файлов или записать некоторые данные обратно в память). В этом случае они предоставляют метод завершения, который обязательно выполняется перед <xref:System.Runtime.InteropServices.SafeHandle> запусков критический метод завершения.  
  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод, когда вы закончите с помощью <xref:System.Runtime.InteropServices.SafeHandle> объекта. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Метода <xref:System.Runtime.InteropServices.SafeHandle> объекта окажется в неработоспособном состоянии.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод перед освобождением последней ссылки на <xref:System.Runtime.InteropServices.SafeHandle> объекта. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Runtime.InteropServices.SafeHandle> метод <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> для обычной операции удаления и значение <see langword="false" /> для завершения работы с дескриптором.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.Runtime.InteropServices.SafeHandle" />, определяя, нужно ли выполнять обычную операцию удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует явно вызывать <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> метод с `disposing` параметру присвоить `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с дескриптором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> Метод является деструктор для <xref:System.Runtime.InteropServices.SafeHandle> класса. Код приложения не следует вызывать этот метод напрямую.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет инкапсулируемый дескриптор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не предоставляйте дескриптор публично (то есть за пределами производного класса).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, является ли дескриптор закрытым.</summary>
        <value>Значение <see langword="true" />, если дескриптор закрыт, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Метод возвращает значение, указывающее, является ли <xref:System.Runtime.InteropServices.SafeHandle> дескриптора объекта больше не связан с машинным ресурсом. Это отличается от определения <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство, которое вычисляет ли заданный дескриптор всегда считается недопустимым. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Возвращает `true` значение в следующих случаях:  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> Был вызван метод.  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Метод или <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> метод был вызван и нет ссылок, чтобы <xref:System.Runtime.InteropServices.SafeHandle> объекта в других потоках.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, показывающее, допустимо ли значение дескриптора.</summary>
        <value>Значение <see langword="true" />, если значение дескриптора является неправильным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы должны реализовывать <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство, чтобы среда CLR может определить, необходим ли критическое завершение. Производные классы должны предоставлять реализацию, которая соответствует общий тип дескриптора, они поддерживают (0 или -1 является недопустимым). Эти классы могут быть дополнительными производными для конкретных типов безопасных дескрипторов.  
  
 В отличие от <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> свойство, которое сообщает ли <xref:System.Runtime.InteropServices.SafeHandle> объекта закончит базовый дескриптор <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство вычисляет, является ли значение заданного дескриптора всегда считается недопустимым. Таким образом <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство всегда возвращает значение для любого значения одного дескриптора.  
  
   
  
## Examples  
 В следующем примере проверяется, если файл был успешно открыт. Данный пример кода является частью большего примера для <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе выполняет код, необходимый для освобождения дескриптора.</summary>
        <returns>Значение <see langword="true" />, если дескриптор освобождается успешно; в противном случае при катастрофическом сбое — значение <see langword="false" />. В таком случае создается управляемый помощник по отладке <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Метод гарантированно вызываться только один раз и только если маркер является допустимым в соответствии с определением <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> свойство. Реализация этого метода в вашей <xref:System.Runtime.InteropServices.SafeHandle> производные классы для выполнения любого кода, который необходим для освобождения дескриптора. Так как одна из функций <xref:System.Runtime.InteropServices.SafeHandle> — обеспечение защиты от утечки ресурсов, код в реализации <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> никогда не должна завершиться ошибкой. Сборщик мусора вызывает <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> после выполнения обычных методов завершения для объектов, которые были собраны в то же время сборки мусора. Сборщик мусора гарантирует, что ресурсы, чтобы вызвать этот метод и что метод не будет прерван во время его уже выполняется. Этот метод будет подготовлен как область с ограничением исполнения (CER) во время создания экземпляра (а также все методы в его статически определимый граф вызова). Несмотря на то, что это предотвращает прерывание прерывания потока, необходимо по-прежнему быть не следует вводить все пути ошибок в переопределенный <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> метод. В частности, применение <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> атрибут любые методы, вызов из <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. В большинстве случаев этот код должен быть:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Кроме того, для простой очистки (например, вызов Win32 API `CloseHandle` на дескриптор файла) можно проверить возвращаемое значение для вызова одной платформы. Для сложных очистки может иметь много логики программы и количестве вызовов, некоторые из которых может завершиться ошибкой. Необходимо убедиться, что логику программы имеет код отката для каждого из таких случаев.  
  
 Если <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> возвращает `false` по любой причине, он создает [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) управляемый помощник по отладке.  Это поможет вам обнаружить ситуации, в которых происходит сбой попытку освободить ресурсы.  
  
   
  
## Examples  
 В следующем примере кода, освобождает дескриптор и является частью большего примера для <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c">Диагностика ошибок времени выполнения с помощью управляемых помощников по отладке</related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51">releaseHandleFailed</related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ранее существующий дескриптор для использования.</param>
        <summary>Определяет дескриптор для заданного ранее существующего дескриптора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> метод только в том случае, если необходима поддержка ранее существующий дескриптор (например, если дескриптор возвращается в виде структуры), поскольку взаимодействия инфраструктуры .NET Framework COM не поддерживает маршалинг вывода дескрипторов в структуре.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помечает дескриптор, как больше не используемый.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> метод только в том случае, если известно, что маркер больше не ссылается на ресурс. Таким образом не изменяет значение <xref:System.Runtime.InteropServices.SafeHandle.handle> поле; он только Помечает дескриптор как закрытые. Дескриптор может содержать потенциально устаревшее значение. Этот вызов действует так что не предпринимается попытка освобождения ресурсов.  
  
 Как и в <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> используйте <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> только в том случае, если необходима поддержка ранее существующий дескриптор.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>