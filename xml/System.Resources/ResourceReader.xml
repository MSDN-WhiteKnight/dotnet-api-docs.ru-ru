<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cf7a67a258c9d35bde90d29a438b1379dff2335c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58691141" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Перечисляет ресурсы в двоичном файле ресурсов (RESOURCES) путем последовательного считывания пар "ключ-значение" ресурсов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceReader> Класс предоставляет стандартную реализацию <xref:System.Resources.IResourceReader> интерфейс. Объект <xref:System.Resources.ResourceReader> экземпляр представляет автономный RESOURCES-файла или файла .resources, внедренного в сборку. Он позволяет перечислить ресурсы в RESOURCES-файла и извлечь его пары "имя значение". Он отличается от <xref:System.Resources.ResourceManager> класс, который используется для получения указанных именованных ресурсов из RESOURCES-файла, внедренного в сборку. <xref:System.Resources.ResourceManager> Класс используется для извлечения ресурсов, имена которых известны заранее, тогда как <xref:System.Resources.ResourceReader> класс полезен для извлечения ресурсов, которого номер или точные имена не известны во время компиляции. Например приложение может использовать файл ресурсов для хранения сведений о конфигурации, организованных в разделах и элементов в разделе, когда количество разделов или элементов в разделе, не известен заранее. Ресурсы могут называться затем универсально (такие как `Section1`, `Section1Item1`, `Section1Item2`, и так далее) и получать с помощью <xref:System.Resources.ResourceReader> объекта.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 Дополнительные сведения об использовании <xref:System.Resources.ResourceReader> класса, в следующих разделах:  
  
-   [Создание экземпляра объекта ResourceReader](#instantiate)  
  
-   [Перечисление ресурсов объект ResourceReader](#enumerate)  
  
    -   [Извлечение ресурсов с помощью свойства IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Извлечение ресурсов по имени с GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Создание экземпляра объекта ResourceReader  
 RESOURCES-файл является двоичным файлом, который был скомпилирован из текстового файла или XML-файл .resx с [Resgen.exe (генератор файлов ресурсов)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Объект <xref:System.Resources.ResourceReader> объект может представлять отдельном Resources-файле или в RESOURCES-файл, встроенный в сборку.  
  
 Для создания экземпляра <xref:System.Resources.ResourceReader> который операции чтения из автономного RESOURCES-файл, использовать <xref:System.Resources.ResourceReader> конструктора класса входного потока или строка, содержащая имя файла .resources. В следующем примере оба подхода. Создает экземпляр первый <xref:System.Resources.ResourceReader> , представляющий RESOURCES-файл с именем `Resources1.resources` с помощью имени файла. Создает второй <xref:System.Resources.ResourceReader> , представляющий RESOURCES-файл с именем `Resources2.resources` с помощью потока, созданного из файла.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Чтобы создать <xref:System.Resources.ResourceReader> , представляющий внедренный RESOURCES-файл, создать экземпляр <xref:System.Reflection.Assembly> объекта из сборки, в который внедрены RESOURCES-файл. Его <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> возвращает <xref:System.IO.Stream> объект, который может быть передан в <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор. В следующем примере создается <xref:System.Resources.ResourceReader> , представляющий внедренный RESOURCES-файл.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Перечисление ресурсов объект ResourceReader  
 Чтобы перечислить ресурсы в RESOURCES-файл, вызовите <xref:System.Resources.ResourceReader.GetEnumerator%2A> метод, возвращающий <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> объекта. Вы вызываете `IDictionaryEnumerator.MoveNext` метод для перехода из одного ресурса к другому. Этот метод возвращает `false` при были перечислены все ресурсы в RESOURCES-файл.  
  
> [!NOTE]
>  Несмотря на то что <xref:System.Resources.ResourceReader> класс реализует <xref:System.Collections.IEnumerable> интерфейс и <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> метод, <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> метод не предоставляет <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> реализации. Вместо этого <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> возвращает метод <xref:System.Collections.IDictionaryEnumerator> объект интерфейса, который предоставляет доступ к паре имя значение для каждого ресурса.  
  
 Можно получить отдельные ресурсы коллекции одним из двух способов:  
  
-   Можно выполнить итерацию каждого ресурса в <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> сбора и использования <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> свойств для извлечения ресурсов имя и значение. Этот способ рекомендуется использовать, если все ресурсы имеют тот же тип, или вы знаете тип данных каждого ресурса.  
  
-   Имя каждого ресурса можно получить при прохождении <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> коллекции и вызвать <xref:System.Resources.ResourceReader.GetResourceData%2A> метод для извлечения данных ресурса. Мы рекомендуем этот подход, если вы не знаете тип данных каждого ресурса, или если предыдущий подход будет вызвано исключение.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Извлечение ресурсов с помощью свойства IDictionaryEnumerator  
 Первый метод перечисления ресурсы в RESOURCES-файл включает в себя напрямую извлечение пары имя значение для каждого ресурса. После вызова метода `IDictionaryEnumerator.MoveNext` имя метода для перемещения для каждого ресурса в коллекции, можно извлечь ресурс из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойства и данные ресурсов из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойство.  
  
 В следующем примере показано, как получить имя и значение каждого ресурса в RESOURCES-файл с помощью <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> и <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства. Для выполнения этого примера, создайте текстовый файл с именем ApplicationResources.txt для определения строковые ресурсы.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Затем можно преобразовать текстовый файл ресурсов в двоичный файл с именем ApplicationResources.resources, используя следующую команду:  
  
 **resgen ApplicationResources.txt**  
  
 В следующем примере затем используется <xref:System.Resources.ResourceReader> класс перечислить каждый ресурс в двоичный RESOURCES-файл автономных и для отображения имени ключа и соответствующее значение.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Попытка получить данные ресурсов из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойство можно вызывать следующие исключения:  
  
-   Объект <xref:System.FormatException> Если данные не в требуемом формате.  
  
-   Объект <xref:System.IO.FileNotFoundException> Если не удается найти сборку, содержащую тип, к которой принадлежит данные.  
  
-   Объект <xref:System.TypeLoadException> Если тип, к которой принадлежит данных не может быть не найден.  
  
 Как правило возникают эти исключения, если RESOURCES-файл был изменен вручную, если сборки, в которой определен тип, либо не были включены с приложением или был случайно удален, или в том случае, если сборка является более старой версии, который предшествовал тип. Если возникает одно из этих исключений, можно получить ресурсы, перечисление каждого ресурса и вызвав <xref:System.Resources.ResourceReader.GetResourceData%2A> метод, как показано в следующем разделе. Такой подход предоставляет некоторую информацию о данных ввода, <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> попыталась вернуть свойство.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Извлечение ресурсов по имени с GetResourceData  
 Второй подход к перечисление ресурсов в RESOURCES-файл также включает в себя перемещение ресурсов в файле, вызвав `IDictionaryEnumerator.MoveNext` метод. Для каждого ресурса, извлечении имени ресурса из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойство, которое затем передается <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> метод для извлечения данных ресурса. Это значение возвращается в виде массива байтов в `resourceData` аргумент.  
  
 Этот подход является менее удобны, чем получение ресурса имя и значение из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> и <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства, поскольку он возвращает фактическое количество байтов, которые образуют значение ресурса. Тем не менее, если попытка получить ресурс вызывает исключение, <xref:System.Resources.ResourceReader.GetResourceData%2A> метод может помочь определить источник исключения, указав сведения о типе данных ресурса. Дополнительные сведения о строку, указывающую на тип данных ресурса, см. в разделе <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 Как использовать этот подход для извлечения ресурсов, так и для обработки исключений, которые вызываются в следующем примере. Он программным образом создает двоичный RESOURCES-файл, который содержит четыре строки, второе логическое значение, одним целым числом, одного точечного рисунка и один произвольный `DateTimeTZI` объекта. Чтобы запустить пример, сделайте следующее:  
  
1.  Создать сборку с именем Library.dll, содержащий `DateTimeTZI` структуры. Ниже приведен исходный код для сборки.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Скомпилируйте исходный код на языке C# с помощью следующей команды:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Или можно выполнить компиляцию в Visual Basic с помощью следующей команды:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Скомпилируйте и выполните следующий исходный код, который создает в RESOURCES-файл с именем ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Файл исходного кода называется CreateResources.cs. Его можно скомпилировать в C# с помощью следующей команды:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Или можно выполнить компиляцию в Visual Basic с помощью следующей команды:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Скомпилируйте и запустите следующий код, чтобы перечислить ресурсы в файле ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     После внесения изменений в исходный код (например, выдав намеренно <xref:System.FormatException> в конце `try` блок) или переименование Library.dll сборки, чтобы он недоступен во время выполнения, можно запустить пример, чтобы просмотреть как вызовы <xref:System.Resources.ResourceReader.GetResourceData%2A> позволяют извлечь или повторно создать некоторые сведения о ресурсах.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Входной поток для чтения ресурсов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для заданного потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> Конструктор создает <xref:System.Resources.ResourceReader> объект, который извлекает ресурсы из RESOURCES-файл автономного или из .resources файл, который является, внедренных в сборку. Чтобы прочитать текст из автономного RESOURCES-файл, следует создать <xref:System.IO.Stream> объект и передать его в <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор. Чтобы прочитать текст из внедренный RESOURCES-файл, вызовите <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> метод, с учетом регистра именем RESOURCES-файл и передайте возвращенный <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор.  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Txt-файл можно скомпилировать в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen PatientForm.txt**  
  
 В следующем примере предполагается, что файл ресурсов внедряется в сборку, содержащую исполняемый код приложения. Он извлекает файл ресурсов с именем `PatientForm.resources` из текущей выполняемой сборки и отображает имя и значение каждого из его ресурсы.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Если в примере C# называется `Example.cs`, можно выполнить компиляцию с помощью следующей команды:  
  
 **CSC Example.cs /res:PatientForm.resources**  
  
 Если в примере Visual Basic называется `Example.vb`, можно выполнить компиляцию с помощью следующей команды:  
  
 **Vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="stream" /> недоступен для чтения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При доступе к <paramref name="stream" /> произошла ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления служб сериализации. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Путь к файлу и имя файла ресурсов для чтения. В параметре <c>filename</c> регистр не учитывается.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для указанного именованного файла ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> Конструктор создает <xref:System.Resources.ResourceReader> объект, который извлекает ресурсы из автономного RESOURCES-файл. Чтобы получить ресурсы из внедренный RESOURCES-файл, используйте <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор.  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Можно скомпилировать этот txt-файл в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen PatientForm.txt**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображает имя и значение каждого из них.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="fileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.BadImageFormatException">Файле ресурса имеет недопустимый формат. Например, длина файла может быть равна нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы операционной системы, связанные с этим объектом <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> может безопасно вызываться несколько раз.  
  
   
  
## Examples  
 В следующем примере перемещается по ресурсам файла и отображает все найденные пары ключ/значение. В этом коде используется <xref:System.Resources.ResourceReader.Close%2A> метод, чтобы завершить работу <xref:System.Resources.ResourceReader> и освободить все ресурсы, используемые в нем.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда вы закончите, с помощью этого <xref:System.Resources.ResourceReader>, вызовите <xref:System.Resources.ResourceReader.Dispose%2A> освободить все ресурсы, используемые этим экземпляром. Следует удалить дополнительные ссылки на это <xref:System.Resources.ResourceReader> экземпляр таким образом, чтобы сборщик мусора мог освободить память экземпляра вместо того чтобы постоянно активным для заключительной обработки.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> вызывает закрытый метод Dispose(Boolean), который содержит код для освобождения управляемых и неуправляемых ресурсов. Дополнительные сведения см. в разделе [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, перечислить ресурсы путем вызова <xref:System.Resources.ResourceReader.GetEnumerator%2A> метод и затем повторный вызов <xref:System.Collections.IEnumerator.MoveNext%2A> метод возвращенного <xref:System.Collections.IDictionaryEnumerator> объекта до выполнения метода `false`. Имя ресурса доступен из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойство; свое значение из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойство. В примере показано, как перечислить ресурсы таким образом.  
  
 Реализация <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства <xref:System.Resources.ResourceReader> класса можно вызывать следующие исключения:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Не удается найти сборку, содержащую тип, к которой принадлежит данные.  
  
-   <xref:System.FormatException>  
  
     Данные не в требуемом формате.  
  
-   <xref:System.TypeLoadException>  
  
     Не удается найти тип, к которой принадлежит данные.  
  
 Можно обработать исключение, вызвав метод <xref:System.Resources.ResourceReader.GetResourceData%2A> метод для извлечения сведений о типе данных и массив байтов, назначенные именованный ресурс. Дополнительные сведения см. в разделе «Получение ресурсов по имени с GetResourceData» <xref:System.Resources.ResourceReader> разделе, посвященном классу.  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader> Класс включает два метода, которые возвращают перечислителей. <xref:System.Resources.ResourceReader.GetEnumerator%2A> Возвращает метод <xref:System.Collections.IDictionaryEnumerator> объекта интерфейса и рекомендуемый метод, который вызывается, когда перечисление ресурсов.  
  
   
  
## Examples  
 В примере этого раздела используется следующий txt-файл с именем `PatientForm.txt` для определения ресурсов, используемых приложением.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Txt-файл можно скомпилировать в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen PatientForm.txt**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображает имя и значение каждого из них.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Устройство чтения уже закрыто или удалено, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="resourceName">Имя ресурса.</param>
        <param name="resourceType">При возвращении этого метода содержит строку, представляющую имя типа извлекаемого ресурса. Этот параметр передается неинициализированным.</param>
        <param name="resourceData">Когда этот метод возвращает значение, оно содержит массив байтов, являющийся двоичным представлением извлеченного типа. Этот параметр передается неинициализированным.</param>
        <summary>Получает имя типа и данные именованного ресурса из открытого файла ресурсов или потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A> Метод возвращает значение именованного ресурса в виде массива байтов. Обычно используется, когда <xref:System.Collections.IDictionaryEnumerator.Value%2A> свойство вызывает исключение при попытке получить значение ресурса.  
  
 `resourceType` — Это строка, представляющая тип данных ресурса. Это может быть любой из следующих значений:  
  
-   Строковое представление `ResourceTypeCode` член перечисления, указывающее тип данных ресурса. `ResourceTypeCode` — Закрытое перечисление, используемый сюда указывают, что специальные двоичный формат используется для хранения одно из 19 общие типы данных. К ним относятся типы-примитивы платформы .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), а также <xref:System.String>, <xref:System.DateTime>, и <xref:System.TimeSpan>, кроме того, `ResourceTypeCode` перечисление содержит значения, показанные в следующей таблице.  
  
    |Значение ResourceTypeCode|Описание|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Данные представляют собой массив байтов. Эти данные часто введите результаты из вызова <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> метод.|  
    |`ResourceTypeCode.Null`|Данные является пустой ссылкой. Эти данные часто введите результаты из вызова <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> метод с объекта, значение которого равно `null`.|  
    |`ResourceTypeCode.Stream`|Данные хранятся в виде потока. Эти данные часто введите результаты из вызова <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> или <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> метод.|  
  
     Предположим, что `resourceData` не был поврежден, его можно обычно преобразования из массива байтов обратно в исходное значение путем вызова <xref:System.BitConverter> или <xref:System.IO.BinaryReader> метод.  
  
-   Строка, содержащая полное имя типа которого сериализованных данных назначается `resourceData` аргумент (например, `System.String`). Кроме того для типов, которые не являются частью библиотеки классов .NET Framework, строка содержит имя, версию, язык и региональные параметры и открытый ключ сборки, содержащей тип. Например, следующая строка указывает, что сериализованные данные представляет экземпляр `Person` введите `Extensions` пространства имен, которое находится в версии 1.0 сборки с именем служебной программы, который содержит открытый ключ не и без заданного языка и региональных параметров.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Предположим, что `resourceData` не поврежден и что доступен тип источника, `resourceData` могут преобразовываться из массива байтов обратно в исходное значение, преобразовав массив байтов для <xref:System.IO.Stream> объект и передает поток <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>метод.  
  
-   Строка, используемая для описания типа данных в <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> вызов метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> — не существует.</exception>
        <exception cref="T:System.BadImageFormatException">Недопустимый тип параметра <paramref name="resourceName" />.</exception>
        <exception cref="T:System.FormatException">Извлеченные данные ресурсов повреждены.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Resources.ResourceReader" /> не инициализирован (скорее всего, потому что он закрыт).</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> является явной реализацией интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Resources.ResourceReader> приведен к типу интерфейса <xref:System.Collections.IEnumerable>. Рекомендуемый подход для перечисления ресурсов в RESOURCES-файл является вызов <xref:System.Collections.IEnumerator.MoveNext%2A> метод <xref:System.Collections.IDictionaryEnumerator> объект, возвращаемый <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Средство чтения уже закрыто, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые объектом <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызов Dispose позволяет ресурсы, используемые <xref:System.Resources.ResourceReader> перераспределить для других целей. Дополнительные сведения о Dispose, см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).

## Examples  
В следующем примере кода проходит через файловые ресурсы и выводит на экран все найденные пары ключ/значение. В этом коде используется метод theIDisposable.Dispose завершение работы <xref:System.Resources.ResourceReader> и освободить все ресурсы, используемые в нем.

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>