<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d0c16b8e46be32f6651836c170b722768bf5514" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56765905" /></Metadata><TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Позволяет настраивать работу системы безопасности домена приложения и управлять ею.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании нового <xref:System.AppDomain>, общих запросов среды выполнения языка <xref:System.AppDomainManager> на наличие <xref:System.Security.HostSecurityManager>, который участвует в принятии решений безопасности <xref:System.AppDomain>.  Узел поставщики должны реализовать диспетчер безопасности узла, который наследуется от <xref:System.Security.HostSecurityManager> класса.  
  
   
  
## Examples  
 Следующий пример показывает очень простую реализацию <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться в частично доверенном или прозрачном коде.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <block subset="none" type="overrides"><para>Некоторые из членов <see cref="T:System.Security.HostSecurityManager" /> вызываются всякий раз, когда сборка загружается, явно или неявно. <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> И <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> методов не должно загружать все сборки, так как это приведет к в членах <see cref="T:System.Security.HostSecurityManager" /> , вызывается рекурсивно. Чтобы избежать циклических ссылок, необходимо создать новые экземпляры классов, которые могут вызвать загрузку сборок, явно или неявно, в конструкторе класса, производного от <see cref="T:System.Security.HostSecurityManager" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.HostSecurityManager" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот член не может наследоваться кодом с частичным доверием.</permission>
        <block subset="none" type="overrides"><para>Создайте экземпляры классов, которые могут вызвать загрузку, явно или неявно, сборок, в этом конструкторе.  Метод доступа get для <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> свойство и <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> и <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> методы вызываются всякий раз, когда сборка загружается, и их последующей загрузке сборок будет вызвать циклические ссылки.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Свидетельство для активируемого приложения.</param>
        <param name="activatorEvidence">Свидетельство для активирующего домена приложения (необязательное).</param>
        <param name="context">Контекст доверия.</param>
        <summary>Определяет, должно ли выполняться приложение.</summary>
        <returns>Объект, содержащий сведения о доверии в отношении приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом. Базовая реализация вызывает диспетчер безопасности приложения, чтобы определить, если приложение должно выполняться.  
  
 Базовая реализация не использует свидетельство активатора. Однако переопределенную реализацию использовать свидетельство активатора для определения свидетельство безопасности для домена приложения, предпринимается попытка активировать приложение.  
  
   
  
## Examples  
 В следующем примере показано, как переопределить <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> метод для диспетчера безопасности пользовательского ведущего приложения. Этот пример является частью большего примера для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="applicationEvidence" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Не удается найти в свидетельстве приложения объект <see cref="T:System.Runtime.Hosting.ActivationArguments" />.  
  
-или- 
Свойство <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> в аргументах активации имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Набор разрешений <see cref="T:System.Security.Policy.ApplicationTrust" /> не содержит минимального набора запросов, определенного в объекте <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает политику безопасности для текущего домена приложения.</summary>
        <value>Политика безопасности для текущего домена приложения. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство может быть переопределено в производном классе. Базовая реализация всегда возвращает значение `null`.  
  
 Это свойство вызывается в <xref:System.AppDomain> время создания. Это позволяет основному приложению предоставить политику для текущего <xref:System.AppDomain>.  Уровень политики состоит из следующих:  
  
-   Набор групп кода, упорядоченных в одно дерево с административным доступом.  
  
-   Набор именованных наборов разрешений, на которые ссылается группы кода, чтобы указать разрешения для нельзя предоставлять коду, принадлежащий к группе кода.  
  
-   Список сборок с полным доверием.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации важные сведения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод использует политику разграничения доступа кода (CAS), которая является устаревшей для [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями .NET Framework, используйте [элемент &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает флаги, представляющие компоненты политики безопасности, необходимые сайту.</summary>
        <value>Одно из значений перечисления, указывающее компоненты политики безопасности. Значение по умолчанию — <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство может быть переопределено в производном классе. Базовая реализация всегда возвращает значение <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 Производный узел можно изменить значение этого свойства, если только подмножество <xref:System.Security.HostSecurityManagerOptions> представляет интерес.  Возможные подмножества включают none, отклоненный набор, уровень политики и свидетельство сборки.  
  
   
  
## Examples  
 В следующем примере показано, как переопределить <xref:System.Security.HostSecurityManager.Flags%2A> свойства диспетчера безопасности пользовательского ведущего приложения. Этот пример является частью большего примера для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Тип свидетельства.</param>
        <summary>Запрашивает определенный тип свидетельства для домена приложения.</summary>
        <returns>Запрошенное свидетельство домена приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом. Базовая реализация возвращает `null`.  
  
 Среда CLR вызывает этот метод при необходимости свидетельства указанного типа для текущего <xref:System.AppDomain>. Возвращаемое значение используется в качестве свидетельств, предоставляемых веб-узла и хранится в <xref:System.AppDomain.Evidence%2A> коллекцию <xref:System.AppDomain.CurrentDomain%2A> свойство. Можно использовать <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> метод, чтобы получить свидетельство, созданный из коллекции.  
  
 Чтобы получить обратный вызов к этому методу, необходимо указать узлы <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> флаг в <xref:System.Security.HostSecurityManager.Flags%2A> свойство.  
  
 Этот метод создания свидетельства позволяет узлам отложить создание свидетельство для <xref:System.AppDomain> пока они не понадобятся свидетельство. В .NET Framework версии 3.5 и более ранних версий, она была необходима для предоставления <xref:System.AppDomain> свидетельство во время загрузки, переопределив <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод. Мы рекомендуем использовать <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> для доказательства того, вместо переопределения <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Метод вызывается в только для типов свидетельства, определены в переопределении <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> метод.  
  
 Возвращаемое значение `null` указывает, что узел не может создать свидетельства указанного типа.  
  
   
  
## Examples  
 В следующем примере показано, как переопределить <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод для диспетчера безопасности пользовательского ведущего приложения. Этот пример является частью большего примера для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Тип свидетельства.</param>
        <param name="assembly">Целевая сборка.</param>
        <summary>Запрашивает определенный тип свидетельства для сборки.</summary>
        <returns>Запрошенное свидетельство сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом. Базовая реализация возвращает `null`.  
  
 Среда CLR вызывает этот метод при необходимости свидетельства указанного типа для текущей сборки. Возвращаемое значение используется в качестве свидетельств, предоставляемых веб-узла и хранится в <xref:System.Reflection.Assembly.Evidence%2A> свойство. Можно использовать <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> метод, чтобы получить свидетельство, созданный <xref:System.Reflection.Assembly.Evidence%2A> свойство.  
  
 Чтобы получить обратный вызов к этому методу, необходимо указать узлы <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> флаг в <xref:System.Security.HostSecurityManager.Flags%2A> свойство.  
  
 Этот метод создания свидетельства позволяет узлам отложить создание свидетельство для <xref:System.AppDomain> пока они не понадобятся свидетельство. В .NET Framework 3.5 и более ранних версий, она была необходима для предоставления <xref:System.AppDomain> свидетельство во время загрузки, переопределив <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> метод. Мы рекомендуем использовать <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> для доказательства того, вместо переопределения <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Метод вызывается в только для типов свидетельства, определены в переопределении <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> метод.  
  
 Возвращаемое значение `null` указывает, что узел не может создать свидетельства указанного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, какие типы свидетельства узел может предоставить домену приложения при запросе.</summary>
        <returns>Массив типов свидетельства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом. Базовая реализация возвращает `null`.  
  
 Типы, возвращаемого этим методом, определяют ли <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> метод вызывается в. Присутствие этого типа в этом списке не означает узел должен уметь создавать этот тип свидетельства, но можно попытаться. По этой причине лучше чрезмерно указать вместо того, чтобы в задавать типы в этом списке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">Целевая сборка.</param>
        <summary>Определяет, какие типы свидетельства узел может предоставить сборке при запросе.</summary>
        <returns>Массив типов свидетельства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен производным классом. Базовая реализация возвращает `null`.  
  
 Типы, возвращаемого этим методом, определяют ли <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> метод вызывается в. Присутствие этого типа в этом списке не означает узел должен уметь создавать этот тип свидетельства, но можно попытаться. По этой причине лучше чрезмерно указать вместо того, чтобы в задавать типы в этом списке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Дополнительное свидетельство, добавляемое к свидетельству <see cref="T:System.AppDomain" />.</param>
        <summary>Содержит свидетельство домена приложения для загружаемой сборки.</summary>
        <returns>Свидетельство, используемое для класса <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Этот метод вызывается всякий раз, когда <xref:System.AppDomain> создается объект. `inputEvidence` Параметр является вычисляемым свидетельство, среда CLR. Реализация узла можно увеличить или уменьшить свидетельство. Возвращает значение свидетельство, используемое для домена приложения.  Базовая реализация всегда возвращает объект свидетельства, переданный в качестве `inputEvidence` параметра.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации важные сведения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Загруженная сборка.</param>
        <param name="inputEvidence">Дополнительное свидетельство, добавляемое в свидетельство сборки.</param>
        <summary>Содержит свидетельство сборки для загружаемой сборки.</summary>
        <returns>Свидетельство, используемое для сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Этот метод вызывается всякий раз, когда сборка загружается, явно или неявно. Переданными в параметрах являются загружаемая сборка и вычисленное свидетельство среда CLR. Реализация узла можно увеличить или уменьшить свидетельство. Возвращает значение свидетельство, используемое для сборки.  Базовая реализация всегда возвращает объект свидетельства, переданный в качестве `inputEvidence` параметра.  
  
> [!IMPORTANT]
>  См. примечания для наследующих объектов для <xref:System.Security.HostSecurityManager> класс для реализации важные сведения.  
  
   
  
## Examples  
 В следующем примере показано, как переопределить <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> метод для диспетчера безопасности пользовательского ведущего приложения. Этот пример является частью большего примера для <xref:System.Security.HostSecurityManager> класса.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Набор свидетельств, используемых для оценки политики.</param>
        <summary>Определяет разрешения, которые нужно предоставить коду, на основе определенного свидетельства.</summary>
        <returns>Набор разрешений, которые могут быть предоставлены системой безопасности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает обработчик политики безопасности, передавая ему указанное свидетельство. Результат определяется политикой безопасности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="evidence" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>