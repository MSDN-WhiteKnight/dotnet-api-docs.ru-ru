<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ebd69e389a8e772381b0a3f87e7c323d91525d51" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55346880" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сериализует объекты в текст сообщения или десериализует текст сообщения в объекты, используя для этого формат XML, основанный на определении схемы XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.XmlMessageFormatter> — Это модуль форматирования по умолчанию, экземпляр <xref:System.Messaging.MessageQueue> использует для сериализации сообщений в очереди. При создании экземпляра <xref:System.Messaging.MessageQueue>, экземпляр <xref:System.Messaging.XmlMessageFormatter> автоматически и связывается с <xref:System.Messaging.MessageQueue>. Можно указать другой модуль форматирования, создав его в коде и назначив его <xref:System.Messaging.MessageQueue.Formatter%2A> свойство вашей <xref:System.Messaging.MessageQueue>.  
  
 По умолчанию очереди <xref:System.Messaging.XmlMessageFormatter> экземпляр может использоваться для записи в очередь, но он не может использоваться для чтения из очереди, пока не будет задан либо <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> свойство модуля форматирования. Можно либо установить одно или оба этих значения в экземпляр модуля форматирования по умолчанию, или можно создать новый экземпляр модуля форматирования и установить эти значения автоматически, передав их в качестве аргументов в соответствующий <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктор.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется каждой операции должен быть полностью специфицированным, указав его имя сборки. Кроме того при работе с несколькими параллельными версиями, номер версии должен также быть добавлен к имени типа цели также.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из двух свойств должно быть задано при чтении из очереди, но можно установить оба. Набор типов является совокупный набор из двух свойств. Решение какое свойство использовать к конкретному приложению. Если тело сообщения содержит тип, схема которой соответствует ни одному из типов в массиве для любого из этих свойств, исключение возникнет при считывании сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter> Является важнейшим компонентом слабо связанных обмена сообщениями на основе XML. Программа XSD.exe, использующая формат XML используется для создания XML-схем, например, при использовании служебной программы для сериализации класса, используемого приложением. Этот класс должен иметь конструктор по умолчанию.  
  
 Используется формат снова в обратном процессе когда программа создает класс, на основе схемы распространении описания класса данных. Использование служебной программы и XML-схемы, он создает позволяет избежать перераспределения DLL-файлов, каждый раз при повторной компиляции класса после реализации этого класса. До тех пор, пока не изменить схему на стороне клиента или сервера, другие изменения с обеих сторон не влияют на другой.  
  
   
  
## Examples  
 В следующем примере кода включает три части кода: серверный компонент, класс order и код клиента. Класс order, можно с помощью программы XSD.exe для создания схемы, распознаваемой сервером во входящих сообщениях. Схема является форматированный XML-файл, описывающий «форму» класса. Эту схему можно использоваться на стороне клиента, чтобы создать класс order, относящиеся к клиенту, который использует ту же схему, что и серверный класс.  
  
 В следующем примере кода представлен серверный компонент, получающий заказы через очередь сообщений. Текст сообщения должен быть объект заказа, схема которой совпадает с классом Order.cs ниже. Серверный процесс или приложение выполняет десериализацию порядок.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 В следующем примере кода представляет класс order, который предоставляет схему для объектов заказов и десериализуемых приложением на сервере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Любое клиентское приложение, которое взаимодействует с приложением на сервере необходимо отправлять сообщения на сервер, сериализуя данные в классе локально определенный порядок, в текст сообщения. Этот класс локально определенный порядок должен иметь ту же схему, что класс order, определенные на сервере, в который приложение на сервере будет пытаться десериализации текста сообщения. Программа XSD.exe позволяет диспетчеру приложения на сервере Создание и распространение схему, которую клиент должен использовать для сериализации сообщения, отправляемые на сервер.  
  
 Когда диспетчер клиентского приложения получает схему для класса order, программа XSD.exe снова используется для создания класса order относящиеся к клиенту из схемы. Этот класс, который используется в примере кода клиента ниже сервера класс order (программа XSD.exe вызывает класс, сформированные схемой, имеет имя, совпадающее с именем исходного класса). Этот новый класс order используется для сериализации заказа в тело сообщения.  
  
 В следующем примере кода — это клиентская обработка, используемая для сериализации заказа и передавать эти сведения, связанные с заказом в очередь. Этот код связывает элемент, количество и адрес с элементами схемы, которые были созданы для класса Order.cs служебной программой XSD.exe. Заказ передается в очередь заказов на локальном компьютере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 После создания схемы из класса order на сервере можно изменить класс. Если не изменения схемы, не требуется повторно распространить схему. После распространения схемы и создания класса на заказ на стороне клиента, этот клиентский класс можно также изменить независимо от сервера класс order, до тех пор, пока схема не изменяется. Эти два класса становятся слабо связанными.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" /> без набора типов целевых объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка конструктора используется чаще всего при записи в очередь типы целевых объектов при необходимости, при написании.  
  
 Для считывания сообщения из очереди, используя экземпляр <xref:System.Messaging.XmlMessageFormatter> создано с помощью этого конструктора, необходимо задать <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> таким образом, чтобы модуль форматирования знает, какие типы нужно попытаться выполнить десериализацию.  
  
 При создании нового <xref:System.Messaging.MessageQueue>, по умолчанию <xref:System.Messaging.XmlMessageFormatter> , создается экземпляр без набора типов назначения. Как и в случае с модулем форматирования, созданные с помощью этого конструктора, необходимо задать типы целевого объекта для этого экземпляра модуля форматирования, если требуется выполнить чтение из очереди.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Массив типа <see cref="T:System.String" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения. Эти значения должны быть полностью определены, например, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив (полностью определенных) строковых значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами типов целевых объектов чаще всего используются при чтении из очереди. При написании, в некоторых случаях не требуется указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора задает <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> свойства значения массива, переданного через `targetTypeNames` параметра. Установка этого свойства позволяет <xref:System.Messaging.MessageQueue> с помощью этого <xref:System.Messaging.XmlMessageFormatter> экземпляру для считывания сообщений, содержащих объекты заданного типа.  
  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из двух свойств должно быть задано при чтении из очереди, но можно установить оба. Набор типов является совокупный набор из двух свойств. Решение, какую из них следует использовать к конкретному приложению. Если тело сообщения содержит тип, схема которой соответствует ни одному из типов в массиве для любого из этих свойств, исключение возникнет во время чтения.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="targetTypeNames" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Массив типа <see cref="T:System.Type" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив типов объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами типов целевых объектов чаще всего используются при чтении из очереди. При написании, в некоторых случаях не требуется указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора задает <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства значения массива, переданного через `targetTypes` параметра. Установка этого свойства позволяет <xref:System.Messaging.MessageQueue> с помощью этого <xref:System.Messaging.XmlMessageFormatter> экземпляру для считывания сообщений, содержащих объекты заданных типов.  
  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из двух свойств должно быть задано при чтении из очереди, но можно установить оба. Набор типов является совокупный набор из двух свойств. Решение, какую из них следует использовать к конкретному приложению. Если тело сообщения содержит тип, схема которой соответствует ни одному из типов в массиве для любого из этих свойств, исключение возникнет во время чтения.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется каждой операции должен быть полностью специфицированным, указав его имя сборки. Кроме того при работе с несколькими параллельными версиями, номер версии должен также быть добавлен к имени типа цели также.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, можно добавить каждый объект (например, `MyClass`) в список, в результате, показано в следующем примере кода C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="targetTypes" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.Messaging.Message" /> для проверки.</param>
        <summary>Определяет, может ли модуль форматирования десериализовать сообщение.</summary>
        <returns>Значение <see langword="true" />, если XML-модуль форматирования может десериализовать сообщение; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> вызывается форматер попытается определить, если содержимое сообщения может выполнить десериализацию. Модуль форматирования может десериализовать сообщение, только если тип в теле сообщения имеет ту же схему, что один из типов в массиве, представленный <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Возвращает `false` в следующих двух случаях:  
  
-   Сообщение не был отформатирован с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Схема тела сообщения не в списке в либо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойство.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру какие типы объектов, он должен иметь возможность десериализации. Если любой тип отсутствует в списке, но найден в сообщении, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="message" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, свойства чтения и записи (наборы типов целевых объектов) которого такие же, как и у текущего экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
        <returns>Объект со свойствами, идентичными свойствам данного экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />, но с метаданными, которые не определяют его как экземпляр класса модуля форматирования.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает копию модуля форматирования и инициализирует все свойства, чтобы значения данного <xref:System.Messaging.XmlMessageFormatter> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Десериализуемое сообщение <see cref="T:System.Messaging.Message" /> в XML-формате.</param>
        <summary>Читает содержимое из данного сообщения и создает объект, содержащий десериализованное сообщение.</summary>
        <returns>Десериализованное сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Одно из этих свойств должно быть задано до сообщение может быть десериализован.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Типы целевого объекта нет необходимости указывать для записи в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.  
  
-или- 
Экземпляр, сериализуемый в тело сообщения, не согласуется ни с одной из схем, представленных типами в свойствах <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> и <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="message" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.String" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из двух свойств должно быть задано при чтении из очереди, но можно установить оба. Набор типов является совокупный набор из двух свойств. Решение какое свойство использовать к конкретному приложению. Если тело сообщения содержит тип, схема которой соответствует ни одному из типов в массиве для любого из этих свойств, исключение возникнет при считывании сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется каждой операции должен быть полностью специфицированным, указав его имя сборки. Кроме того при работе с несколькими параллельными версиями, номер версии должен также быть добавлен к имени типа цели также.  
  
 Целевые типы являются только необходимые при чтении из очереди. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства не обязательно должны иметь значение записи в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.Type" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модуль форматирования схемы для поиска при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализуемый в тело сообщения должно согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метод, метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из двух свойств должно быть задано при чтении из очереди, но можно установить оба. Набор типов является совокупный набор из двух свойств. Решение какое свойство использовать к конкретному приложению. Если тело сообщения содержит тип, схема которой соответствует ни одному из типов в массиве для любого из этих свойств, исключение возникнет при считывании сообщения.  
  
 Целевые типы являются только необходимые при чтении из очереди. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства не обязательно должны иметь значение записи в очередь.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, можно добавить каждый объект (например, `MyClass`) в список, в результате, показано в коде C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Body" /> которого будет содержать сериализованный объект.</param>
        <param name="obj">Объект <see cref="T:System.Object" />, сериализуемый в тело сообщения.</param>
        <summary>Выполняет сериализацию объекта в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не нужно указывать типы целевого объекта для записи в очередь, так как они должны быть при чтении. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойство используется модулем форматирования только в том случае, при десериализации сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter> Использует <xref:System.Xml.Serialization.XmlSerializer> класс, который определяет, что может быть сериализован. Только открытые поля и открытые свойства могут быть сериализованы. Структуры, структуры с массивами и массивы структур являются сериализуемыми, до тех пор, пока они не используют кодированным стилем с протоколом SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="message" /> — <see langword="null" />.  
  
-или- 
Значение параметра <paramref name="obj" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>