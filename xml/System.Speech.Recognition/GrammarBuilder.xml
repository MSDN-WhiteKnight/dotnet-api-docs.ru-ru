<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="192371536742150cbc1ede0124c131635288eda1" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55334922" /></Metadata><TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет механизм для программного создания ограничений для грамматики распознавания речи.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Грамматиками распознавания речи часто разрабатываются в XML-формате, заданном параметром [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761). Если вы знакомы с SRGS, но необходимо программно создавать грамматики, можно использовать <xref:System.Speech.Recognition.SrgsGrammar> пространства имен, члены которого близко соответствуют элементами и атрибутами, определенными по SRGS. Если вы не знакомы с SRGS, или упрощенный программный подход для создания грамматики, с помощью которых можно эффективно выполнять множество распространенных сценариев; можно использовать <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> классы.  
  
 Используйте <xref:System.Speech.Recognition.GrammarBuilder> объектов для построения иерархическое дерево состоит из <xref:System.Speech.Recognition.Choices> объекты, которые содержат фразы, смешивается с преамбула и после amble фраз в каждом узле и заполняется семантического значения, которые передают значение в приложение.  
  
 Чтобы использовать <xref:System.Speech.Recognition.GrammarBuilder> для создания <xref:System.Speech.Recognition.Grammar> объекта, выполните следующие действия.  
  
1.  Создание объекта <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Добавление ограничений к <xref:System.Speech.Recognition.GrammarBuilder>, такие как <xref:System.String> объектов, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>и другие <xref:System.Speech.Recognition.GrammarBuilder> объекты, определяющие ограничения для грамматики.  
  
3.  Используйте один из <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструкторы для создания <xref:System.Speech.Recognition.Grammar> объект из завершенного <xref:System.Speech.Recognition.GrammarBuilder> грамматики.  
  
 Разработка с помощью <xref:System.Speech.Recognition.GrammarBuilder> лучше всего подходит для грамматики, иметь одно правило, содержащий списков или списков возможно списков. Чтобы программно создавать грамматики, имеющих несколько правил, или которым необходимо выполнять внутреннее правило ссылки, используйте классы <xref:System.Speech.Recognition.SrgsGrammar> пространства имен.  
  
 Экземпляры <xref:System.Speech.Recognition.GrammarBuilder> также можно получить путем неявного преобразования из некоторые другие классы или путем объединения <xref:System.Speech.Recognition.GrammarBuilder> со второй объект, содержащий ограничения для грамматики... Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы и <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы.  
  
 Чтобы добавить правила в существующий <xref:System.Speech.Recognition.GrammarBuilder>, использовать <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, и <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> методы.  
  
> [!IMPORTANT]
>  Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической. 
  
 Чтобы помочь с отладкой, <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> свойство возвращает текущее состояние <xref:System.Speech.Recognition.GrammarBuilder> как строка.  
  
 Дополнительные сведения о создании и использовании грамматиками распознавания речи, см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [создание грамматики GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты для создания грамматики, который может распознать одно из двух фразы «фон *colorChoice*"или «Меняем цвет фона на *colorChoice*".  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *colorChoice* из массива <xref:System.String> объектов. Объект <xref:System.Speech.Recognition.Choices> объекта является аналогом `one-of` в спецификации SRGS и содержит набор фраз, которые можно распознать при произношении. В примере также используется <xref:System.Speech.Recognition.Choices> объекта для группирования массив из двух <xref:System.Speech.Recognition.GrammarBuilder> объекты в пару альтернативные фраз, которые может распознать результирующий грамматики. Альтернативные слова или фразы являются компонентами большинства грамматики и <xref:System.Speech.Recognition.Choices> объект предоставляет следующие функциональные возможности для грамматик создан с параметром <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.GrammarBuilder> образована <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляры этого класса можно получить также неявные преобразования из других классов или путем объединения <xref:System.Speech.Recognition.GrammarBuilder> объект со второй объект из нового <xref:System.Speech.Recognition.GrammarBuilder>. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> методы.  
  
 Добавление ограничений к существующему <xref:System.Speech.Recognition.GrammarBuilder>, использовать <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, и <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> методов и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> оператор.  
  
> [!IMPORTANT]
>  Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической.
  
 Дополнительные сведения о создании и использовании грамматиками распознавания речи, см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [создание грамматики GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый пустой экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы добавить правила в существующий <xref:System.Speech.Recognition.GrammarBuilder> , используйте <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, и <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> методов и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> оператор.  
  
> [!IMPORTANT]
>  Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической.
  
   
  
## Examples  
 В следующем примере используется <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты для создания грамматики, который может распознать одно из двух фразы «фон *colorChoice*"или «Меняем цвет фона на *colorChoice*".  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *colorChoice* из массива <xref:System.String> объектов. Объект <xref:System.Speech.Recognition.Choices> объекта является аналогом `one-of` в спецификации SRGS и содержит набор фраз, любое из которых можно распознать при произношении. В примере также используется <xref:System.Speech.Recognition.Choices> объекта для группирования массив из двух <xref:System.Speech.Recognition.GrammarBuilder> объекты в пару альтернативные фраз, которые может распознать результирующий грамматики. Альтернативные слова или фразы являются компонентами большинства грамматики и <xref:System.Speech.Recognition.Choices> объект предоставляет следующие функциональные возможности для грамматик создан с параметром <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.GrammarBuilder> образована <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Набор вариантов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из набора объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о создании грамматики распознавания речи, который содержит альтернативные варианты, см. в разделе [с помощью варианта для создания грамматики GrammarBuilder](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты для создания грамматики, который может распознать одно из двух фразы «фон *colorChoice*"или «Меняем цвет фона на *colorChoice*".  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *colorChoice* из массива <xref:System.String> объектов. Объект <xref:System.Speech.Recognition.Choices> объекта является аналогом `one-of` в спецификации SRGS и содержит набор фраз, которые можно распознать при произношении. В примере также используется <xref:System.Speech.Recognition.Choices> объекта для группирования массив из двух <xref:System.Speech.Recognition.GrammarBuilder> объекты в пару альтернативные фраз, которые может распознать результирующий грамматики. Альтернативные слова или фразы являются компонентами большинства грамматики и <xref:System.Speech.Recognition.Choices> объект предоставляет следующие функциональные возможности для грамматик создан с параметром <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.GrammarBuilder> образована <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Семантический ключ.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из семантического ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании <xref:System.Speech.Recognition.GrammarBuilder> экземпляра из <xref:System.Speech.Recognition.SemanticResultValue> объекта, добавьте семантической информации в грамматику, которые могут быть возвращены в результате распознавания. Вы можете получить доступ к семантической информации в результат распознавания с помощью <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase>, которая доступна в обработчике `SpeechRecognized` событий. Если <xref:System.Speech.Recognition.GrammarBuilder> определяет <xref:System.Speech.Recognition.SemanticResultKey>, это может использоваться для получения семантической информации в верности результата распознавания, связанный с ключом. См. в примере <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>, а также см. в разделе <xref:System.Speech.Recognition.SemanticResultValue> и <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  При построении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> Свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *colorChoice*"и «Меняем цвет фона на *colorChoice*«, где  *colorChoice* выбирается из набора цветов. Грамматика позволяет пользователю ни один из нескольких названий цветов и возвращает семантической информации об имени распознанных цвет к приложению.  
  
 В примере используется один <xref:System.Speech.Recognition.SemanticResultKey> с помощью которого можно получить <xref:System.Speech.Recognition.SemanticValue> который связан с цветом, произносятся пользователем. Например, если входные данные содержат фразу «Set фон на красный,» результат распознавания содержит семантическое значение «#ff0000», который можно получить с помощью обработчика для `SpeechRecognized` событий.  
  
 В примере используется <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов для создания ограничений, содержащихся в последнем <xref:System.Speech.Recognition.GrammarBuilder> объекта, `bothPhrases`. Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объект из завершенного <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Семантическое значение или пара имя-значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из семантического значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании <xref:System.Speech.Recognition.GrammarBuilder> экземпляра из <xref:System.Speech.Recognition.SemanticResultValue> объекта, добавьте семантической информации в грамматику, которые могут быть возвращены в результате распознавания. Вы можете получить доступ к семантической информации в результат распознавания с помощью <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> свойство <xref:System.Speech.Recognition.RecognizedPhrase>, которая доступна в обработчике `SpeechRecognized` событий. Если <xref:System.Speech.Recognition.GrammarBuilder> определяет <xref:System.Speech.Recognition.SemanticResultKey>, это может использоваться для получения семантической информации в верности результата распознавания, связанный с ключом. См. в примере <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>, а также см. в разделе <xref:System.Speech.Recognition.SemanticResultValue> и <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  При построении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> Свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *colorChoice*"и «Меняем цвет фона на *colorChoice*«, где  *colorChoice* выбирается из набора цветов. Грамматика позволяет пользователю ни один из нескольких названий цветов и возвращает семантической информации об имени распознанных цвет к приложению.  
  
 В примере используется один <xref:System.Speech.Recognition.SemanticResultKey> с помощью которого можно получить <xref:System.Speech.Recognition.SemanticValue> который связан с цветом, произносятся пользователем. Например, если входные данные содержат фразу «Set фон на красный,» результат распознавания содержит семантическое значение «#ff0000», который можно получить с помощью обработчика для `SpeechRecognized` событий.  
  
 В примере используется <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов для создания ограничений, содержащихся в последнем <xref:System.Speech.Recognition.GrammarBuilder> объекта, `bothPhrases`. Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объект из завершенного <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из последовательности слов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фраза представляет точное произнесенной фразой, который может распознать грамматики распознавания речи. Дополнительные сведения о создании грамматики распознавания речи, который содержит строки, см. в разделе [использованию строк для создания грамматики GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты для создания грамматики, который может распознать одно из двух фразы «фон *colorChoice*"или «Меняем цвет фона на *colorChoice*".  
  
 После создания списка допустимых значений для *colorChoice* с помощью <xref:System.Speech.Recognition.Choices> объекта, в примере инициализируются два <xref:System.Speech.Recognition.GrammarBuilder> объектов, `makePhrase` и `setPhrase`, используя строку в качестве аргумента.  
  
 Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.Choices> объект приведен к <xref:System.Speech.Recognition.GrammarBuilder> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов.</param>
        <param name="subsetMatchingCriteria">Соответствующий режим, используемый грамматикой распознавания речи для распознавания фразы.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для подмножества последовательности слов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` Параметр представляет фразу, которая может распознать грамматики распознавания речи. `subsetMatchingMode` Параметр определяет подмножество фразу, которая может произнести для достижения успешного распознавание всю фразу. Это можно использовать для создания грамматики со списком записей, имеющих длинные имена, не требуя от пользователей произнести полное имя, чтобы соответствовать элементу.  
  
 Дополнительные сведения о режимах сопоставления см. в разделе <xref:System.Speech.Recognition.SubsetMatchingMode>. Дополнительные сведения о создании грамматики распознавания речи, который содержит строки, см. в разделе [использованию строк для создания грамматики GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для каждого <xref:System.Speech.Recognition.SubsetMatchingMode> значение и грамматику по выбору между соответствующий режим грамматики. Если значение `phrase` — «один два три четыре пять шесть семь», то грамматики подпоследовательности распознает входные данные «два три четыре», но не входные данные «один три пять». Тем не менее Грамматика упорядоченный набор распознает оба эти входные данные.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Повторяющийся элемент.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из повторяющегося элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `minRepeat` равно 0, то новый <xref:System.Speech.Recognition.GrammarBuilder> представляет необязательный элемент.  
  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно значению `maxRepeat`.  
  
> [!IMPORTANT]
>  При указании повторов для <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько семантические элементы, которые неоднократно могут изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для заказа пиццы. Он начинается с необязательным, откройте фразы, следуют начинки от одной до четырех и закрывает со словом «пицца».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Повторяющаяся последовательность слов.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входной фразы, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входной фразы, при котором засчитывается совпадение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из последовательности слов в <see cref="T:System.String" /> и определяет, сколько раз можно повторить <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `minRepeat` равно 0, то новый <xref:System.Speech.Recognition.GrammarBuilder> представляет необязательный элемент.  
  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно значению `maxRepeat`. Дополнительные сведения о создании грамматики распознавания речи, который содержит строки, см. в разделе [использованию строк для создания грамматики GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для заказа пиццы. Он начинается с необязательным, откройте фразы, следуют начинки от одной до четырех и закрывает со словом «пицца».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы предоставляют другой механизм, с помощью которых можно комбинировать различные типы для создания разнообразия и гибко грамматики созданных с помощью <xref:System.Speech.Recognition.GrammarBuilder>. Эти методы соответствуют статического <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> методы, которые также определены на <xref:System.Speech.Recognition.GrammarBuilder> класса. Порядок параметров определяет порядок элементов в новом <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Объект <xref:System.Speech.Recognition.GrammarBuilder> также может быть получен из <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, и [строка](https://go.microsoft.com/fwlink/?LinkId=159733) объектов. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
> [!IMPORTANT]
>  Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической. 
  
 Дополнительные сведения о создании и использовании грамматиками распознавания речи, см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [создание грамматики GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Первый элемент grammar, представляющий набор альтернатив.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.Choices" />, за которым следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="choices" />, за которой следует элемент <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра.  
  
 Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. Дополнительные сведения о создании грамматики распознавания речи, который содержит информацию о своем см. в разделе [добавьте семантику грамматике GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="choices">Второй элемент грамматики, который представляет набор вариантов.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, за которым следует объект <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder" />, за которой следует элемент <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра.  
  
 Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров с помощью других элементов грамматики, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько элементов семантической несколько раз изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов. Операторы явного приведения в вызовы <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Первый элемент грамматики.</param>
        <param name="builder2">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух объектов <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder1" />, за которой следует элемент <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder1` или `builder2` параметра.  
  
 Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров с помощью других элементов грамматики, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько элементов семантической несколько раз изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов. Операторы явного приведения в вызовы <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="phrase">Второй элемент грамматики, который представляет последовательность слов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которого следует фраза.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder" />, за которой следует элемент <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра.  
  
 Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов. Операторы явного приведения в вызовы <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Первый элемент грамматики, который представляет последовательность слов.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий фразу, после которой следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="phrase" />, за которой следует элемент <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра.  
  
 Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> операторы.  
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов. Операторы явного приведения в вызовы <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти методы можно использовать для добавления элементов грамматики к существующему <xref:System.Speech.Recognition.GrammarBuilder>. При создании элементов грамматики, их можно добавить в существующий конструктор для последовательной разработки ограничения для грамматики распознавания речи. Каждый элемент добавляется в конец текущей последовательности элементов.  
  
 Этот метод имеет перегрузки для добавления <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, и <xref:System.Speech.Recognition.SemanticResultValue> объектов.  
  
> [!IMPORTANT]
>  Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической. 
  
 Дополнительные сведения о создании и использовании грамматиками распознавания речи, см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [создание грамматики GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Набор вариантов для добавления.</param>
        <summary>Добавляет набор альтернатив к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.Choices> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляры <xref:System.Speech.Recognition.GrammarBuilder> объекта, убедитесь, что позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько семантической элементов, которые могут несколько раз изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для фразах, таких как «James вызов на работе» и «Anne вызов на свой сотовый телефон», где слово «телефон» является необязательным. В примере представлены использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метод.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Элемент грамматики для добавления.</param>
        <summary>Добавляет элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` добавляется в конец текущей последовательности элементов грамматики.  
  
> [!NOTE]
>  При добавлении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляры <xref:System.Speech.Recognition.GrammarBuilder> объекта, убедитесь, что позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько семантической элементов, которые могут несколько раз изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах. 
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для фразах, таких как «James вызов на работе» и «Anne вызов на свой сотовый телефон», где слово «телефон» является необязательным. <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты используются для создания грамматики. В примере представлены использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метод.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Семантический ключ для добавления.</param>
        <summary>Добавляет семантический ключ к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляры <xref:System.Speech.Recognition.GrammarBuilder> объекта, убедитесь, что позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
   
  
## Examples  
 Следующий пример является частью консольного приложения для выбора назначения и городов рейса. Приложение распознает фраз, такие как «Я хочу летать из Майами в Чикаго». Обработчик <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> событие использует <xref:System.Speech.Recognition.SemanticResultKey> мог извлечь нужный код аэропорта, указанный в <xref:System.Speech.Recognition.SemanticResultValue> города, источник и назначение.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Прибавляемое семантическое значение.</param>
        <summary>Добавляет семантическое значение к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляры <xref:System.Speech.Recognition.GrammarBuilder> объекта, убедитесь, что позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
   
  
## Examples  
 Следующий пример является частью консольного приложения для выбора назначения и городов рейса. Приложение распознает фраз, такие как «Я хочу летать из Майами в Чикаго». Обработчик <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> событие использует <xref:System.Speech.Recognition.SemanticResultKey> мог извлечь нужный код аэропорта, указанный в <xref:System.Speech.Recognition.SemanticResultValue> города, источник и назначение.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов для добавления.</param>
        <summary>Добавляет фразу к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` добавляется в конец текущей последовательности элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов для добавления.</param>
        <param name="subsetMatchingCriteria">Соответствующий режим, используемый грамматикой для распознавания фразы.</param>
        <summary>Добавляет элемент для подмножества фразы к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подмножество элемент добавлен в конец текущей последовательности элементов. Дополнительные сведения о создании грамматики распознавания речи с помощью строки, см. в разделе [использованию строк для создания грамматики GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Подробные сведения об использовании режима сопоставления подмножеств см. в разделе <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для каждого <xref:System.Speech.Recognition.SubsetMatchingMode> значение. Например, созданный грамматики `OrderedSubset` распознает фразах, «три четыре пять» и «один три пять» и грамматики `Subsequence` распознает фразы «три четыре пять», но не фразы, «один три пять».  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Повторяющийся элемент грамматики для добавления.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <summary>Добавляет повторный элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно значению `maxRepeat`.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляры <xref:System.Speech.Recognition.GrammarBuilder> объекта, убедитесь, что позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или несколько семантической элементов, которые могут несколько раз изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для фразах, таких как «James вызов на работе» и «Anne вызов на свой сотовый телефон», где слово «телефон» является необязательным. <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты используются для создания грамматики. В примере представлены использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метод.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Повторяющаяся последовательность слов для добавления.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных <paramref name="phrase" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных <paramref name="phrase" />, при котором засчитывается совпадение.</param>
        <summary>Добавляет повторную фразу к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно значению `maxRepeat`.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для фразах, таких как «James вызов на работе» и «Anne вызов на свой сотовый телефон», где слово «телефон» является необязательным. <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты используются для создания грамматики. В примере представлены использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метод.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет грамматику диктовки к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> Методы позволяют добавить грамматику диктовки, как правило, <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Дополнительные сведения о грамматики диктовки, см. в разделе <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет грамматику диктовки по умолчанию к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о грамматики диктовки, см. в разделе <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который включает режим диктовки.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Категория грамматики диктовки для добавления.</param>
        <summary>Добавляет указанную грамматику диктовки к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать грамматику диктовки правописания, задайте `category` для `spelling`.  
  
 Дополнительные сведения о грамматики диктовки, см. в разделе <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 В следующем примере создается грамматику распознавания речи, которое включает в себя правила грамматики диктовки правописания.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет файл грамматики или правило грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Методы можно добавить файл грамматики или правило грамматики из файла. Эти методы позволяют приложениям сделать использование предварительно развернутый или общедоступным грамматические правила. Приложение должно иметь доступ на чтение к расположению файлов указанного грамматики.  
  
 Эти методы можно считать грамматики распознавания речи из следующих форматов.  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Двоичные файлы, которые соответствуют Microsoft Speech распознавания грамматики двоичный формат (расширением файла cfg)  
  
 Компиляция SRGS XML-формата файла грамматики в двоичный файл грамматики с расширением cfg можно уменьшить время, затраченное поиск совпадения, особенно в том случае, если Грамматика требует распознавания большое количество слов и фраз. Дополнительные сведения о компиляции грамматик SRGS в двоичный формат CFG, см. в разделе <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь или универсальный идентификатор ресурса (URI) файла, который описывает грамматику распознавания речи в поддерживаемом формате.</param>
        <summary>Добавляет файл определения грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI, предоставляемые `path` аргумент может быть локальным или удаленным. Приложение должно иметь доступ на чтение к расположению файлов указанного грамматики.  
  
 Представление W3C грамматики распознавания речи Specification (SRGS) можно определить корневое правило. Этот метод добавляет грамматику, начиная с правилом корневой к текущей последовательности элементов грамматики. Чтобы добавить правило грамматики, используйте <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> метод.  
  
   
  
## Examples  
 В следующем примере C# создается грамматику распознавания речи, который использует правило с именем `Cities` в локальном файле SRGS, cities.grxml. Содержимое файла cities.grxml появляется в примере кода C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или универсальный идентификатор ресурса (URI) файла, который описывает грамматику распознавания речи в поддерживаемом формате.</param>
        <param name="rule">Идентификатор добавляемого правила или значение <see langword="null" />, чтобы добавить корневое правило файла грамматики по умолчанию.</param>
        <summary>Добавляет указанное правило файла определения грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI, предоставляемые `path` аргумент может быть локальным или удаленным. Приложение должно иметь доступ на чтение к расположению файлов указанного грамматики.  
  
 Можно использовать <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> метод для добавления файла грамматики, начиная с его корневое правило.  
  
   
  
## Examples  
 В следующем примере C# создается грамматику распознавания речи, который использует правило с именем `Cities` в локальном файле SRGS, cities.grxml. Содержимое файла cities.grxml появляется в примере кода C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет элемент грамматики распознавания, соответствующий любой входной информации для текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Группового элемента добавляется в конец текущей последовательности элементов.  
  
 Подстановочный элемент соответствует любой произнесенного слова. Он не соответствует фонового шума или бездействия.  
  
   
  
## Examples  
 В следующем примере создается грамматику, которая принимает входные данные пароля в качестве подстановочного знака. В этом примере подключается <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> обработчик событий для грамматики, который проверяет ввод пароля.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает язык и региональные параметры грамматики распознавания речи.</summary>
        <value>Язык и региональные параметры <see cref="T:System.Speech.Recognition.GrammarBuilder" />. По умолчанию — свойство <see cref="P:System.Threading.Thread.CurrentUICulture" /> выполняющего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Конструктор создает <xref:System.Speech.Recognition.Grammar> объект, который может использоваться распознавателем речи соответствующего языка и региональных параметров. Только <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> свойство <xref:System.Speech.Recognition.GrammarBuilder> , предоставляется как параметр в конструктор грамматики, используемый для задания языка и региональных параметров, полученный грамматики распознавания речи.  
  
 Microsoft Windows и System.Speech API принять все допустимые коды языка страны. Для выполнения распознавания речи с помощью языка, заданного параметром `Culture` свойство, в обработчик распознавания речи, который поддерживает, что код страны язык должен быть установлен. Механизмы распознавания речи, поставляемых вместе с Microsoft Windows 7 работать со следующими кодами языка страны.  
  
-   en-GB. Английский (Соединенное Королевство)  
  
-   en US. Русский (Россия)  
  
-   de-DE. Немецкий (Германия)  
  
-   es-ES. Испанский (Испания)  
  
-   fr-FR. Французский (Франция)  
  
-   ja-JP. Японский (Япония)  
  
-   zh-CN. Китайский (Китай)  
  
-   zh-TW. Китайский (Тайвань)  
  
 Коды двухбуквенный языка, например «en», «fr», или «es» разрешено.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи для заказа пиццы с до четырех начинки. В частности задает <xref:System.Speech.Recognition.GrammarBuilder> объекта языка и региональных параметров, на английский (США).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строку, которая отображает содержимое и структуру грамматики, содержащейся в <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>Текущее содержимое и структура <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается грамматики распознавания речи для заказа пиццы с до четырех начинки. Он записывает состояние <xref:System.Speech.Recognition.GrammarBuilder> в консоль, прежде чем создавать грамматики. Этот метод создает следующие выходные данные:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Создавать грамматики, с помощью GrammarBuilder</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, соответствующий последовательности из двух элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок операндов определяет порядок элементов в новом <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Внимание рекомендуется использовать при объединении <xref:System.Speech.Recognition.Choices> или <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров с помощью других элементов грамматики. Распознаватель речи может создавать исключения, при использовании грамматики распознавания речи, содержит повторяющиеся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно может изменять значение элемента же семантической. 
  
 Дополнительные сведения о создании и использовании грамматиками распознавания речи, см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [создание грамматики GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Первый элемент grammar, представляющий набор альтернатив.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.Choices" />, за которым следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="choices" />, а затем параметр <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="choices">Второй элемент грамматики, который представляет набор альтернативных вариантов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которого следует <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder" />, а затем параметр <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Первый элемент грамматики.</param>
        <param name="builder2">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух объектов <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder1" />, а затем параметр <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder1` и `builder2` параметров. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> экземпляров, убедитесь в том, позволяет избежать создания повторяющихся семантические элементы с тем же именем ключа или нескольких семантические элементы, которые многократно изменить <xref:System.Speech.Recognition.SemanticValue.Value%2A> Свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может создавать исключения при обнаружении этих обстоятельствах.
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="phrase">Второй элемент грамматики, который представляет последовательность слов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которой следует фраза.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder" />, а затем параметр <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> операторы.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Первый элемент грамматики, который представляет последовательность слов.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий фразу, после которой следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="phrase" />, а затем параметр <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает объекты, перечисленные выше для `builder` параметра. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> операторы.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать две фразы «фон *цвет*"и «Меняем цвет фона на *цвет*«, где *цвет* выбирается из набора цветов. Различные типы используются для создания окончательного грамматики, такие как [строка](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, и <xref:System.Speech.Recognition.GrammarBuilder> объектов.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует другой тип в <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр класса <xref:System.Speech.Recognition.GrammarBuilder>. Каждый из следующих классов можно привести <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Каждый из неявного приведения эквивалентно вызову конструктора.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Набор вариантов для преобразования.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.Choices" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.Choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр класса <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указав `choices` для `alternateChoices`.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать ответ «Да» или «no» вопрос. Оператор неявного преобразования, используемый при построении <xref:System.Speech.Recognition.SemanticResultValue> объекта из <xref:System.Speech.Recognition.Choices> объекта, при построении <xref:System.Speech.Recognition.Choices> объект из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и при построении <xref:System.Speech.Recognition.Grammar> объект из <xref:System.Speech.Recognition.SemanticResultKey> объекта.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Семантический ключ для преобразования.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.SemanticResultKey" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.SemanticResultKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр класса <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указав `semanticKey` для `key`.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать ответ «Да» или «no» вопрос. Оператор неявного преобразования, используемый при построении <xref:System.Speech.Recognition.SemanticResultValue> объекта из <xref:System.Speech.Recognition.Choices> объекта, при построении <xref:System.Speech.Recognition.Choices> объект из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и при построении <xref:System.Speech.Recognition.Grammar> объект из <xref:System.Speech.Recognition.SemanticResultKey> объекта.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Преобразуемый объект <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.SemanticResultValue" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр класса <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указав `semanticValue` для `value`.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается грамматику распознавания речи, который может распознать ответ «Да» или «no» вопрос. Оператор неявного преобразования, используемый при построении <xref:System.Speech.Recognition.SemanticResultValue> объекта из <xref:System.Speech.Recognition.Choices>объекта, при построении <xref:System.Speech.Recognition.Choices> объект из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и при построении <xref:System.Speech.Recognition.Grammar> объект из <xref:System.Speech.Recognition.SemanticResultKey> объекта.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Преобразуемая строка.</param>
        <summary>Преобразует строку в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованная строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр класса <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указав те же `phrase`.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере используется <xref:System.Speech.Recognition.GrammarBuilder> и <xref:System.Speech.Recognition.Choices> объекты для создания грамматики, который может распознать одно из двух фразы «фон *colorChoice*"или «Меняем цвет фона на *colorChoice*".  
  
 После создания списка допустимых значений для *colorChoice* с помощью <xref:System.Speech.Recognition.Choices> объекта, в примере инициализируются два <xref:System.Speech.Recognition.GrammarBuilder> объектов, `makePhrase` и `setPhrase`, с правилами неявного преобразования из строки объекты.  
  
 Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.Choices> объект приведен к <xref:System.Speech.Recognition.GrammarBuilder> объекта.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>