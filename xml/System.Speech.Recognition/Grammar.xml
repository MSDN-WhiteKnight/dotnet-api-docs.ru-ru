<Type Name="Grammar" FullName="System.Speech.Recognition.Grammar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a458e67e335f73937a0210d9c8409b90846e104f" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57962944" /></Metadata><TypeSignature Language="C#" Value="public class Grammar" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Grammar extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.Grammar" />
  <TypeSignature Language="VB.NET" Value="Public Class Grammar" />
  <TypeSignature Language="C++ CLI" Value="public ref class Grammar" />
  <TypeSignature Language="F#" Value="type Grammar = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Grammar: {(_uri != null ? "uri=" + _uri.ToString () + " " : "") + "rule=" + _ruleName }")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Объект времени выполнения, который ссылается на грамматика распознавания речи, которые приложение может использовать для определения ограничений для распознавания речи.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Грамматики распознавания речи — это набор правил или ограничений, которые определяют, в обработчик распознавания речи может распознать как значимые входные данные. Дополнительные сведения о создании и использовании грамматиками распознавания речи см. в разделе [распознавания речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)), [Создание XML с помощью грамматик](https://msdn.microsoft.com/library/2d799487-49c6-4cc9-b42f-f71cd3824fe1), [создание грамматики с помощью GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae), и [создавать грамматики, с помощью SrgsGrammar](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361680(v%3doffice.14)).  
  
 После создания грамматику, необходимо создать его в <xref:System.Speech.Recognition.Grammar> объекта, что можно загрузить в обработчик распознавания речи и что приложение может использовать во время выполнения для управления распознавания речи. Можно использовать <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор для создания <xref:System.Speech.Recognition.Grammar> экземпляра из <xref:System.Speech.Recognition.GrammarBuilder> или <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> объекта, или из файла или <xref:System.IO.Stream> , содержащее описание грамматики в поддерживаемом формате. Ниже приведены поддерживаемые форматы:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Грамматика конструкторы, принимающие файлы грамматики XML-формата в своих аргументах компиляции грамматики XML в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Приложения распознавания речи, управляются <xref:System.Speech.Recognition.SpeechRecognizer> или <xref:System.Speech.Recognition.SpeechRecognitionEngine> объекта, можно загрузить несколько грамматик распознавания речи. Приложения независимо друг от друга можно включить или отключить отдельные грамматики, задав <xref:System.Speech.Recognition.Grammar.Enabled%2A> свойство и изменение поведения распознавания через <xref:System.Speech.Recognition.Grammar> свойства, такие как <xref:System.Speech.Recognition.Grammar.Priority%2A> и <xref:System.Speech.Recognition.Grammar.Weight%2A> свойства.  
  
 Грамматика <xref:System.Speech.Recognition.Grammar.SpeechRecognized> событие возникает, когда входные данные соответствуют путь через грамматики.  
  
> [!NOTE]
>  Это лучший способ проверить безопасность любого URI или библиотеку DLL, используемую для создания <xref:System.Speech.Recognition.Grammar> объекта.  
>   
>  Windows и в платформу речи, обеспечивают безопасность для приложений, создав <xref:System.Speech.Recognition.Grammar> экземпляр из библиотеки DLL или из грамматику, которая поддерживает создание сценариев.  
>   
>  Скрипты в <xref:System.Speech.Recognition.Grammar> объекты всегда выполняются так, как если бы загрузить с веб-страницы в `Internet Zone`. Common Language Runtime (CLR) изолирует любой библиотеки DLL, загруженной для получения определения грамматики.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Speech.Recognition.Grammar> объект из грамматику распознавания речи, определенные в XML-файл (cities.xml). Содержимое файла cities.xml отображается в следующем примере XML.  
  
```csharp  
// Load a cities grammar from a local file and return the grammar object.   
private static Grammar CreateGrammarFromFile()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml");  
  citiesGrammar.Name = "SRGS File Cities Grammar";  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
    <altmember cref="T:System.Speech.Recognition.GrammarBuilder" />
    <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
    <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор для создания <xref:System.Speech.Recognition.Grammar> экземпляра из <xref:System.Speech.Recognition.GrammarBuilder> или <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> объекта, или из файла или <xref:System.IO.Stream> , содержащее описание грамматики в поддерживаемом формате. Ниже приведены поддерживаемые форматы:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Грамматика конструкторы, принимающие файлы грамматики XML-формата в своих аргументах компиляции грамматики XML в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Грамматики распознавания речи можно определить корневое правило. Чтобы создать <xref:System.Speech.Recognition.Grammar> , указывающий, какое правило для использования в качестве его корневое правило, использовать конструктор, принимающий `ruleName` параметра.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> , указывающий базовый URI для разрешения относительных ссылок на правила, используйте конструктор, принимающий `baseUri` параметра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Grammar ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Grammar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, описывающий грамматику для распознавания речи в поддерживаемом формате.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, любые параметры, и описание не следует определять обработчик инициализации, который требует аргументов.  
  
 Этот конструктор можно создать <xref:System.Speech.Recognition.Grammar> экземпляр из следующих форматов:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Этот конструктор компилирует файлы грамматики XML-формата в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Грамматику SRGS можно определить корневое правило. Чтобы создать <xref:System.Speech.Recognition.Grammar> из потока и указать корневое правило, использовать <xref:System.Speech.Recognition.Grammar.%23ctor%2A> или <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> из потока и указать базовый URI, используемый для разрешения относительных ссылок на правила, используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи из локального SRGS файла (cities.xml), используя файловый поток. Содержимое файла cities.xml отображается в следующем примере C#.  
  
```csharp  
  
// Load a cities grammar from an I/O stream and    
// return the new grammar.   
private static Grammar CreateGrammarFromStream()  
{  
  string fileName = @"c:\temp\cities.xml";  
  Grammar citiesGrammar =  
    new Grammar(new FileStream(fileName, FileMode.Open));  
  citiesGrammar.Name = "Stream Cities Grammar";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> описывает грамматику, которая не содержит корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Поток не содержит допустимого описания грамматики или не описывает грамматику, содержащую ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar builder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Экземпляр <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий ограничения для грамматики распознавания речи.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из объекта <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об использовании <xref:System.Speech.Recognition.GrammarBuilder> класс определяет грамматику, см. в разделе [создание грамматики с помощью GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 В следующем примере создается в грамматики распознавания речи с помощью <xref:System.Speech.Recognition.Choices> и <xref:System.Speech.Recognition.GrammarBuilder> объектов. <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Конструктор создает <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.GrammarBuilder> объекта.  
  
```csharp  
  
// Create a grammar using a GrammarBuilder and return the new grammar.   
private static Grammar CreateGrammarBuilderGrammar()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  
  Choices cityChoice = new Choices (new string[]   
  {"Seattle", "New York", "Miami", "Los Angeles"});  
  
  builder.Append("I would like to fly from");  
  builder.Append(cityChoice);  
  builder.Append("to");  
  builder.Append(cityChoice);  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "GrammarBuilder Cities Grammar";  
  
  return citiesGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar srgsDocument" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">Ограничения для грамматики распознавания речи.</param>
        <summary>Инициализируется новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из объекта <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, все параметры и <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> не должны содержать обработчик инициализации, который требует аргументов.  
  
 Объект <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> может иметь корневое правило. Чтобы создать <xref:System.Speech.Recognition.Grammar> , указывающий корневое правило, использование <xref:System.Speech.Recognition.Grammar.%23ctor%2A> или <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
 Чтобы создать распознавания речи <xref:System.Speech.Recognition.Grammar> из <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> и указать базовый URI, используемый для разрешения относительных ссылок на правила, используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи в <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> экземпляр, который затем используется для создания <xref:System.Speech.Recognition.Grammar> объекта.  
  
```csharp  
private static Grammar CreateSrgsDocumentGrammar()  
{  
  // Create the SrgsDocument.  
  SrgsDocument document = new SrgsDocument();  
  
  // Create the Cities rule and add it to the document.  
  SrgsRule citiesRule = new SrgsRule("Cities");  
  
  SrgsOneOf cityChoice = new SrgsOneOf();  
  cityChoice.Add(new SrgsItem("Seattle"));  
  cityChoice.Add(new SrgsItem("Los Angeles"));  
  cityChoice.Add(new SrgsItem("New York"));  
  cityChoice.Add(new SrgsItem("Miami"));  
  
  citiesRule.Add(cityChoice);  
  document.Rules.Add(citiesRule);  
  
  // Create the Main rule and add it to the document.  
  SrgsRule mainRule = new SrgsRule("Main");  
  mainRule.Scope = SrgsRuleScope.Public;  
  
  SrgsItem item = new SrgsItem("I would like to fly from");  
  item.Add(new SrgsRuleRef(citiesRule));  
  item.Add(new SrgsText("to"));  
  item.Add(new SrgsRuleRef(citiesRule));  
  
  mainRule.Add(item);  
  document.Rules.Add(mainRule);  
  
  // Set the root rule.  
  document.Root = mainRule;  
  
  // Create the Grammar object.  
  Grammar citiesGrammar = new Grammar(document);  
  citiesGrammar.Name = "SrgsDocument Cities Grammar";  
  
  return citiesGrammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="srgsDocument" /> не содержит корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> содержит ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу, описывающему грамматику для распознавания речи в поддерживаемом формате.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, любые параметры, и описание не следует определять обработчик инициализации, который требует аргументов.  
  
 Этот конструктор можно создать <xref:System.Speech.Recognition.Grammar> экземпляр из следующих форматов:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Этот конструктор компилирует файлы грамматики XML-формата в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Грамматику SRGS можно определить корневое правило. Чтобы создать <xref:System.Speech.Recognition.Grammar> из строки и указать корневое правило, используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> , указывающий базовый URI, используемый для разрешения относительных ссылок на правила, откройте файл в файловый поток и используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A?displayProperty=nameWithType> конструктор.  
  
   
  
## Examples  
 В следующем примере загружаются грамматики распознавания речи из локального файла SRGS для построения <xref:System.Speech.Recognition.Grammar> объекта. Содержимое файла cities.xml отображается в примере C# в следующем примере XML.  
  
```csharp  
// Load a cities grammar from a local file and  
// return the new grammar.   
private static Grammar CreateGrammarFromFile()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml");  
  citiesGrammar.Name = "SRGS File Cities Grammar";  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> содержит пустую строку ("") или файл описывает грамматику, которая не содержит корневого правила.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Файл не содержит допустимого описания или не описывает грамматику, содержащую ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, описывающий грамматику для распознавания речи в поддерживаемом формате.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из <see cref="T:System.IO.Stream" /> и указывает корневое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, любые параметры, и описание не следует определять обработчик инициализации, который требует аргументов.  
  
 Этот конструктор можно создать <xref:System.Speech.Recognition.Grammar> экземпляр из следующих форматов:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Этот конструктор компилирует файлы грамматики XML-формата в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> из потока и указать базовый URI, используемый для разрешения относительных ссылок на правила, используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере загружает в локальный файл SRGS (cities.xml) из файлового потока и задает правила для использования в качестве корневого элемента грамматики. Содержимое файла cities.xml отображается в примере C# в следующем примере XML.  
  
```csharp  
  
// Load a cities grammar from an I/O stream, use a specific  
// rule as the root of the grammar, and return the new grammar.   
private static Grammar CreateGrammarFromStream2()  
{  
  FileInfo file = new FileInfo(@"c:\temp\cities.xml");  
  Grammar citiesGrammar = new Grammar(file.OpenRead(), "Main");  
  citiesGrammar.Name = "Stream Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно разрешить <paramref name="ruleName" /> или оно не является открытым или <paramref name="ruleName" /> — <see langword="null" /> и грамматическое описание не определяет корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Поток не содержит допустимого описания или не описывает грамматику, содержащую ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">Ограничения для грамматики распознавания речи.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />.</param>
        <summary>Инициализирует новый экземпляр объекта <see cref="T:System.Speech.Recognition.Grammar" /> из <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> и указывает корневое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, все параметры и <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> не должны содержать обработчик инициализации, который требует аргументов.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> и указать базовый URI, используемый для разрешения относительных ссылок на правила, используйте <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи в <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> экземпляра и указывает правило для использования в качестве корневого правила грамматики. В примере создается <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> экземпляра и загружает их в обработчик распознавания речи.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
using System.Speech.Recognition.SrgsGrammar;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create the SrgsDocument.  
        SrgsDocument document = new SrgsDocument();  
  
        // Create the Cities rule and add it to the document.  
        SrgsRule citiesRule = new SrgsRule("Cities");  
        citiesRule.Scope = SrgsRuleScope.Public;  
  
        SrgsOneOf cityChoice = new SrgsOneOf();  
        cityChoice.Add(new SrgsItem("Seattle"));  
        cityChoice.Add(new SrgsItem("Los Angeles"));  
        cityChoice.Add(new SrgsItem("New York"));  
        cityChoice.Add(new SrgsItem("Miami"));  
  
        citiesRule.Add(cityChoice);  
        document.Rules.Add(citiesRule);  
  
        // Create the Main rule and add it to the document.  
        SrgsRule mainRule = new SrgsRule("Main");  
        mainRule.Scope = SrgsRuleScope.Public;  
  
        mainRule.Add(new SrgsItem("I would like to fly from"));  
        mainRule.Add(new SrgsRuleRef(citiesRule));  
        mainRule.Add(new SrgsItem("to"));  
        mainRule.Add(new SrgsRuleRef(citiesRule));  
  
        document.Rules.Add(mainRule);  
  
        // Create the Grammar object and specify which rule to use as the root.  
        Grammar citiesGrammar = new Grammar(document,"Main");  
  
        // Load the grammar object to the recognizer.  
        recognizer.LoadGrammarAsync(citiesGrammar);  
  
        // Attach a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=  
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Set the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Start recognition.  
        recognizer.RecognizeAsync();  
        Console.WriteLine("Starting aynchronous recognition...");  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("  Speech recognized: " + e.Result.Text);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно разрешить <paramref name="ruleName" /> или оно не является открытым или <paramref name="ruleName" /> — <see langword="null" /> и <paramref name="srgsDocument" /> не содержит корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> содержит ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, ruleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (path, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу, описывающему грамматику для распознавания речи в поддерживаемом формате.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из файла и указывает корневое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, любые параметры, и описание не следует определять обработчик инициализации, который требует аргументов.  
  
 Этот конструктор можно создать <xref:System.Speech.Recognition.Grammar> экземпляр из следующих форматов:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Этот конструктор компилирует файлы грамматики XML-формата в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Чтобы создать <xref:System.Speech.Recognition.Grammar> , указывающий базовый URI, используемый для разрешения относительных ссылок на правила, открыть поток файлов для файла и использовать <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере загружается из файла локального файла SRGS (cities.xml) и указывает правила для использования в качестве корневого элемента грамматики. Содержимое файла cities.xml отображается в примере C# в следующем примере XML.  
  
```csharp  
  
// Load a cities grammar from a local file, use a specific  
// rule as the root of the grammar, and return the new grammar.  
private static Grammar CreateGrammarFromFile2()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml", "Main");  
  citiesGrammar.Name = "SRGS File Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно разрешить <paramref name="ruleName" /> или оно не является открытым или <paramref name="path" /> является пустой строкой (""), или <paramref name="ruleName" /> — <see langword="null" />и грамматическое описание не определяет корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Файл не содержит допустимого описания или не описывает грамматику, содержащую ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, подключенный к объекту ввода/вывода (включая файлы, ресурсы Visual Studio и DLL-библиотеки), который содержит грамматическую спецификацию.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="parameters">Параметры, передаваемые обработчику инициализации, указанному свойством <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> для точки входа или корневого правила создаваемого объекта <see cref="T:System.Speech.Recognition.Grammar" />. Параметр может принимать значение NULL.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из <see cref="T:System.IO.Stream" /> и указывает корневое правило.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Также можно указать параметры для инициализации обработчика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> подключен к грамматике, которая: 
– не содержит правила, указанного в <paramref name="ruleName" />;  
  
– требует параметры инициализации отличающиеся от тех, которые определены в <paramref name="parameters" />;  
  
– содержит относительную ссылку на правило, которая не может быть разрешена базовым правилом <see cref="T:System.Uri" /> по умолчанию для грамматик.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, Uri baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, class System.Uri baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, Uri ^ baseUri);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * Uri -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, baseUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, описывающий грамматику для распознавания речи в поддерживаемом формате.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="baseUri">Базовый универсальный код ресурса (uri), используемый для разрешения любых относительную ссылок на правила в описании грамматики или <see langword="null" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из потока, определяет корневое правило и определяет базовый универсальный идентификатор ресурса (URI) для разрешения относительных ссылок на правила.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, любые параметры, и описание не следует определять обработчик инициализации, который требует аргументов.  
  
 Этот конструктор можно создать <xref:System.Speech.Recognition.Grammar> экземпляр из следующих форматов:  
  
-   Файлы XML-формата, которые соответствуют W3C [спецификации грамматики распознавания речи (SRGS) версии 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Грамматики, которые были скомпилированы в двоичный файл с расширением .cfg  
  
 Этот конструктор компилирует файлы грамматики XML-формата в двоичный формат, чтобы оптимизировать их для загрузки и использования обработчиком распознавания речи. Можно уменьшить количество времени, необходимый для создания <xref:System.Speech.Recognition.Grammar> объекта из XML-формата грамматики путем компиляции грамматики заранее, с помощью одного из <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> методы.  
  
 Этот конструктор не проверяет `baseUri`. Тем не менее `LoadGrammar` метод <xref:System.Speech.Recognition.SpeechRecognitionEngine> или <xref:System.Speech.Recognition.SpeechRecognizer> объекта вызывает исключение, если он не может разрешить все ссылки на правила в описании грамматики. Если `baseUri` не `null`, `LoadGrammar` метод использует URI для разрешения ссылок на любые правила, которые в противном случае он не может разрешить. Если `baseUri` представляет файл, а затем `LoadGrammar` использует заданный файл и каталог файлов, когда он пытается разрешить относительных ссылок на правила.  
  
   
  
## Examples  
 Следующий пример загружает в локальный файл SRGS (shuttle.xml) из потока файла. Файл содержит относительную ссылку правила для правила в файле cities.xml и задает базовый URI для разрешения ссылок на правила. Содержимое файлов shuttle.xml и cities.xml отображается в примерах XML ниже в примере C#.  
  
```csharp  
  
private static Grammar CreateGrammarFromStream3()  
{  
  FileInfo file = new FileInfo(@".\shuttle.xml");  
  Uri baseUri = new Uri(@"file://c:\temp\");  
  Grammar citiesGrammar = new Grammar(file.OpenRead(), null, baseUri);  
  citiesGrammar.Name = "Stream Cities Grammar 3";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- shuttle.xml:   
    Defines an SRGS grammar for asking about a shuttle service. This grammar  
    references a Cities rule that is defined in the cities.xml grammar. -->  
  
  <rule id="Main">  
    <item>  
      Can I get a shuttle in  
      <ruleref uri="cities.xml#Cities"/>  
    </item>  
  </rule>  
</grammar>  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно разрешить <paramref name="ruleName" /> или оно не является открытым или <paramref name="ruleName" /> — <see langword="null" /> и грамматическое описание не определяет корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Поток не содержит допустимого описания или не описывает грамматику, содержащую ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">Экземпляр <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, содержащий ограничения для грамматики распознавания речи.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="parameters">Параметры, передаваемые обработчику инициализации, указанному свойством <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> для точки входа или корневого правила создаваемого объекта <see cref="T:System.Speech.Recognition.Grammar" />. Параметр может принимать значение NULL.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из экземпляра <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, указывает имя правила, которое должно функционировать как точка входа в грамматику.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Также можно указать параметры для инициализации обработчика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один из параметров содержит недопустимое значение.  
  
<see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, указанный <paramref name="srgsDocument" />, не содержит правила, заданного параметром <paramref name="ruleName" />.  
  
Содержимое параметров массива не соответствует аргументам любого из обработчиков инициализации правила.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, Uri baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, class System.Uri baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, Uri ^ baseUri);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * Uri -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, baseUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">Ограничения для грамматики распознавания речи.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />.</param>
        <param name="baseUri">Базовый универсальный код ресурса (uri), используемый для разрешения любых относительную ссылок на правила в <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> или <see langword="null" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из объекта <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, определяет корневое правило и определяет базовый универсальный идентификатор ресурса (URI) для разрешения относительных ссылок на правила.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не передает обработчику инициализации, все параметры и <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> не должны содержать обработчик инициализации, который требует аргументов.  
  
 Этот конструктор не проверяет `baseUri`. Тем не менее `LoadGrammar` метод <xref:System.Speech.Recognition.SpeechRecognitionEngine> или <xref:System.Speech.Recognition.SpeechRecognizer> объекта вызывает исключение, если он не может разрешить все ссылки на правила в описании грамматики. Если `baseUri` не `null`, `LoadGrammar` метод использует URI для разрешения ссылок на любые правила, которые в противном случае он не может разрешить. Если `baseUri` представляет файл, а затем `LoadGrammar` метод использует заданный файл и каталог файлов, когда он пытается разрешить относительных ссылок на правила.  
  
   
  
## Examples  
 В следующем примере создается грамматики распознавания речи в <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> содержит относительную ссылку правила в файле cities.xml и указывает URI, используемый для разрешения ссылок на правила. Содержимое файла cities.xml отображается в примере C# в следующем примере XML.  
  
```csharp  
  
private static Grammar CreateSrgsDocumentGrammar3()  
{  
  // Create the SrgsDocument.  
  SrgsDocument document = new SrgsDocument();  
  
  // Create the Main rule and add it to the document.  
  SrgsRule mainRule = new SrgsRule("Main");  
  mainRule.Scope = SrgsRuleScope.Public;  
  
  SrgsItem item = new SrgsItem("Can I get a shuttle in");  
  
  // Create a relative URI for the cities rule.  
  Uri ruleUri = new Uri("cities.xml#Cities", UriKind.Relative);  
  
  item.Add(new SrgsRuleRef(ruleUri));  
  
  mainRule.Add(item);  
  document.Rules.Add(mainRule);  
  
  // Set the root rule.  
  document.Root = mainRule;  
  
  // Create the grammar.  
  Uri baseUri = new Uri(@"file://c:\temp\");  
  Grammar citiesGrammar = new Grammar(document, null, baseUri);  
  citiesGrammar.Name = "SrgsDocument Cities Grammar 3";  
  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно разрешить <paramref name="ruleName" /> или оно не является открытым или <paramref name="ruleName" /> — <see langword="null" /> и <paramref name="srgsDocument" /> не содержит корневое правило.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> содержит ссылку на правило, которая не может быть разрешена.</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, ruleName As String, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (path, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу, включая библиотеки DLL, который содержит грамматическую спецификацию.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="parameters">Параметры, передаваемые обработчику инициализации, указанному свойством <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> для точки входа или корневого правила создаваемого объекта <see cref="T:System.Speech.Recognition.Grammar" />. Параметр может принимать значение NULL.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из файла, содержащего определение грамматики, и указывает имя правила, которое должно функционировать как точка входа в грамматику.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Также можно указать параметры для инициализации обработчика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один из параметров содержит недопустимое значение.  
  
Файл, указанный в <paramref name="path" />, не содержит допустимую грамматику или правило, определенное в <paramref name="ruleName" />.  
  
Содержимое параметров массива не соответствует аргументам любого из обработчиков инициализации правила.  
  
Грамматика содержит относительную ссылку на правило, которая не может быть разрешена базовым правилом <see cref="T:System.Uri" /> по умолчанию для грамматик.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, Uri baseUri, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, class System.Uri baseUri, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Uri,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, Uri ^ baseUri, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * Uri * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, baseUri, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, подключенный к объекту ввода/вывода (включая файлы, ресурсы Visual Studio и DLL-библиотеки), который содержит грамматическую спецификацию.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="baseUri">Базовый универсальный код ресурса (uri), используемый для разрешения любых относительную ссылок на правила в описании грамматики или <see langword="null" />.</param>
        <param name="parameters">Параметры, передаваемые обработчику инициализации, указанному свойством <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> для точки входа или корневого правила создаваемого объекта <see cref="T:System.Speech.Recognition.Grammar" />. Параметр может принимать значение NULL.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> для <see cref="T:System.IO.Stream" /> и определяет корневое правило и базовый код URI для разрешения относительных ссылок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Также можно указать параметры для инициализации обработчика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один из параметров содержит недопустимое значение.  
  
<paramref name="stream" /> подключен к грамматике, которая не содержит правило, определенное в <paramref name="ruleName" />.  
  
Содержимое параметров массива не соответствует аргументам любого из обработчиков инициализации правила.  
  
Грамматика содержит относительную ссылку на правило, которая не может быть разрешена базовым правилом <see cref="T:System.Uri" /> по умолчанию для грамматик или URI-адресом, заданным в <paramref name="baseUri" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, Uri baseUri, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, class System.Uri baseUri, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Uri,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, Uri ^ baseUri, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * Uri * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, baseUri, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">Экземпляр <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, содержащий ограничения для грамматики распознавания речи.</param>
        <param name="ruleName">Идентификатор правила для использования в качестве точки входа грамматики распознавания речи или значение <see langword="null" />, чтобы использовать корневое правило по умолчанию описания грамматики.</param>
        <param name="baseUri">Базовый универсальный код ресурса (uri), используемый для разрешения любых относительную ссылок на правила в описании грамматики или <see langword="null" />.</param>
        <param name="parameters">Параметры, передаваемые обработчику инициализации, указанному свойством <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> для точки входа или корневого правила создаваемого объекта <see cref="T:System.Speech.Recognition.Grammar" />. Этот параметр может быть нулевым.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.Grammar" /> из экземпляра <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, указывает имя правила, которое должно функционировать как точка входа в грамматику, и базовый URI для разрешения относительных ссылок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Также можно указать параметры для инициализации обработчика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один из параметров содержит недопустимое значение.  
  
<see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />, указанный <paramref name="srgsDocument" />, не содержит правила, заданного в <paramref name="ruleName" />.  
  
Содержимое параметров массива не соответствует аргументам любого из обработчиков инициализации правила.  
  
Грамматика содержит относительную ссылку на правило, которая не может быть разрешена базовым правилом <see cref="T:System.Uri" /> по умолчанию для грамматик или URI-адресом, заданным в <paramref name="baseUri" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Speech.Recognition.Grammar.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое определяет, может ли <see cref="T:System.Speech.Recognition.Grammar" /> использоваться распознавателем речи для выполнения распознавания.</summary>
        <value><see langword="Enabled" /> Возвращает <see langword="true" /> Если распознаватель речи может выполнять распознавание с использованием грамматики распознавания речи; в противном случае возвращается <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.Speech.Recognition.Grammar> может включать или отключать независимо от загрузки механизмом распознавания речи.  
  
   
  
## Examples  
 Следующий пример записывает сведения о <xref:System.Speech.Recognition.Grammar> объект [консоли](https://go.microsoft.com/fwlink/?LinkId=159613).  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">Спецификации грамматики распознавания речи</related>
      </Docs>
    </Member>
    <Member MemberName="IsStg">
      <MemberSignature Language="C#" Value="protected internal virtual bool IsStg { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStg" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.IsStg" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property IsStg As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool IsStg { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStg : bool" Usage="System.Speech.Recognition.Grammar.IsStg" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее является ли грамматика строго типизированной.</summary>
        <value>Свойство <see langword="IsStg" /> возвращает значение <see langword="true" />, если грамматика строго типизированная; в противном случае возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строго типизированный <xref:System.Speech.Recognition.Grammar> объекта (`IsStg` равно `true`) могут возвращать результаты, со строгой типизацией (объектов вместо необработанного текста) в клиентское приложение. Например, может возвращать строго типизированную грамматику <xref:System.DateTime> объектов вместо необработанных распознанных входных данных.  
  
 Вы можете реализовать строго типизированных грамматик, подключив кода правилам грамматики. Как механизма распознавания обрабатывает любые правила, ведения как входные текущего частичных результатов, выполняется соответствующий код и текстовой информации становится форматированного типа объектов. Это позволяет клиенту, чтобы проще использовать улучшенные семантической проверки, поддержка нескольких языков и региональных параметров и грамматики внутренней логики.  
  
 Экземпляры со строгой типизацией <xref:System.Speech.Recognition.Grammar> объектов обычно получаются из ресурсов в сборке как <xref:System.Type> из Common Language Runtime (CLR). Локализованные типы, используемые для поддержки различных языков приведены примеры таких <xref:System.Speech.Recognition.Grammar> объектов.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Строго типизированных грамматик, наследование <see cref="T:System.Speech.Recognition.Grammar" /> , необходимо переопределить поведение по умолчанию <see langword="IsStg" />, который является возврат <see langword="false" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public bool Loaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Loaded" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Loaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Loaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Loaded : bool" Usage="System.Speech.Recognition.Grammar.Loaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее загружен ли объект <see cref="T:System.Speech.Recognition.Grammar" /> распознавателем речи.</summary>
        <value>Свойство <see langword="Loaded" /> возвращает <see langword="true" />, если указанная грамматика распознавания речи в данный момент загружена в распознаватель речи; в противном случае возвращается значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Один раз <xref:System.Speech.Recognition.Grammar> загрузки, значения <xref:System.Speech.Recognition.Grammar.Weight%2A>, и <xref:System.Speech.Recognition.Grammar.Priority%2A> не может быть изменено.  
  
   
  
## Examples  
 Следующий пример записывает сведения о <xref:System.Speech.Recognition.Grammar> объект [консоли](https://go.microsoft.com/fwlink/?LinkId=159613).  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="LoadLocalizedGrammarFromType">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.Grammar LoadLocalizedGrammarFromType (Type type, params object[] onInitParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.Grammar LoadLocalizedGrammarFromType(class System.Type type, object[] onInitParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.LoadLocalizedGrammarFromType(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::Grammar ^ LoadLocalizedGrammarFromType(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ onInitParameters);" />
      <MemberSignature Language="F#" Value="static member LoadLocalizedGrammarFromType : Type * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="System.Speech.Recognition.Grammar.LoadLocalizedGrammarFromType (type, onInitParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.Grammar</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="onInitParameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">В сборке <see cref="T:System.Type" /> объекта, основанного на <see cref="T:System.Speech.Recognition.Grammar" />.</param>
        <param name="onInitParameters">Параметры для передачи в метод инициализации локализованного объекта на основе <see cref="T:System.Speech.Recognition.Grammar" />. Параметр может принимать значение NULL.</param>
        <summary>Метод <see langword="LoadLocalizedGrammarFromType" /> возвращает локализованный экземпляр объекта <see cref="T:System.Speech.Recognition.Grammar" />, который является наследником <see cref="T:System.Type" />.</summary>
        <returns>Метод <see langword="LoadLocalizedGrammarFromType" /> возвращает допустимый объект на основе <see cref="T:System.Speech.Recognition.Grammar" /> или <see langword="null" />, если возникла ошибка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Локализованные грамматики, полученное с `LoadLocalizedGrammarFromType` обычно со строгой типизацией (см. в разделе <xref:System.Speech.Recognition.Grammar.IsStg%2A> Дополнительные сведения о строго типизированных грамматик). Если `onInitParameters` является пустой ссылкой (Nothing в Visual Basic), локализованной грамматики должен иметь метод инициализации отсутствует, или метод, который не принимает аргументы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Speech.Recognition.Grammar.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя объекта <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <value>Свойство <see langword="Name" />, возвращает имя объекта <see cref="T:System.Speech.Recognition.Grammar" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается два <xref:System.Speech.Recognition.Grammar> объектов, одна для цифр и одна для дробей. Грамматика объекты являются присвоения имен и относительный вес и приоритеты, а также загрузки в распознаватель речи внутри процесса. `CreateDigitsGrammar`, `CreateFractionsGrammar`, И `recognizer_SpeechRecognized` методы здесь не показаны.  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public int Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Priority" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Priority { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : int with get, set" Usage="System.Speech.Recognition.Grammar.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение приоритета объекта <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <value>Свойство <see langword="Priority" /> возвращает целое значение, представляющее относительный приоритет конкретной грамматики <see cref="T:System.Speech.Recognition.Grammar" />. Диапазон от -128 до 127 включительно. Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Priority` Свойство используется для выбора грамматику, когда несколько грамматики будет выдавать результаты идентичны распознавания. Если распознаватель речи имеет более одной грамматики распознавания речи загружается и включена, в соответствии с входными данными, и соответствие наилучший результат из распознавателя, то распознаватель использует грамматику, которая максимальные `Priority`. Если грамматики, которые приводят к результату идентичные распознавания также имеют одинаковые `Priority` значение, а затем грамматику, которая использует распознаватель не определено.  
  
   
  
## Examples  
 В следующем примере создается два <xref:System.Speech.Recognition.Grammar> объектов, одна для цифр и одна для дробей. <xref:System.Speech.Recognition.Grammar> Объекты являются присвоения имен и относительный вес и приоритеты, а также загрузки в распознаватель речи внутри процесса. `CreateDigitsGrammar`, `CreateFractionsGrammar`, И `recognizer_SpeechRecognized` методы здесь не показаны.  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Weight" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="ResourceName">
      <MemberSignature Language="C#" Value="protected string ResourceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResourceName" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.ResourceName" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResourceName As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::String ^ ResourceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceName : string with get, set" Usage="System.Speech.Recognition.Grammar.ResourceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение с именем двоичного ресурса, который использовался для загрузки текущего <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <value>Свойство <see langword="ResourceName" /> возвращает имя двоичного ресурса, из которого была загружена строго типизированная грамматика, используемая объектом <see cref="T:System.Speech.Recognition.Grammar" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuleName">
      <MemberSignature Language="C#" Value="public string RuleName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RuleName" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.RuleName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RuleName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RuleName : string" Usage="System.Speech.Recognition.Grammar.RuleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя корневого правила или точки входа объекта <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <value>Свойство <see langword="RuleName" /> возвращает идентификатор для корневого правила грамматики распознавания речи, на которую стоит ссылка. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания <xref:System.Speech.Recognition.Grammar> и задайте имя для своего правила корневого, используйте один из <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструкторов, принимающих `ruleName` параметра.  
  
 Если корневое правило <xref:System.Speech.Recognition.Grammar> не имеет имени, свойство возвращает `null`.  
  
 Правила корневого <xref:System.Speech.Recognition.Grammar> создании экземпляров из <xref:System.Speech.Recognition.GrammarBuilder> объекты обычно имеют без имени, поэтому <xref:System.Speech.Recognition.Grammar.RuleName%2A> возвращает `null`.  
  
   
  
## Examples  
 Следующий пример записывает сведения о <xref:System.Speech.Recognition.Grammar> объект [консоли](https://go.microsoft.com/fwlink/?LinkId=159613).  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream)" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="SpeechRecognized">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; SpeechRecognized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Recognition.SpeechRecognizedEventArgs&gt; SpeechRecognized" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Recognition.Grammar.SpeechRecognized" />
      <MemberSignature Language="VB.NET" Value="Public Event SpeechRecognized As EventHandler(Of SpeechRecognizedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Recognition::SpeechRecognizedEventArgs ^&gt; ^ SpeechRecognized;" />
      <MemberSignature Language="F#" Value="member this.SpeechRecognized : EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; " Usage="member this.SpeechRecognized : System.EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда распознаватель речи выполняет распознавание с помощью объекта <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Распознаватель речи, также вызывает `SpeechRecognized` события при обнаружении входных данных. <xref:System.Speech.Recognition.Grammar> Объекта <xref:System.Speech.Recognition.Grammar.SpeechRecognized> события до распознаватель речи `SpeechRecognized` событий. Дополнительные сведения см. в разделе <xref:System.Speech.Recognition.SpeechRecognizer.SpeechRecognized?displayProperty=nameWithType>, <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized?displayProperty=nameWithType>, и <xref:System.Speech.Recognition.SpeechRecognitionEngine.RecognizeCompleted> события.  
  
 Все задачи, относящиеся к конкретной грамматики всегда должны обрабатываться обработчиками для <xref:System.Speech.Recognition.Grammar> объекта <xref:System.Speech.Recognition.Grammar.SpeechRecognized> событий.  
  
   
  
## Examples  
 В следующем примере показано использование обработчика событий для <xref:System.Speech.Recognition.Grammar> объекта <xref:System.Speech.Recognition.Grammar.SpeechRecognized> событий. Он выводит результат распознавания [консоли](https://go.microsoft.com/fwlink/?LinkId=159613).  
  
```csharp  
public partial class Form1 : Form  
{  
  SpeechRecognitionEngine sre;  
  
  public Form1()  
  {  
  InitializeComponent();  
  
  // Create an in-process speech recognizer.  
  sre = new SpeechRecognitionEngine();  
  
  // Configure input to the speech recognizer.  
  sre.SetInputToDefaultAudioDevice();  
  
  // Create a simple grammar and load it.  
  Grammar testGrammar = new Grammar(new GrammarBuilder("testing"));  
  sre.LoadGrammarAsync(testGrammar);  
  
  // Add a handler for the grammar's speech recognized event.  
  testGrammar.SpeechRecognized += new EventHandler<SpeechRecognizedEventArgs>(testGrammar_SpeechRecognized);  
  
  // Start asynchronous speech recognition.  
  sre.RecognizeAsync();  
  }  
  
  // Handle the grammar's SpeechRecognized event, output the recognized text.  
  void testGrammar_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
  {  
    Console.WriteLine("Recognized text: " + e.Result.Text);  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="StgInit">
      <MemberSignature Language="C#" Value="protected void StgInit (object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void StgInit(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.StgInit(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub StgInit (parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void StgInit(cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.StgInit : obj[] -&gt; unit" Usage="grammar.StgInit parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="parameters">Параметры для передачи с целью инициализации строго типизированной грамматики. Этот параметр может быть нулевым.</param>
        <summary>Метод <see langword="StgInit" /> инициализирует строго типизированную грамматику.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строго типизированный <xref:System.Speech.Recognition.Grammar> объекта (`IsStg` равно `true`) могут возвращать результаты, со строгой типизацией (объектов вместо необработанного текста) в клиентское приложение. Например, может возвращать строго типизированную грамматику <xref:System.DateTime> объектов вместо необработанных распознанных входных данных.  
  
 Вы можете реализовать строго типизированных грамматик, подключив кода правилам грамматики. Как механизма распознавания обрабатывает любые правила, ведения как входные текущего частичных результатов, выполняется соответствующий код и текстовой информации становится форматированного типа объектов. Это позволяет клиенту, чтобы проще использовать улучшенные семантической проверки, поддержка нескольких языков и региональных параметров и грамматики внутренней логики.  
  
 Экземпляры со строгой типизацией <xref:System.Speech.Recognition.Grammar> объектов обычно получаются из ресурсов в сборке как <xref:System.Type> из Common Language Runtime (CLR). Локализованные типы, используемые для поддержки различных языков приведены примеры таких <xref:System.Speech.Recognition.Grammar> объектов.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если для инициализации, требуется строго типизированную грамматику <see langword="StgInit" /> должны вызываться в конструктор или метод инициализации.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Weight">
      <MemberSignature Language="C#" Value="public float Weight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Weight" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Weight" />
      <MemberSignature Language="VB.NET" Value="Public Property Weight As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Weight { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.Weight : single with get, set" Usage="System.Speech.Recognition.Grammar.Weight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение веса объекта <see cref="T:System.Speech.Recognition.Grammar" />.</summary>
        <value><see langword="Weight" /> Возвращает свойство, с плавающей запятой значение, указывающее относительный вес, который экземпляр механизма распознавания должен присвоить грамматике при обработке речевой ввод. Диапазон — от 0,0 до 1,0 включительно. По умолчанию используется 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Из-за сложности использование механизма распознавания **вес**, не непосредственно как прогнозируемый, что и его влияние на скорость конкретной грамматики <xref:System.Speech.Recognition.Grammar.Priority%2A>.  
  
 Распознавание речи — это Взвешенное система. Она оценивает все возможные распознавания пути, на основе сочетания вес грамматики, задается для альтернативных вариантов в грамматике и определением модели речи вероятности. Распознавание речи использует сочетание этих весовые коэффициенты и вероятности для rank потенциальных альтернативные распознаваний. Грамматики с более высоким весом будет передавать сведения в ранжировании альтернативы распознавания, чем грамматики с низким весом.  
  
 Последствия <xref:System.Speech.Recognition.Grammar.Weight%2A> свойство в распознаватель речи зависят от реализации распознавателя. Несмотря на то что <xref:System.Speech.Recognition.Grammar.Weight%2A> свойство может использоваться для настройки точность распознавания речи для приложения, его следует использовать только после того, как управлять диагностики исследования распознавания конкретной среды и с полной информацией о модуль распознавания в списке.  
  
   
  
## Examples  
 В следующем примере создается два <xref:System.Speech.Recognition.Grammar> объектов, одна для цифр и одна для дробей. <xref:System.Speech.Recognition.Grammar> Объекты являются присвоения имен и относительный вес и приоритеты, а также загрузки в распознаватель речи внутри процесса. `CreateDigitsGrammar`, `CreateFractionsGrammar`, И `recognizer_SpeechRecognized` методы здесь не показаны.  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Priority" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
  </Members>
</Type>