<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d51d70444dab9462315feb569307240656b2446" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57961072" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Псевдослучайные числа выбираются с равной вероятностью из конечного набора чисел. Выбранные числа не являются полностью произвольным, так как математический алгоритм используется для выбора их, но они достаточно случайны с практической точки зрения. Текущая реализация <xref:System.Random> класс основан на измененной версии Дональд E. Кнута субтрактивным алгоритм генерации случайных чисел. Дополнительные сведения см. в разделе E. г. Кнута. *Искусство компьютерном программировании, том 2: Искусство*. Addison-Wesley, Reading, MA, third edition, 1997.  
  
 Для создания криптографически надежное случайное число, например, подходит для создания случайного пароля, используйте <xref:System.Security.Cryptography.RNGCryptoServiceProvider> класса или являются производными от класса <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 В этом разделе.  
  
 [Создание экземпляра генератора случайных чисел](#Instantiate)   
 [Как избежать создания нескольких экземпляров](#Multiple)   
 [Безопасность System.Random класс и потока](#ThreadSafety)   
 [Создание различных типов случайных чисел](#Functionality)   
 [Подстановка собственный алгоритм](#Overriding)   
 [Как использовать System.Random, чтобы...](#Operations)   
 [Получить ту же последовательность случайных значений](#Same)  
 [Получения уникальных последовательностей случайных значений](#Unique)  
 [Получить целых чисел в указанном диапазоне](#Range)  
 [Получить целых чисел с помощью указанного количества десятичных разрядов](#Digits)  
 [Извлечь значения с плавающей запятой в указанном диапазоне](#Floats)  
 [Сформировать произвольного логических значений](#Boolean)  
 [Сформировать произвольного 64-разрядных целых чисел](#Long)  
 [Получение байт в указанном диапазоне](#Bytes)  
 [Получить элемент из массива или коллекции в случайном порядке](#Array)  
 [Получить уникальный элемент из массива или коллекции](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Создание экземпляра генератора случайных чисел  
 Создать экземпляр генератора случайных чисел, предоставляя начальное значение (начальное значение для алгоритма формирования псевдослучайных чисел) для <xref:System.Random.%23ctor%2A> конструктора класса.  Можно указать начальное значение, явно или неявно:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Конструктор использует явного начального значения, которое вы указали.  
  
-   <xref:System.Random.%23ctor> Конструктор использует системные часы для обеспечения начального значения. Это наиболее распространенным способом создания генератора случайных чисел.  
  
 Если же начальное значение используется для отдельного <xref:System.Random> объекты, они получат те же серии случайных чисел. Это может быть полезно для создания набора тестов, который обрабатывает случайных значений, или воспроизведения игры, которые являются производными свои данные от случайных чисел. Тем не менее, обратите внимание, что <xref:System.Random> объектов в процессах, под управлением различных версий платформы .NET Framework, могут возвращать другая последовательность случайных чисел, даже если их все экземпляры с использованием идентичных начальных значений.  
  
 Для получения различных последовательностей случайных чисел, можно сделать начальное значение зависит от времени, что позволяет создавать различные последовательности для каждого нового экземпляра <xref:System.Random>. Параметризованного <xref:System.Random.%23ctor%28System.Int32%29> конструктор может занять <xref:System.Int32> значение на основе количества тактов в текущее время, тогда как без параметров <xref:System.Random.%23ctor> конструктор использует системные часы для создания начального значения. Тем не менее, так как часы конечное решение, с помощью конструктора без параметров для создания различных <xref:System.Random> объекты в быстрой последовательности создает генераторы случайных чисел, которые создают идентичные последовательности случайных чисел. В следующем примере показано как две <xref:System.Random> объекты, экземпляры которых создаются в быстрой последовательности, создают идентичные наборы случайных чисел. В большинстве систем Windows <xref:System.Random> объекты, создаваемые в 15 миллисекунд друг от друга, скорее всего, имеют одинаковые начальные значения.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Чтобы избежать этой проблемы, создайте один <xref:System.Random> объекта вместо нескольких объектов.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Как избежать создания нескольких экземпляров  
 Инициализация двух генераторов случайных чисел в непрерывном цикле или быстро создает два генераторы случайных чисел, которые могут производить идентичные последовательности случайных чисел. В большинстве случаев это не намерениями разработчика и может привести к проблемам с производительностью, так как создание и инициализация генератора случайных чисел является довольно дорогостоящим процессом.  
  
 Для повышения производительности и во избежание случайному созданию отдельных генераторы случайных чисел, которые создают идентичные числовой последовательности, рекомендуется создать одну <xref:System.Random> объект для создания многих случайных чисел со временем, вместо создания новый <xref:System.Random> объекты для каждого случайного числа.  
  
 Тем не менее <xref:System.Random> класс не является потокобезопасным. При вызове метода <xref:System.Random> методы из нескольких потоков, следуйте рекомендациям, изложенным в следующем разделе.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Безопасность System.Random класс и потока  
 Вместо создания экземпляров отдельных <xref:System.Random> объектов, мы рекомендуем создать один <xref:System.Random> экземпляр для формирования случайных чисел, необходимых приложению. Тем не менее <xref:System.Random> объекты не являются потокобезопасными. Если приложение вызывает <xref:System.Random> методов из нескольких потоков, необходимо использовать объект синхронизации только один поток может получить доступ к генератора случайных чисел за раз. Если вы не убедитесь, что <xref:System.Random> объекту осуществляется в потокобезопасным способом, возвращает 0, вызовы методов, которые возвращают случайных чисел.  
  
 В следующем примере используется C# [оператор lock](~/docs/csharp/language-reference/keywords/lock-statement.md) и Visual Basic [оператор SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) , чтобы один генератор случайных чисел является доступ к 11 потоков в потокобезопасным способом. Каждый поток создает 2 миллиона случайных чисел, подсчитывает количество случайных чисел и вычисляет их сумму и затем обновляет итоговые значения для всех потоков, завершения выполнения.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 В примере проверяется потокобезопасность одним из следующих способов:  
  
-   <xref:System.ThreadStaticAttribute> Атрибут используется для определения локальные переменные потока, которые отслеживают общее число случайных чисел и их сумму для каждого потока.  
  
-   Блокировка ( `lock` инструкции на языке C# и `SyncLock` в Visual Basic) защищает доступ к переменным, общее количество и сумма всех случайных чисел, созданные во всех потоках.  
  
-   Семафор ( <xref:System.Threading.CountdownEvent> объекта) используется для того, что основной поток блокируется до всех остальных потоков завершения выполнения.  
  
-   В примере проверяется ли генератора случайных чисел оказались поврежденными, определяя ли два последовательных вызовах для случайных чисел методы создания возвращают 0. При обнаружении повреждений, в примере используется <xref:System.Threading.CancellationTokenSource> чтобы сообщить, что все потоки следует отменить.  
  
-   Перед созданием каждой случайное число, каждый поток проверяет состояние <xref:System.Threading.CancellationToken> объекта. Если запрос на отмену в примере вызывается <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод для отмены потока.  
  
 Следующий пример идентичен первому, за исключением того, что она использует <xref:System.Threading.Tasks.Task> объекта и лямбда-выражения вместо <xref:System.Threading.Thread> объектов.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Он отличается от первого примера, одним из следующих способов:  
  
-   Переменные, чтобы отслеживать количество случайных чисел и их сумму в каждой задаче локальны для задачи, поэтому нет необходимости использовать <xref:System.ThreadStaticAttribute> атрибута.  
  
-   Статический <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод используется, чтобы убедиться, что основной поток не завершается до завершения всех задач. Нет необходимости для <xref:System.Threading.CountdownEvent> объекта.  
  
-   Исключение, полученный в результате отмены задачи будет отображена в <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод. В предыдущем примере он обрабатывается каждым потоком.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Создание различных типов случайных чисел  
 Генератор случайных чисел предоставляет методы, которые позволяют создавать следующие виды случайных чисел:  
  
-   Ряд <xref:System.Byte> значения. Определить количество байтовых значений, передавая массив присваивается количество элементов, метод, чтобы вернуться к <xref:System.Random.NextBytes%2A> метод. Следующий пример приводит к возникновению ошибки 20 байт.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Целое число. Можно выбрать, следует ли целое число от 0 до максимального значения (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) путем вызова <xref:System.Random.Next> метод, целое число между 0 и значением, вызвав <xref:System.Random.Next%28System.Int32%29> метода или целое число в пределах диапазона значений путем вызова <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>метод. В параметризованных перегрузок указанное максимальное значение является исчерпывающим; Максимальное число созданных является один меньше, чем указанное значение.  
  
     В следующем примере вызывается <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод для генерации 10 случайных чисел от -10 до 10. Обратите внимание, что второй аргумент метода задает Исключенный верхний предел диапазона случайных значений, возвращаемых методом. Другими словами наибольшее целое, этот метод может возвращать одно — меньше, чем это значение.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Единый значение с плавающей запятой от 0,0 меньше, чем 1.0, вызвав <xref:System.Random.NextDouble%2A> метод. Исключенный верхний предел создаваемого случайного числа, возвращаемого методом-1, поэтому его фактическое верхняя граница — 0.99999999999999978. Следующий пример приводит к возникновению ошибки 10 случайных чисел с плавающей запятой.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод позволяет указать диапазон возвращаемого случайного числа. Тем не менее `maxValue` параметр, который указывает верхний предел возвращаются номера, является эксклюзивных, не включительно, значение. Это означает, что вызов метода `Next(0, 100)` возвращает значение от 0 до 99, а не в диапазоне от 0 до 100.  
  
 Можно также использовать <xref:System.Random> класса для таких задач, как создание [случайных значений T:System.Boolean](#Boolean), создание [случайное число с плавающей запятой значения с диапазоном, отличный от 0 до 1](#Floats), создание [случайных 64-разрядных целых чисел](#Long), и [случайным образом получение уникального элемента из массива или коллекции](#UniqueArray). Эти и другие стандартные задачи, см. в разделе [использование System.Random, чтобы...](#Operations) раздел.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Подстановка собственный алгоритм  
 Вы можете реализовать собственный генератор случайных чисел, путем наследования от <xref:System.Random> класса и предоставление вашей алгоритма генерации случайных чисел. Чтобы указать собственный алгоритм, необходимо переопределить <xref:System.Random.Sample%2A> метод, который реализует алгоритм генерации случайных чисел. Следует также переопределить <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, и <xref:System.Random.NextBytes%2A> методов, чтобы гарантировать, что они вызывают переопределенный <xref:System.Random.Sample%2A> метод. Вам не нужно переопределить <xref:System.Random.Next%28System.Int32%29> и <xref:System.Random.NextDouble%2A> методы.  
  
 Например, который является производным от <xref:System.Random> класса и изменяет его значение по умолчанию генератор псевдослучайных чисел, см. в разделе <xref:System.Random.Sample%2A> справочной странице.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Как использовать System.Random, чтобы...  
 В следующих разделах рассматриваются и обсуждаются образцы кода для некоторые из способов, может потребоваться использовать случайные числа в приложении.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Получить ту же последовательность случайных значений  
 Иногда требуется создать ту же последовательность случайных чисел, в сценарии тестирования продуктов и игры. Тестирование и той же последовательностью случайных чисел, позволяет обнаруживать регрессии и подтвердить исправления ошибок. С помощью той же последовательности случайное число в играх позволяет воспроизвести предыдущие игры.  
  
 Можно создать одну и ту же последовательность случайных чисел, предоставляя то же начальное значение для <xref:System.Random.%23ctor%28System.Int32%29> конструктор. Начальное значение предоставляет начальное значение для алгоритма формирования псевдослучайных чисел. В следующем примере используется 100100 как значение произвольного начального значения для создания экземпляра <xref:System.Random> , отображает 20 случайных значений с плавающей запятой и сохраняет начальное значение. Затем он восстанавливает начальное значение, создает новый генератор случайных чисел и отображает одинаковые значения 20 случайных чисел с плавающей запятой.  Обратите внимание, что пример могут давать различные последовательности случайных чисел, при запуске в различных версиях платформы .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Получить уникальный последовательность случайных чисел  
 Предоставление различных начальных значений для экземпляров <xref:System.Random> класс вызывает каждый генератора случайных чисел для создания другой последовательности значений. Укажите начальное значение явным образом с помощью вызова методов <xref:System.Random.%23ctor%28System.Int32%29> конструктор, или неявно, вызвав <xref:System.Random.%23ctor> конструктор. Большинство разработчиков вызовите конструктор без параметров, который использует системные часы. В следующем примере используется этот подход для создания двух <xref:System.Random> экземпляров. Каждый экземпляр выводит ряд 10 случайных целых чисел.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Тем не менее из-за его конечное разрешение системных часов не обнаруживает время различия, которые являются приблизительно не превышает 15 миллисекунд. Таким образом Если код вызывает <xref:System.Random.%23ctor> перегрузки для создания двух <xref:System.Random> объектов подряд, вы может случайно предоставлять объекты с использованием идентичных начальных значений. Чтобы увидеть это в предыдущем примере, закомментируйте <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызова метода и компиляции и снова запустите пример.  
  
 Чтобы предотвратить такую ситуацию, рекомендуется создать экземпляр одного <xref:System.Random> объекта вместо того чтобы несколько сеансов. Однако, поскольку <xref:System.Random> не является потокобезопасным, некоторые устройства синхронизации необходимо использовать при доступе к <xref:System.Random> экземпляра из нескольких потоков; Дополнительные сведения см [произвольного класса и поток безопасность](#ThreadSafety) ранее в этом раздел. Кроме того, можно использовать механизм задержки, такие как <xref:System.Threading.Thread.Sleep%2A> метод, используемый в предыдущем примере, чтобы избежать возникновения экземпляров друг от друга более чем 15 миллисекунд.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Получить целых чисел в указанном диапазоне  
 Целые числа в указанном диапазоне можно получить, вызвав <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод, который позволяет указать нижней и верхней границы номеров, хотелось бы генератора случайных чисел для возврата. Верхняя граница — эксклюзивных, не включительно, значение. То есть он не включен в диапазон значений, возвращаемых методом. В следующем примере этот метод используется для создания произвольных целых чисел от -10 до 10. Обратите внимание, что в нем задано 11, равное одному больше, чем нужное значение в качестве значения из `maxValue` аргумента в вызове метода.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Получить целых чисел с помощью указанного количества десятичных разрядов  
 Вы можете вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод для извлечения чисел с указанного количества десятичных разрядов. Например, чтобы получить цифры с четырьмя знаками (то есть числа, в диапазоне от 1000 до 9999), следует вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод с `minValue` значение 1000 и `maxValue` значение 10000, как показано в следующем примере.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Извлечь значения с плавающей запятой в указанном диапазоне  
 <xref:System.Random.NextDouble%2A> Метод возвращает случайные значения с плавающей запятой, диапазон от 0 до меньше 1. Тем не менее часто нужно будет создать случайные значения в некоторых других диапазоне.  
  
 Если интервал между минимальным и максимальным нужные значения-1, можно добавить разницу между начальной интервал, а значение 0, возвращенному методом <xref:System.Random.NextDouble%2A> метод. Следующий пример делает это для генерации 10 случайных чисел от -1 до 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Для формирования случайных чисел с плавающей запятой, нижняя граница — 0, но верхняя граница — больше 1 (или, в случае отрицательных чисел, нижняя граница диапазона — меньше -1 и верхняя граница — 0), умножьте ненулевой границей случайного числа. В следующем примере выполняется для формирования случайных чисел с плавающей запятой с 20 миллионов этого диапазона от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. В также отображаются распределения случайных значений, созданных с помощью метода.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Для формирования случайных чисел с плавающей запятой двух произвольных значений, таких как <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод не для целых чисел, используйте следующую формулу:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 В следующем примере генерирует 1 миллион случайные числа в диапазоне от 10.0 до версии 11.0 и отображает их распределение.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Сформировать произвольного логических значений  
 <xref:System.Random> Класс не предоставляет методов, позволяющих создать <xref:System.Boolean> значения. Тем не менее можно определить собственный класс или метод для этого. В следующем примере определяется класс, `BooleanGenerator`, с единственным методом, `NextBoolean`. `BooleanGenerator` Класса хранилищ <xref:System.Random> объект в качестве частной переменной. `NextBoolean` Вызовы методов <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод и передает результат в <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> метод. Обратите внимание на то, что 2 используется в качестве аргумента для указания верхней границы случайного числа. Так как это значение монопольного, этот метод возвращает значение 0 или 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Вместо того чтобы создавать отдельный класс для создания случайных <xref:System.Boolean> значения в примере просто могли бы определить один метод. В этом случае, однако <xref:System.Random> следует, объект был определен как переменную уровня класса, чтобы избежать создания нового <xref:System.Random> экземпляр в каждом вызове метода. В Visual Basic из экземпляра Random могут быть определены как [статический](~/docs/visual-basic/language-reference/modifiers/static.md) переменных в `NextBoolean` метод.  Следующий пример предоставляет реализацию.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Сформировать произвольного 64-разрядных целых чисел  
 Перегрузки <xref:System.Random.Next%2A> метод возвращает 32-разрядных целых чисел. Однако в некоторых случаях может потребоваться работать с 64-разрядных целых чисел. Это можно сделать следующим образом:  
  
1.  Вызовите <xref:System.Random.NextDouble%2A> метод для извлечения двойной точности с плавающей запятой.  
  
2.  Умножьте это значение с <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 В следующем примере использует эту методику для формирования случайных длинных целых чисел — 20 миллионов и распределяет их в 10 равно групп. Затем он вычисляет распределения случайных чисел с подсчета в каждой группе, от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Как видно из примера, номера более или менее равномерно распределяются диапазон типа данных long integer.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Альтернативный способ, что манипуляция с битами использует не создает по-настоящему случайных чисел. Этот метод вызывает <xref:System.Random.Next> для создания двух целых чисел, один на 32 сдвигает влево биты и схему или их вместе. Этот метод имеет два ограничения:  
  
1.  Так как бит 31 бита знака, значение в бит 31 полученное значение типа long integer всегда равно 0.  Эту проблему можно устранить путем формирования случайных 0 или 1, left сдвигая 31 бита, а также использование оператора OR его с исходной случайных длинное целое число.  
  
2.  Более серьезно поскольку вероятность того, что значение, возвращаемое функцией <xref:System.Random.Next> будет равно 0, будет небольшим количеством случайных чисел в диапазоне от 0x0 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Получение байт в указанном диапазоне  
 Перегрузки <xref:System.Random.Next%2A> метода позволяют указать диапазон случайных чисел, но <xref:System.Random.NextBytes%2A> метод — нет. В следующем примере реализуется `NextBytes` метод, который позволяет указать диапазон байтов, возвращаемых. Он определяет `Random2` класс, производный от <xref:System.Random> и перегружает его `NextBytes` метод.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` Метод создает оболочку для вызова <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метода и указывает минимальное значение и один больше, чем максимальное значение (в этом случае 0 и 101), мы должны возвращаться в массиве байтов. Так как мы уверены, что целочисленные значения, возвращаемые <xref:System.Random.Next%2A> метод находятся в диапазоне <xref:System.Byte> тип данных, можно безопасно нужно преобразовать их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Получить элемент из массива или коллекции в случайном порядке  
 Случайные числа часто служат в качестве индексов для извлечения значений из массива или коллекции. Чтобы извлечь значение случайный индекс, можно вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод и использование, нижняя граница массива в качестве значения его `minValue` аргумент и один больше, чем значение верхней границы массива в качестве значения его `maxValue` аргумент. Отсчитываемый от нуля массив, это эквивалентно его <xref:System.Array.Length%2A> свойства или единицу большее, чем значение, возвращенное <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> метод. Случайным образом в следующем примере извлекается имя города на территории США из массив городов.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Получить уникальный элемент из массива или коллекции  
 Генератор случайных чисел всегда можете вернуться повторяющиеся значения. Уменьшается диапазон чисел или число значений, созданных разрастается, увеличивается вероятность дубликаты. Если случайные значения должны быть уникальными, дополнительные номера создаются для компенсации дубликаты, все чаще вызовет снижение производительности.  
  
 Существует ряд методов для обработки этого сценария. Распространенным решением является создание массива или коллекция, содержащая значения должны быть получены, а параллельный массив, содержащий случайные числа с плавающей запятой. Второй массив заполняется случайными числами во время создания первого массива и <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> метод используется для сортировки первого массива, используя значения в массиве parallel.  
  
 Например если вы разрабатываете игры, вы хотите убедиться, что каждая карта используется только один раз. Вместо создания случайных чисел, чтобы получить карту и отслеживания ли эта карта уже были обработаны, можно создать массив, параллельный случайных чисел, который может использоваться для сортировки колоды. После сортировки колоды, приложение может поддерживать указатель, чтобы указать индекс следующей карты в колоде.  
  
 Этот подход показан в приведенном ниже примере. Он определяет `Card` класс, представляющий игральную карту и их `Dealer` класс, который обрабатывает перемешать карт. `Dealer` Конструктор класса заполняет два массива: `deck` массива, который имеет область видимости класса, которое представляет все карты в колоде; и локальный `order` массив, который имеет одинаковое количество элементов, как `deck` массива и заполняется с помощью случайным образом <xref:System.Double> значения.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Затем вызывается метод для сортировки `deck` массива на основе значений в `order` массива.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 В следующем примере создается один генератор случайных чисел и вызывает его <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, и <xref:System.Random.NextDouble%2A> методов для автоматического создания последовательности случайных чисел в разных диапазонах.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Следующий пример создает случайное целое число, которое используется в качестве индекса для получения строковое значение из массива.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>В .NET Framework 1.0 и 1.1, минимальная реализация класса, производным от <see cref="T:System.Random" /> требуется переопределение <see cref="M:System.Random.Sample" /> метод для определения новых или измененных алгоритм генерации случайных чисел. Производный класс может использовать реализацию базового класса <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, и <see cref="M:System.Random.NextDouble" /> методы для вызова реализации в производном классе <see cref="M:System.Random.Sample" /> метод.  
  
В .NET Framework 2.0 и более поздних, поведение <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, и <see cref="M:System.Random.NextBytes(System.Byte[])" /> методы были изменены таким образом, чтобы эти методы не обязательно вызывайте реализации в производном классе <see cref="M:System.Random.Sample" /> метод. Таким образом, классы, производные от <see cref="T:System.Random" /> , предназначенных для .NET Framework 2.0 и более поздней версии, следует также переопределить эти три метода.</para></block>
    <block subset="none" type="usage"><para>Реализации генератора случайных чисел в <see cref="T:System.Random" /> класс не обязательно будет остаются неизменными в разных основных номерах версий платформы .NET Framework. Таким образом Нет оснований предполагать, что то же начальное значение приведет к той же последовательности псевдослучайных чисел в различных версиях платформы .NET Framework.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью зависимого от времени начального значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начальное значение по умолчанию является производным от системных часов и имеет ограниченный разрешения. В результате разных <xref:System.Random> объектов, созданных в быстрой последовательности путем вызова конструктора по умолчанию будет иметь значения по умолчанию идентичны начальное значение и, будут производить идентичными наборами случайных чисел. Этой проблемы можно избежать, используя единую <xref:System.Random> объект для создания всех случайных чисел. Можно также обойти его, изменив начальное значение, возвращенное системных часов и затем явно предоставив это новое начальное значение для <xref:System.Random.%23ctor%28System.Int32%29> конструктор. Дополнительные сведения см. в разделе <xref:System.Random.%23ctor%28System.Int32%29> конструктор.  
  
 Если вы хотите, чтобы генератора случайных чисел для создания случайную последовательность чисел, вызов этого конструктора. Чтобы создать фиксированной последовательности случайных чисел, который будет одинаковым для разных генераторов случайных чисел, вызвать <xref:System.Random.%23ctor%28System.Int32%29> конструктор с предопределенной начальным значением. Это <xref:System.Random> перегрузку конструктора часто используется при тестировании приложения, использующие случайных чисел.  
  
 После создания экземпляра генератора случайных чисел вызове отдельных <xref:System.Random> методы, такие как <xref:System.Random.Next> или <xref:System.Random.NextDouble>, для формирования случайных чисел.  
  
   
  
## Examples  
 В следующем примере используется конструктор по умолчанию для создания экземпляра три <xref:System.Random> объектов и отображает последовательность случайных целых чисел для каждого. Так как первые два <xref:System.Random> объекты создаются в быстрой последовательности, они создаются, используя одинаковые начальные значения, в зависимости от системных часов и, таким образом, они создают идентичную последовательность случайных чисел. С другой стороны, конструктор по умолчанию третьего <xref:System.Random> объекта вызывается после двух секундная задержка, из-за вызова <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод. Так как это создает различные начальное значение для третьей <xref:System.Random> объекта, он создает различные последовательность случайных чисел.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел. Если задано отрицательное число, используется его абсолютное значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью указанного начального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предоставляя задать одинаковые начальные значения для разных <xref:System.Random> объектов вызывает каждый экземпляр для создания идентичных последовательность случайных чисел. Это часто делается при тестировании приложений, основанных на генераторы случайных чисел.  
  
 Приложению требуются различные последовательности случайных чисел, необходимо вызовите этот конструктор несколько раз с различными начальными значениями. Один из способов создания уникального начального значения — упростить зависящие от времени. Например, извлекать его из системных часов, как <xref:System.Random.%23ctor> перегрузки. Тем не менее системных часов может не иметь достаточно разрешения для предоставления различных вызовов этого конструктора с разных начальным значением. В результате генераторы случайных чисел, которые создают идентичные последовательности псевдослучайных чисел, как показано в первых двух <xref:System.Random> объектов в следующем примере. Чтобы избежать этого, применить алгоритм начального значения в каждом вызова или вызова <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что каждый конструктор предоставляется другое начальное значение.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Другой вариант — создать экземпляр одного <xref:System.Random> который используется для формирования случайных чисел в приложении. Это дает несколько большую производительность, так как создание экземпляров генератора случайных чисел является довольно дорогой.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Random> объектов с помощью конструктора класса, который принимает параметр начального значения и создает последовательность случайных целых чисел и чисел типа Double. В примере показано, что и та же последовательность создается при <xref:System.Random> снова создается объект с параметром конструктора и начальное значение.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает случайное целое число.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает неотрицательное случайное целое число.</summary>
        <returns>32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> Создает случайное число в диапазоне от 0 до менее <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Чтобы создать случайное число в диапазоне от 0 до других положительного числа, используйте <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Чтобы создать случайное число в пределах другой диапазон, используйте <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> перегрузки метода.  
  
   
  
## Examples  
 В следующем примере создается повторные вызовы <xref:System.Random.Next%2A> метод для генерации определенное количество случайных чисел, по запросу пользователя. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Метод используется для получения отзывов клиентов.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Следующий пример является производным от класса <xref:System.Random> создать последовательность случайных чисел, распределение которых отличается от равномерного распределения, созданные <xref:System.Random.Sample%2A> метод базового класса. Этот параметр переопределяет <xref:System.Random.Sample%2A> способ предоставления распределения случайных чисел и переопределений <xref:System.Random.Next%2A?displayProperty=nameWithType> метод использование набора случайных чисел.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с .NET Framework версии 2.0, если вы наследуете от класса <see cref="T:System.Random" /> и переопределить <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метод не используется в вызовах базового класса Реализация <see cref="M:System.Random.Next" /> метод. Вместо этого возвращается равномерное распределение базовым <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.Next" /> метод.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Эксклюзивная верхняя граница создаваемого случайного числа. <paramref name="maxValue" /> должно быть больше либо равно 0.</param>
        <summary>Возвращает неотрицательное случайное целое число, которое меньше указанного максимального значения.</summary>
        <returns>32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <paramref name="maxValue" />. То есть диапазон возвращаемых значений включает в себя 0, но не включает <paramref name="maxValue" />. Однако если значение параметра <paramref name="maxValue" /> равно нулю, возвращается значение <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> Перегрузка возвращает этот диапазон случайных целых чисел от 0 до `maxValue` - 1. Тем не менее если `maxValue` равно 0, метод возвращает значение 0.  
  
   
  
## Examples  
 Следующий пример приводит к возникновению ошибки случайных целых чисел с помощью перегрузок <xref:System.Random.Next%2A> метод.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Следующий пример создает случайное целое число, которое используется в качестве индекса для получения строковое значение из массива. Так как один меньше, чем его длину, значение наибольшего индекса массива <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство передается в качестве `maxValue` параметра.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxValue" /> меньше 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Включенный нижний предел возвращаемого случайного числа.</param>
        <param name="maxValue">Исключенный верхний предел возвращаемого случайного числа. Значение свойства <paramref name="maxValue" /> должно быть больше или равно значению свойства <paramref name="minValue" />.</param>
        <summary>Возвращает случайное целое число в указанном диапазоне.</summary>
        <returns>32-разрядное целое число со знаком большее или равное <paramref name="minValue" /> и меньше, чем <paramref name="maxValue" />; то есть, диапазон возвращаемого значения включает <paramref name="minValue" />, не включает <paramref name="maxValue" />. Если значение параметра <paramref name="minValue" /> равно значению параметра <paramref name="maxValue" />, то возвращается значение <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Перегрузка возвращает случайные целые числа указанного диапазона из `minValue` для `maxValue` - 1. Тем не менее если `maxValue` равно `minValue`, метод возвращает `minValue`.  
  
 В отличие от других перегрузок <xref:System.Random.Next%2A> метод, который возвращает только неотрицательные значения, этот метод может возвращать отрицательное случайное целое число.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод для генерации случайных целых чисел с тремя различными диапазонами. Обратите внимание, что точное выходные данные примера зависит от начального значения системное значение, передаваемое в <xref:System.Random> конструктора класса.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Следующий пример создает случайное целое число, которое используется в качестве индекса для получения строковое значение из массива. Так как один меньше, чем его длину, значение наибольшего индекса массива <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство передается в качестве `maxValue` параметра.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="minValue" /> больше значения <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с .NET Framework версии 2.0, если вы наследуете от класса <see cref="T:System.Random" /> и переопределить <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метод не используется в вызовах базового класса Реализация <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> перегрузку метода, если разница между <paramref name="minValue" /> и <paramref name="maxValue" /> параметров больше, чем <see cref="F:System.Int32.MaxValue" />. Вместо этого возвращается равномерное распределение базовым <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> перегрузки метода.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив байтов, содержащий случайные числа.</param>
        <summary>Заполняет элементы указанного массива байтов случайными числами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент массива байтов присваивается случайное число, больше или равно 0 и меньше или равно <xref:System.Byte.MaxValue>.  
  
 Например, для создания криптографически защищенным случайное число, подходящий для создания случайного пароля, используйте метод как <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Random.NextBytes%2A> метод для заполнения массива байтов случайных байтовых значений.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с .NET Framework версии 2.0, если вы наследуете от класса <see cref="T:System.Random" /> и переопределить <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метод не используется в вызовах базового класса Реализация <see cref="M:System.Random.NextBytes(System.Byte[])" /> метод. Вместо этого возвращается равномерное распределение базовым <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.NextBytes(System.Byte[])" /> метод.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический верхняя граница создаваемого случайного числа, возвращаемого этим методом — 0.99999999999999978.  
  
 Для получения случайных значений с плавающей запятой в диапазоне, отличный от 0,0 до 1,0, см. в разделе «Получать значения с плавающей запятой в указанном диапазоне» <xref:System.Random> разделе, посвященном классу.  
  
 Этот метод является общедоступной версией защищенный метод <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Random.NextDouble%2A> метод для создания последовательности случайных чисел двойной точности.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 В следующем примере вызывается <xref:System.Random.NextDouble%2A> метод для генерации 100 случайных чисел и отображает их распределение частоты.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания другого распределения случайных или различных случайных чисел принцип генератор, наследуйте класс от <xref:System.Random> класса и переопределить <xref:System.Random.Sample%2A> метод.  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> Метод `protected`, что означает, что он доступен только в пределах <xref:System.Random> класса и его производных классов. Чтобы получить случайное число между 0 и 1 из <xref:System.Random> экземпляра, вызовите <xref:System.Random.NextDouble%2A> метод.  
  
   
  
## Examples  
 Следующий пример является производным от класса <xref:System.Random> и переопределяет <xref:System.Random.Sample%2A> метод для создания распределения случайных чисел. Этот дистрибутив отличается от равномерного распределения, созданные <xref:System.Random.Sample%2A> метод базового класса.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с .NET Framework версии 2.0, если вы наследуете от класса <see cref="T:System.Random" /> и переопределить <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метод не используется в вызовах базового класса Реализация следующих методов: 
– метод <see cref="M:System.Random.NextBytes(System.Byte[])" />.  
  
– метод <see cref="M:System.Random.Next" />.  
  
- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Метод, если (<paramref name="maxValue" /> - <paramref name="minValue" />) больше, чем <see cref="F:System.Int32.MaxValue" />.  
  
Вместо этого равномерного распределения, предоставляемые базовый <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать реализацию <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить поведение этих трех элементов. Иллюстрация приведена в примере.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>