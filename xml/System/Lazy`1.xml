<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1fe040656ca9af07674a26a02d9bd1c32874d7b8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57911256" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">тип объекта, который неактивно инициализируется.</typeparam>
    <summary>Обеспечивает поддержку неактивной инициализации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте отложенную инициализацию отложить создание больших или ресурсоемких объекта или выполнения ресурсоемких задач, особенно в том случае, если такие создания или выполнения могут не выполняться в течение времени существования программы.  
  
 Чтобы подготовить для отложенной инициализации, создания экземпляра <xref:System.Lazy%601>. Аргумент типа <xref:System.Lazy%601> , созданный тип объекта, который вы хотите инициализировать неактивно. Конструктор, который используется для создания <xref:System.Lazy%601> объекта определяет характеристики инициализации. Отложенная инициализация производится при первом обращении к свойству <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 В большинстве случаев выбор конструктор зависит ответы на два вопроса:  
  
-   Неактивно инициализированного объекта будут доступны из более чем одного потока? Если Да, <xref:System.Lazy%601> объект может создать в любом потоке. Можно использовать один из простых конструкторов, поведение которого по умолчанию является создание поточно ориентированной <xref:System.Lazy%601> объекта, так что только один экземпляр неактивно обрабатываемого объекта создается независимо от того, сколько потока пытаются получить доступ к нему. Для создания <xref:System.Lazy%601> объекта, который не является потокобезопасным, необходимо использовать конструктор, который позволяет указать без потокобезопасности.  
  
    > [!CAUTION]
    >  Что делает <xref:System.Lazy%601> объект поточно-ориентированным не защищает неактивно инициализированного объекта. Если несколько потоков могут получить доступ к неактивно инициализированного объекта, необходимо убедиться в его свойства и методы безопасными для многопоточного доступа.  
  
-   Отложенная инициализация требует большого объема кода, или неактивно инициализированного объекта имеет конструктор по умолчанию, который выполняет все, что нужно и не вызывать исключения? Если вам нужно написать код инициализации, или если необходимо обрабатывать исключения, используйте один из конструкторов, принимающих метод фабрики. Запишите свой код инициализации в методе фабрики.  
  
 В следующей таблице показаны, чтобы выбрать, какой конструктор на основе этих двух факторов:  
  
|Объект, которые будут доступны для|Если требуется никакого кода инициализации (конструктор по умолчанию), используйте|Если код инициализации, используйте|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Несколько потоков|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Один поток|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> с помощью `isThreadSafe` присвоено `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> с помощью `isThreadSafe` присвоено `false`.|  
  
 Лямбда-выражения можно использовать для указания метода фабрики. В этом случае всех кодов инициализации в одном месте. Лямбда-выражение захватывает контекст, включая все аргументы, передаваемые конструктору объекта отложенной инициализацией.  
  
 **Кэширование исключений** при использовании фабричные методы исключения кэшируются. То есть если фабричный метод создает исключение времени исключение первый поток пытается получить доступ к <xref:System.Lazy%601.Value%2A> свойство <xref:System.Lazy%601> объекта, то же исключение возникает при всех последующих попытках. Это гарантирует, что при каждом вызове <xref:System.Lazy%601.Value%2A> свойство дает тот же результат и позволяет избежать ошибкам, которые могут возникнуть при разных потоков получить разные результаты. <xref:System.Lazy%601> Заменяет реальный `T` , в противном случае будет инициализировано на более раннем этапе, обычно во время запуска. Сбой на этой более ранней точки является обычно неустранимой. Если существует вероятность возникновения сбоя восстанавливаемые, мы рекомендуем встраивание логики повторения в процедуре инициализации (в данном случае метод фабрики), так же, как если бы использовали отложенной инициализации.  
  
 **Альтернативой блокировки** в определенных ситуациях может потребоваться избежать <xref:System.Lazy%601> объекта по умолчанию работа блокировки. В редких случаях могут быть вероятность возникновения взаимоблокировок. В таких случаях можно использовать <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор и укажите <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Это позволяет <xref:System.Lazy%601> для создания копии неактивно инициализированного объекта на каждом из нескольких потоков, если потоки обращаются к <xref:System.Lazy%601.Value%2A> свойства одновременно. <xref:System.Lazy%601> Объект гарантирует, что все потоки, использовать один и тот же экземпляр объекта с отложенной инициализацией и удаляет экземпляры, которые не используются. Таким образом сокращение расходов на блокировку обходится, программа может иногда Создание и удаление дополнительных копий ресурсоемкий объект. В большинстве случаев это маловероятно. В примерах для <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструкторы демонстрируют это поведение.  
  
> [!IMPORTANT]
>  При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, исключения не кэшируются, даже если указать метод фабрики.  
  
 **Эквивалентное конструкторы** Помимо возможности использования <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструкторы можно дублировать функции других конструкторов. В следующей таблице показаны значения параметров, которые создают эквивалентное поведение.  
  
|Чтобы создать <xref:System.Lazy%601> объект, который отсутствует|Для конструкторов, которые имеют `LazyThreadSafetyMode` `mode` набор параметров, `mode` для|Для конструкторов, которые имеют значение типа Boolean `isThreadSafe` набор параметров, `isThreadSafe` для|Для конструкторов без параметров безопасности потока|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Полностью потокобезопасным; использует блокировку для убедитесь, что только один поток инициализирует значение.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Все конструкторы являются полностью потокобезопасными.|  
|Не является потокобезопасным.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Неприменимо.|  
|Полностью потокобезопасным; потоки состязаются за право инициализации значения.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Неприменимо.|Неприменимо.|  
  
 **Другие возможности** сведения об использовании <xref:System.Lazy%601> с статических полей потока, или в качестве резервного хранилища для свойств, см. в разделе [отложенной инициализации](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Lazy%601> класса для выполнения отложенной инициализации с доступом из нескольких потоков.  
  
> [!NOTE]
>  В примере используется <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, просто измените конструкторов, закомментированы.  
>   
>  Пример, демонстрирующий исключение кэширования с помощью же конструкторы, см. в разделе <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Четыре основные разделы кода иллюстрируют Создание инициализатор, метод фабрики, фактическую инициализацию и конструктор `LargeObject` класс, который выводит сообщение при создании объекта. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Фабричный метод показано создание объекта, с заполнителем для дальнейшей инициализации:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Обратите внимание на то, код первых двух разделов, которые можно использовать с помощью лямбда-функцию, как показано ниже:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 В примере приостанавливается, чтобы указать, что неопределенное может пройти, прежде чем отложенной инициализации. При нажатии клавиши **ввод** ключей, в примере создает и запускает три потока. `ThreadProc` Метод, используемый вызовами все три потока <xref:System.Lazy%601.Value%2A> свойство. В первый раз, в этом случае `LargeObject` создается экземпляр:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Конструктор `LargeObject` класса, содержащего последнего ключа раздела кода, отображает сообщение и регистрирует удостоверение поток. Выходные данные программы отображаются в конце полный отрывок кода.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>По умолчанию, все открытые и защищенные члены <see cref="T:System.Lazy`1" /> класса являются потокобезопасными и могут быть использованы одновременно из нескольких потоков. Эти потокобезопасности могут быть удалены, при необходимости и экземпляра, используя параметры типа.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используется конструктор целевого типа по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, который создается с помощью этого конструктора могут использоваться одновременно из нескольких потоков.  
  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, просто измените конструкторов, закомментированы.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Два основных строк кода в этом примере входит создание инициализатор и фактическую инициализацию. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 В примере создает и запускает три потока, которые блокируют на <xref:System.Threading.ManualResetEvent> объекта, так что пример может освободить потоков за один раз. `ThreadProc` Метод, используемый вызовами все три потока <xref:System.Lazy%601.Value%2A> свойство для получения `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> Класс предоставляет блокировку, чтобы только один поток может создавать `LargeObject` экземпляра. В примере показано, что другие потоки все получить тот же экземпляр.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используются конструктор целевого типа по умолчанию и заданный режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Если `isThreadSafe` — `true`; в противном случае используется режим <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра. Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режиме <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора для создания отложенный инициализатор, который не является потокобезопасным, для сценариев, где весь доступ к неактивно инициализированного объекта происходит в том же потоке. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`. Чтобы переключиться в другой конструктор, просто измените, какой конструктор закомментирован.  
  
> [!NOTE]
>  Для кода, который демонстрирует, как использовать этот конструктор в сценариях с несколькими потоками (указание `true` для `isThreadSafe`), см. в примере <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация. В `Main` метод, в примере создается <xref:System.Lazy%601> экземпляр и затем паузы. При нажатии клавиши **ввод** ключа, пример обращается к <xref:System.Lazy%601.Value%2A> свойство <xref:System.Lazy%601> экземпляр, который приводит к инициализации возникает. Конструктор `LargeObject` класс отображает сообщение в консоли.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используется заданная функция инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, который создается с помощью этого конструктора могут использоваться одновременно из нескольких потоков.  
  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Исключения, вызываемые по `valueFactory` кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора для предоставления отложенной инициализации с кэширование исключений. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, просто измените конструкторов, закомментированы.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три основные части кода, иллюстрируют Создание инициализатор, фактическую инициализацию и конструктор `LargeObject` класс, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 В примере создает и запускает три потока. `ThreadProc` Метод, используемый вызовами все три потока <xref:System.Lazy%601.Value%2A> свойство для получения `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 В конструкторе класса `LargeObject` , третий ключа раздела кода создает исключение первом `LargeObject` экземпляр создается, но после этого позволяет создавать экземпляр возникает:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 При запуске примере первый поток, который пытается создать экземпляр `LargeObject` завершается ошибкой и исключение перехватывается. Можно предположить, что следующий поток успешно создать экземпляр, но <xref:System.Lazy%601> объект в кэш исключение. По этой причине все три потока исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует конструктор <paramref name="T" /> по умолчанию и заданный потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора для создания отложенный инициализатор, который позволяет нескольким потокам состязаются за право отложенного создания объекта. Несколько потоков может быть выполнена успешно при создании экземпляров, но все потоки использовать экземпляр, который сначала был создан.  
  
> [!NOTE]
>  Пример, в котором показано, как использовать этот конструктор в однопоточных сценариях (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в разделе <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор. Пример, демонстрирующий этот конструктор используется для предоставления блокировки вместо состояния гонки в сценариях с несколькими потоками (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в разделе <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация одним из нескольких потоков. Три основные части кода, иллюстрируют Создание инициализатор, фактическую инициализацию и конструктор и метод завершения из `LargeObject` класса. В начале `Main` метод, в примере создается <xref:System.Lazy%601> объект, который выполняет отложенной инициализации `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 В примере создает и запускает три потока, которые блокируют на <xref:System.Threading.ManualResetEvent> объекта, так что пример может освободить потоков за один раз. В `ThreadProc` метод, который используется для всех трех потоков, вызвав <xref:System.Lazy%601.Value%2A> создает свойство `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Так как конструктор для <xref:System.Lazy%601> указанный экземпляр <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, все три потока разрешено создавать `LargeObject` экземпляров. Это продемонстрировано в примере путем отображения сообщения консоли, в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Тем не менее <xref:System.Lazy%601> объект гарантирует, что только один экземпляр используется всеми потоками. Из примера видно, что все три потока использовать в том же экземпляре, а также показано, что двух других экземпляров может быть удален сборщиком мусора.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Предварительно инициализированное значение для использования.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, использующий предварительно инициализированное заданное значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Экземпляр, созданный этим конструктором используется несколькими потоками одновременно.
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При неактивной инициализации используются заданные функция и режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Если `isThreadSafe` — `true`; в противном случае используется режим <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режиме <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор.  
  
 Исключения, вызываемые по `valueFactory` кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора для предоставления отложенной инициализации с исключением, кэширование, в сценарии с одним потоком. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%2A> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`). Чтобы переключиться в конструктор, просто измените, какой конструктор закомментирован.  
  
> [!NOTE]
>  Для кода, который демонстрирует, как использовать этот конструктор в сценариях с несколькими потоками (указание `true` для `isThreadSafe`), см. в примере <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три основные части кода, иллюстрируют Создание инициализатор, фактическую инициализацию и конструктор `LargeObject` класс, который демонстрирует кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 В вызове конструктора `isThreadSafe` параметр `false`, поэтому <xref:System.Lazy%601> не является потокобезопасным. Так как он не является потокобезопасным, в примере вызывается <xref:System.Lazy%601.Value%2A> свойство три раза в одном потоке:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 В конструкторе класса `LargeObject` , третий ключа раздела кода создает исключение первом `LargeObject` экземпляр создается, но после этого позволяет создавать экземпляр возникает:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Если пример выполняется, первая попытка создать экземпляр `LargeObject` завершается ошибкой и исключение перехватывается. Можно предположить, что следующая попытка будет выполнено успешно, но <xref:System.Lazy%601> объект в кэш исключение. По этой причине все три попытки исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для получения неактивно инициализированного значения, когда оно требуется.</param>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует заданную функцию инициализации и потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Исключения, вызываемые по `valueFactory` кэшируются, если не `mode` является <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ниже приведен пример использования этого конструктора для создания отложенный инициализатор, который позволяет нескольким потокам состязаются за право отложенного создания объекта. Несколько потоков может быть выполнена успешно при создании экземпляров, но все потоки использовать экземпляр, который сначала был создан. Кроме того, в примере показано, что исключения не кэшируются при указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, даже если инициализация выполняется с помощью функции, а не конструктором по умолчанию неактивно созданного типа.  
  
> [!NOTE]
>  Пример, в котором показано, как использовать этот конструктор в однопоточных сценариях (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), см. в разделе <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор. Пример, демонстрирующий этот конструктор используется для предоставления блокировки вместо состояния гонки в сценариях с несколькими потоками (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), см. в разделе <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация одним из нескольких потоков. Четыре основные разделы кода иллюстрируют Создание инициализатор, фактическую инициализацию, функцию инициализации и конструктора и метода завершения `LargeObject` класса. В начале `Main` метод, в примере создается <xref:System.Lazy%601> объект, который выполняет отложенной инициализации `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Функция отложенный инициализатор для выполнения инициализации. В этом случае функция необходима, поскольку нет конструктора по умолчанию для `LargeObject` класса.  
  
 В примере создает и запускает три потока, которые блокируют на <xref:System.Threading.ManualResetEvent> объекта, так что пример может освободить потоков за один раз. В `ThreadProc` метод, который используется для всех трех потоков, вызвав <xref:System.Lazy%601.Value%2A> создает свойство `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 В третьем ключа раздела кода, функция отложенной инициализации вызывается для создания `LargeObject` экземпляра. Функция создает исключение первый времени при вызове:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Для любого другого <xref:System.Threading.LazyThreadSafetyMode> параметр необработанного исключения в функции инициализации будет кэшироваться. Тем не менее <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> отключает кэширование исключений. Выходные данные примера показано, что повторная попытка инициализировать объект завершается успешно.  
  
> [!NOTE]
>  После сообщения о том, что другие потоки успешно инициализирован объект обычно отображается сообщение об исключении. Это из-за задержки, связанные с Создание и перехват исключения.  
  
 Так как конструктор для <xref:System.Lazy%601> указанный экземпляр <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, все три потока разрешено создавать `LargeObject` экземпляров. Это продемонстрировано в примере путем отображения сообщения консоли, в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Объект гарантирует, что только один экземпляр используется всеми потоками (за исключением самого потока, где функция инициализации вызывает исключение). Это показано в выходных данных из примера.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, было ли создано значение для данного экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Значение <see langword="true" />, если для данного экземпляра <see cref="T:System.Lazy`1" /> было создано значение; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда происходит отложенная инициализация для <xref:System.Lazy%601> экземпляр, это может привести значение создаваемого или возникает исключение. Если исключение создается, последующее поведение <xref:System.Lazy%601> экземпляр зависит от того, кэширование исключений, является ли в силе. Если <xref:System.Lazy%601> экземпляр был создан с помощью конструктора, который не содержит функцию, то кэширование исключений не действует. Повторная попытка инициализировать <xref:System.Lazy%601> может быть выполнена успешно и после успешной инициализации <xref:System.Lazy%601.IsValueCreated%2A> возвращает `true`. Если <xref:System.Lazy%601> экземпляр был создан с помощью функции инициализации (определяется `valueFactory` параметр <xref:System.Lazy%601> конструктора), а затем кэширование исключений управляется потокобезопасный режим.  
  
-   Если используется режим <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, имеется второй шанс инициализации <xref:System.Lazy%601> экземпляра. Если исключение возникает и обрабатывается в функции инициализации, исключение кэшируется и снова на последующие обращения к <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> свойство. Значение не создается в том случае, если создается исключение, поэтому в таких случаях <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
-   Если используется режим <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, первый поток, который успешно работает функция инициализации (или конструктор по умолчанию) создает значение <xref:System.Lazy%601> экземпляра. Если функция инициализации вызывает исключение в одном потоке, другие потоки могут по-прежнему пытаться инициализировать <xref:System.Lazy%601> экземпляра. Пока это значение создается, <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра.</summary>
        <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра, если это значение было создано (то есть если свойство <see cref="P:System.Lazy`1.IsValueCreated" /> возвращает значение <see langword="true" />). В противном случае возвращается строка, указывающая, что значение не было создано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода не приводит к инициализации.  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Свойство может быть `null` после отложенной инициализации, если метод фабрики, был указан для `valueFactory` параметр <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор возвращает `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение свойства <see cref="P:System.Lazy`1.Value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> свойство `false`, доступ к свойству <xref:System.Lazy%601.Value%2A> свойство вызывает инициализацию.  
  
 Помимо исключений, которые находятся в списке <xref:System.Lazy%601.Value%2A> свойство можно вызывать любое необработанное исключение, вызванное фабричный метод, который был передан `valueFactory` параметр <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора по умолчанию, имеющего тип с отложенной инициализацией, а разрешения для доступа к конструктору отсутствуют.</exception>
        <exception cref="T:System.MissingMemberException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора по умолчанию, имеющего тип с отложенной инициализацией, и данный тип не имеет открытого конструктора, не принимающего параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Функция инициализации в данном экземпляре пытается получить доступ к <see cref="P:System.Lazy`1.Value" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Отложенная инициализация</related>
      </Docs>
    </Member>
  </Members>
</Type>