<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66e2e65213f206d2f372ce8b2f4c3348b3bd38c4" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57936866" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет сведения о привязке сборок, которые могут быть добавлены к экземпляру класса <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение свойств <xref:System.AppDomainSetup> экземпляра не влияет на все существующие <xref:System.AppDomain>. Это может повлиять на создание только новый <xref:System.AppDomain>, когда <xref:System.AppDomain.CreateDomain%2A> метод вызывается с <xref:System.AppDomainSetup> экземпляр в качестве параметра.  
  
 Этот класс реализует интерфейс <xref:System.IAppDomainSetup> .  
  
> [!CAUTION]
>  Значение по умолчанию для <xref:System.AppDomainSetup.DisallowCodeDownload%2A> свойство имеет значение false. Этот параметр является небезопасным для служб. Чтобы помочь предотвратить загрузку частично доверенным кодом службы, этому свойству присвоено значение true  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Как выполнить: Настройка домена приложения</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">Контекст активации, который необходимо использовать для текущего домена приложения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> заданным контекстом активации для использования при активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext> Объект, указанный для `activationContext` используется для создания <xref:System.Runtime.Hosting.ActivationArguments> объект, содержащий сведения, необходимые для активации нового домена приложения. Это <xref:System.Runtime.Hosting.ActivationArguments> доступ к объекту можно получить с помощью <xref:System.AppDomainSetup.ActivationArguments%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Объект, определяющий сведения, необходимые для активации нового домена приложения на основе манифеста.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.AppDomainSetup" /> заданными аргументами контекста активации, необходимыми для активации домена приложения на основе манифеста.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект, указанный для `activationArguments` может осуществляться с помощью <xref:System.AppDomainSetup.ActivationArguments%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает данные об активации домена приложения.</summary>
        <value>Объект, содержащий данные об активации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение не вызывается в том случае, если это свойство имеет значение `null`.  
  
 Сведения, предоставляемые <xref:System.Runtime.Hosting.ActivationArguments> объект поддерживает активацию на основе манифеста.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ApplicationTrust" />. Если свойство <see cref="P:System.AppDomainSetup.ApplicationTrust" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</summary>
        <value>Делегат, представляющий метод обратного вызова, вызываемый при инициализации домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы передать сведения в метод обратного вызова, назначить массив строк для <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойство. Массив передается методу обратного вызова, каждый раз <xref:System.AppDomain> инициализируется.  
  
 Метод обратного вызова выполняется в контексте домена, только что созданное приложение.  
  
   
  
## Examples  
 В следующем примере создается дочернего домена приложения с именем `ChildDomain`, с использованием <xref:System.AppDomainSetup> объекта и свидетельство домена приложения по умолчанию. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Свойство имеет значение в метод обратного вызова `AppDomainInit`, который вызывается при инициализации дочернего домена. Аргументы для метода обратного вызова, помещаются в массив строк, которые назначены <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойство. При создании дочернего домена, метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает аргументы, передаваемые методу обратного вызова, представленному делегатом <see cref="T:System.AppDomainInitializer" />. Этот метод обратного вызова вызывается при инициализации домена приложения.</summary>
        <value>Массив строк, передаваемый методу обратного вызова, представленному делегатом <see cref="T:System.AppDomainInitializer" />, когда метод обратного вызова вызывается при инициализации <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.AppDomainSetup.AppDomainInitializer%2A> свойство, чтобы указать метод обратного вызова, который вызывается во время <xref:System.AppDomain> инициализации. Если <xref:System.AppDomainSetup.AppDomainInitializer%2A> свойство не задано, массив, назначенная этому свойству не используется.  
  
 Метод обратного вызова выполняется в контексте домена, только что созданное приложение.  
  
   
  
## Examples  
 В следующем примере кода создается дочернего домена приложения с именем `ChildDomain`, с использованием <xref:System.AppDomainSetup> объекта и свидетельство домена приложения по умолчанию. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Свойство имеет значение в метод обратного вызова `AppDomainInit`, который вызывается при инициализации дочернего домена. Аргументы для метода обратного вызова, помещаются в массив строк, которые назначены <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> свойство. При создании дочернего домена, метод обратного вызова просто выводит строки.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает отображаемое имя сборки, предоставляющей тип диспетчера доменов приложений для доменов приложений, созданных с помощью объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Отображаемое имя сборки, предоставляющей <see cref="T:System.Type" /> диспетчера доменов приложений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы задать тип диспетчера доменов приложений, установить и данное свойство и <xref:System.AppDomainSetup.AppDomainManagerType%2A> свойство. Если любое из этих свойств не задано, другое обрабатывается.  
  
 Если тип не указан, диспетчер домена приложения создается из тот же тип, что родительский домен приложения (то есть домен приложения, из которого <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> вызывается метод).  
  
 При загрузке домена приложения <xref:System.TypeLoadException> возникает исключение, если сборка не существует, или в том случае, если сборка не содержит типа, заданного параметром <xref:System.AppDomainSetup.AppDomainManagerType%2A> свойство. <xref:System.IO.FileLoadException> возникает, если сборка найдена, но не соответствует сведениям о версии.  
  
 Чтобы установить диспетчер домена приложения для домена приложения по умолчанию, используйте [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) элементов в [ \<среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) раздел файла конфигурации приложения, или используйте переменные среды, описанные в <xref:System.AppDomainManager>.  
  
 Эта функция требует полного доверия приложения. (Например, приложения, работающего на рабочем столе имеет полное доверие). Если приложение не имеет полного доверия, <xref:System.TypeLoadException> возникает исключение.  
  
 Формат отображаемого имени сборки, определяется формулой <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает полное имя типа, содержащего диспетчер доменов приложений для доменов приложений, созданных с помощью данного объекта <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Полное имя типа, включая пространство имен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы задать тип диспетчера доменов приложений, установить и данное свойство и <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> свойство. Если любое из этих свойств не задано, другое обрабатывается.  
  
 Если тип не указан, диспетчер домена приложения создается из тот же тип, что родительский домен приложения (то есть домен приложения, из которого <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> вызывается метод).  
  
 При загрузке домена приложения <xref:System.TypeLoadException> возникает исключение, если сборка, заданная <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> свойство не содержит типа, заданного этим свойством.  
  
 Чтобы установить диспетчер домена приложения для домена приложения по умолчанию, используйте [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) и [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) элементов в [ \<среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) раздел файла конфигурации приложения, или используйте переменные среды, описанные в <xref:System.AppDomainManager>.  
  
 Эта функция требует полного доверия приложения. (Например, приложения, работающего на рабочем столе имеет полное доверие). Если приложение не имеет полного доверия, <xref:System.TypeLoadException> возникает исключение.  
  
 Формат полного имени типа, определяется формулой <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя каталога, содержащего приложение.</summary>
        <value>Имя базовой папки приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая папка приложения — где диспетчер сборок начинает поиск сборок.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> Свойства может влиять на какие разрешения предоставляются с доменом приложения. Например домен приложения, рассчитанные на локальном компьютере, обычно получает полное доверие, основанное на его исходном размещении. Тем не менее если <xref:System.AppDomainSetup.ApplicationBase%2A> , свойство <xref:System.AppDomain> присвоено полное имя в интрасети каталог <xref:System.AppDomainSetup.ApplicationBase%2A> параметр ограничивает разрешения, предоставленные в домен приложения до LocalIntranet, даже если домен приложения действительно исходит от локального компьютера.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.AppDomainSetup.ApplicationBase%2A> свойство, чтобы задать расположение, где загрузчик сборок начинает поиск сборок для загрузки в новый домен приложения.  
  
> [!NOTE]
>  Необходимо убедиться, что папка существует.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя приложения.</summary>
        <value>Имя приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как задать <xref:System.AppDomainSetup.ApplicationName%2A> свойства при создании нового домена приложения.  
  
 В примере создается новый домен приложения и затем вызывает <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> метод, чтобы загрузить пример сборку в домене приложения и создайте экземпляр `Worker` класса. `Worker` Класс наследует <xref:System.MarshalByRefObject>, поэтому в примере можно использовать прокси-сервера, возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> для вызова `TestLoad` метод.  
  
 `TestLoad` Метод загружает сборку с вами. Необходимо указать имя допустимым, полное имя сборки, или закомментируйте <xref:System.Reflection.Assembly.Load%28System.String%29> метод. `TestLoad` Метод перечислены сборки, которые загружаются в новом домене приложения, показывающая загрузку указанной сборки и сборка примера.  
  
 В примере используется <xref:System.LoaderOptimizationAttribute> атрибут, чтобы сообщить загрузчик сборок, как приложение будет совместное использование кода между доменами приложений.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содержащий сведения о безопасности и доверии.</summary>
        <value>Объект, содержащий сведения о безопасности и доверии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является `null` при <xref:System.AppDomainSetup> создается. После изменения его невозможно будет восстановить значение ссылкой на null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство имеет значение объекта <see cref="T:System.Security.Policy.ApplicationTrust" />, удостоверение приложения которого не соответствует удостоверению приложения объекта <see cref="T:System.Runtime.Hosting.ActivationArguments" />, возвращенного свойством <see cref="P:System.AppDomainSetup.ActivationArguments" />. Если свойство <see cref="P:System.AppDomainSetup.ActivationArguments" /> имеет значение <see langword="null" />, исключение не вызывается.</exception>
        <exception cref="T:System.ArgumentNullException">Для свойства задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя области, определенной для приложения, где создаются теневые копии файлов.</summary>
        <value>Полный путь к каталогу и полное имя файла, соответствующие создаваемой теневой копии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы это свойство, чтобы оказывать влияние <xref:System.AppDomainSetup.ApplicationName%2A> свойства необходимо также задать значение. Если <xref:System.AppDomainSetup.ApplicationName%2A> свойство не задано, <xref:System.AppDomainSetup.CachePath%2A> свойство учитывается и расположению теневых копий кэша по умолчанию используется кэш загрузки.  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя файла конфигурации для домена приложения.</summary>
        <value>Имя файла конфигурации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В файле конфигурации описываются правила поиска и данные конфигурации для домена приложения. Узел, который создает домен приложения отвечает за предоставление этих данных, так как значения изменяются от ситуации.  
  
 Например данные конфигурации для приложений ASP.NET хранится для каждого приложения, сайта и компьютером, во время хранения данных конфигурации для исполняемого файла для каждого приложения, пользователя и компьютера. Только у узла есть особенностей данные конфигурации для конкретного случая.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, выполняется ли поиск загружаемых сборок в базовой папке приложения и в папке приватных двоичных файлов.</summary>
        <value>Значение <see langword="true" />, если поиск не разрешен; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> свойство `true`, значение <xref:System.AppDomainSetup.ApplicationBase%2A> свойство учитывается. То есть сборки не проверяются для в каталогах, указанных <xref:System.AppDomainSetup.ApplicationBase%2A> свойство. Кроме того, значения <xref:System.AppDomainSetup.PrivateBinPath%2A> свойство и <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> свойства игнорируются. Сборки не проверяются для в каталогах, указанных <xref:System.AppDomainSetup.PrivateBinPath%2A> свойство.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Свойство обеспечивает дополнительный уровень контроля над процесс загрузки. В обычной сборке, загрузка последовательности, базовой папки приложения проверяется перед <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> события. Тем не менее, некоторые приложения может потребоваться загрузка сборок с составным файлом OLE в документе или в разных местах известных, ни в глобальном кэше сборок, так и в каталогах, указанных <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> свойства. Такие приложения могут использовать <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> свойства во избежание задержки, вызванные Обычная проверка и следует избегать загрузки копии необходимой сборки, которые могут быть расположены в обычно осуществляется поиск.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, допускает ли домен приложения перенаправление привязки сборок.</summary>
        <value>Значение <see langword="true" />, если перенаправление сборок запрещено; значение <see langword="false" />, если оно разрешено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Свойство предназначено для использования служб и серверных приложений, в которых перенаправление привязки сборок не является частью сценария приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, разрешена ли загрузка сборок для этого домена приложения по протоколу HTTP.</summary>
        <value>Значение <see langword="true" />, если загрузка сборок по протоколу HTTP запрещена; значение <see langword="false" />, если она разрешена.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Свойство предназначено для использования служб и серверных приложений, в которых загрузка кода из интрасети или Интернета не является частью сценария приложения.  
  
> [!CAUTION]
>  Значение по умолчанию для <xref:System.AppDomainSetup.DisallowCodeDownload%2A> свойство `false`. Этот параметр является небезопасным для служб. Чтобы помочь предотвратить загрузку частично доверенным кодом службы, значение этого свойства `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, применяется ли к домену приложения раздел [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) файла конфигурации.</summary>
        <value>Значение <see langword="true" />, если раздел <see langword="&lt;publisherPolicy&gt;" /> файла конфигурации для домена приложения игнорируется; значение <see langword="false" />, если объявленная политика издателя применяется.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Свойство специально применяется к веб-приложение, которое загружается локально. Это свойство используется для предотвращения вредоносных попыток выполнить небезопасное веб-приложение в безопасном режиме.  
  
 Дополнительные сведения о возможностях обойти политику издателя, см. в разделе [Перенаправление версий сборок](~/docs/framework/configure-apps/redirect-assembly-versions.md) раздела. Дополнительные сведения о безопасном режиме см. разделе «Проверка файлов конфигурации» [Обнаружение сборок в среде выполнения](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) раздела.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает базовую папку, в которой находится папка для динамически создаваемых файлов.</summary>
        <value>Каталог, в котором расположена папка <see cref="P:System.AppDomain.DynamicDirectory" />.  

 <block subset="none" type="note"><para>  
 Возвращаемое значение этого свойства отличается от присвоенного значения.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Это свойство используется, чтобы задать базовый каталог, куда будут записываться динамического каталог для нового домена приложения. При загрузке кода в новом домене приложения сборки, разрешения сборки сначала выполнит поиск обычно осуществляется поиск. Если не удается найти сборку, он ищет в динамических каталог, который возвращается методом <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> свойство. Динамические сборки, которые будут загружаться и выполняться задачей новый домен приложения можно разместить существует.  
  
 При назначении путь к <xref:System.AppDomainSetup.DynamicBase%2A> свойство, добавляется дополнительный подкаталог; в этом подкаталоге называется хэш-код значение, присваиваемое <xref:System.AppDomainSetup.ApplicationName%2A> свойство. Таким образом впоследствии возвращаемый этим свойством базового каталога всегда отличается от значения, присвоенного.  
  
> [!IMPORTANT]
>  Присвоение этому свойству значение не создает все каталоги. Каталоги должны быть созданы и протестирован код, который использует их.  
  
 Динамические каталог является подкаталогом <xref:System.AppDomainSetup.DynamicBase%2A>. Его простое имя — значение, возвращенное <xref:System.AppDomainSetup.ApplicationName%2A> свойство, чтобы его формат *исходный путь*\\*хэш-код*\\*имя_приложения*.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.AppDomainSetup.DynamicBase%2A> проверяет свойство, чтобы задать путь домена приложения при загрузке динамические сборки.  
  
 В примере создается <xref:System.AppDomainSetup> и устанавливает его <xref:System.AppDomainSetup.ApplicationName%2A> свойства «Пример» и его <xref:System.AppDomainSetup.DynamicBase%2A> свойства «C:\DynamicAssemblyDir». Затем выполняется отображение <xref:System.AppDomainSetup.DynamicBase%2A> свойства, чтобы показать, что хэш-код имени приложения, добавленную в подкаталог путь, по которому была изначально назначена.  
  
> [!NOTE]
>  В этом примере базовый каталог предназначен для выходящих за пределы путь поиска сборок для примера приложения. Не забудьте скомпилировать этот пример в другом месте. Удаление базового каталога и всех его подкаталогах при каждом запуске примера.  
  
 В примере создается новый домен приложения с помощью <xref:System.AppDomainSetup> объекта. Затем в примере создается dynamic directory, если он еще не существует. Несмотря на то, что в примере используется домен приложения <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> свойство для получения имени динамического каталога, она может легко создать каталог заранее путем объединения исходный путь, хэш-код имени приложения и Имя приложения.  
  
 В примере имеется `GenerateDynamicAssembly` метод, который создается сборка с именем `DynamicHelloWorld.dll` и сохраняет его в каталоге динамического новый домен приложения. Динамическая сборка содержит один тип `HelloWorld`, который имеет статический метод (`Shared` метод в Visual Basic) с именем `HelloFromAD`. Вызов этого метода имя домена приложения.  
  
 `Example` Класс является производным от <xref:System.MarshalByRefObject>, поэтому пример можно создать экземпляр класса в новом домене приложения и вызвать его `Test` метод. `Test` Метод загружает динамическую сборку по его отображаемому имени и вызывает статический `HelloFromAD` метод.  
  
 Можно отобразить, написав код для сборки с именем, что dynamic directory выполняется после обычно осуществляется поиск `DynamicHelloWorld.dll` и компиляции его в том же каталоге, что в этом примере. Сборка должна иметь класс с именем `HelloWorld` со статическим методом с именем `HelloFromAD`. Этот метод не обязательно иметь ту же функциональность, что в примере; она может просто отображать строку в консоль. Сборка должна также иметь <xref:System.Reflection.AssemblyVersionAttribute> атрибут, который задает его версию 1.0.0.0. При запуске примера, сборка, в которой компилируется в текущем каталоге находится перед поиска dynamic directory.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Это свойство не может быть установлено, поскольку имя приложения в домене приложения равно <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML-данные конфигурации, заданные методом <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, который переопределяет XML-данные конфигурации приложения.</summary>
        <returns>Массив, содержащий XML-данные конфигурации, заданные с помощью метода <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, или <see langword="null" />, если метод <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> не вызывался.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод позволяет переопределить данные конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` переопределяет сведения о файле конфигурации приложения. Например когда приложение Example.exe создает новый домен приложения, можно переопределить, первоначально полученную из файла Example.exe.config сведения о конфигурации.  
  
> [!IMPORTANT]
>  Некоторые пользователи информации из файла конфигурации, не используйте сведения, сохраненные с <xref:System.AppDomainSetup.SetConfigurationBytes%2A> метод. Среда выполнения это не применяется. Чтобы убедиться, что все сведения о файле конфигурации переопределен в новый домен приложения, используйте <xref:System.AppDomainSetup.ConfigurationFile%2A> свойство, чтобы указать файл конфигурации. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод влияет на привязки сборок.  
  
 XML-данные в `value` совпадает со значением XML в файле конфигурации normal, за исключением того, что он хранился в качестве <xref:System.Byte> массива.  
  
 Чтобы получить доступ к конфигурации байты для домена приложения, используйте <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> свойство для получения <xref:System.AppDomainSetup> для домена приложения, а затем использовать <xref:System.AppDomainSetup.GetConfigurationBytes%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение файла лицензии, связанного с этим доменом.</summary>
        <value>Имя и расположение файла лицензии.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет политику оптимизации, используемую для загрузки исполняемого файла.</summary>
        <value>Константа перечислимого типа, которая используется с атрибутом <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается динамическая сборка и сохраняется на диске, а затем используется <xref:System.AppDomainSetup.LoaderOptimization%2A> свойство, чтобы задать политику оптимизации, используемую для загрузки сборки в домен приложения.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список помеченных флагом <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> сборок, которые видимы коду с частичным доверием в изолированном домене приложения.</summary>
        <value>Массив частичных имен сборок, где каждое частичное имя состоит из простого имени сборки и открытого ключа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> атрибут (APTCA) может быть сделан условного путем настройки ее <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> свойства <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Сборку APTCA, который помечен атрибутом <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> не может использоваться кодом с частичным доверием, если ведущее приложение не разрешает его.  
  
 Узел изолированный домен приложения позволяет коду в домене приложения, использование сборок с атрибутов conditional APTCA, создав массив, содержащий простое имя и открытый ключ каждой сборки и присвоив массива к этому свойству. Например элемент массива может выглядеть следующим образом: «MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9».  
  
> [!IMPORTANT]
>  Если вы используете подкласс <xref:System.AppDomainManager>и в сборке, определяющей он зависит от сборки, которые помечены с условным атрибутом APTCA, необходимо включить эти сборки в списке, который передается <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> свойство <xref:System.AppDomainSetup>использовалась для создания доменов приложений. В противном случае будут отключены сборки с условным атрибутом APTCA.  
  
> [!NOTE]
>  При отладке приложения, на котором выполняется в изолированном домене приложения, некоторые <xref:System.Security.SecurityException> сообщений можно вводить в заблуждение. Например, сообщение может быть указано, что одной из сборок с полным доверием имеет только ограниченные разрешения, когда фактическую причину проблемы, требования безопасности, превышающий набор разрешений изолированного домена приложения распространится на границе изолированный домен приложения и сбой.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает список каталогов в базовой папке приложения, в которых выполняется поиск закрытых сборок.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытые сборки развертываются в ту же структуру каталогов, что и приложение. Если каталоги, заданные для <xref:System.AppDomainSetup.PrivateBinPath%2A> не находящиеся под <xref:System.AppDomainSetup.ApplicationBase%2A>, они игнорируются.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строковое значение, включающее <see cref="P:System.AppDomainSetup.ApplicationBase" /> в путь поиска для приложения или исключающее его из пути поиска для приложения, чтобы поиск выполнялся только в <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для включения пути базовой папки приложения при поиске сборок; любое непустое строковое значение для исключения пути. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте это свойство задано любое непустое строковое значение, включая <xref:System.String.Empty?displayProperty=nameWithType> ("»), чтобы исключить пути каталога приложения — то есть <xref:System.AppDomainSetup.ApplicationBase%2A> — из пути поиска для приложения и для поиска сборок только в <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отключено ли кэширование интерфейсов для вызовов взаимодействия в домене приложения, так что <c>QueryInterface</c> выполняется для каждого вызова.</summary>
        <value><see langword="true" />, если кэширование интерфейсов отключено для вызовов взаимодействия в доменах приложения, созданных с текущим объектом <see cref="T:System.AppDomainSetup" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отключение кэширования интерфейсов оказывает значительное влияние на производительность вызовов взаимодействия.  
  
 Этот член является введен в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">Перечислимый набор строковых значений, задающий переключатели совместимости, или значение <see langword="null" /> для снятия существующих переключателей совместимости.</param>
        <summary>Устанавливает заданные переключатели, благодаря чему домен приложения становится совместимым с предыдущими версиями платформы .NET Framework для указанных аспектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основные версии платформы .NET Framework иногда внесены существенные изменения из предыдущей версии. Например [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] представляет небольшое количество критических изменений из [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Используйте <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> метод, чтобы указать, что один или несколько этих критических изменений следует выполнить откат для домена приложения, чтобы сделать поведение, совместимой с предыдущей версии платформы .NET Framework.  
  
 При каждом вызове этого метода он заменяет существующие параметры коммутатора. Чтобы удалить параметры, укажите `null` для `switches` параметра.  
  
 Набор строковых значений, указываемое для `switches` может быть массив простых строк, поскольку массивы реализуют <xref:System.Collections.IEnumerable> интерфейс.  
  
 Ниже приведены примеры параметров совместимости, которые можно задать для восстановления поведения предыдущих версий платформы .NET Framework.  
  
|Параметр|Значение|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Code access security (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включена в этом домене приложения. См. в разделе [ &lt;NetFx40_LegacySecurityPolicy&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Значения по умолчанию для сортировки строк [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включены в этом домене приложения. Успешно восстановление устаревший порядок сортировки также требуется библиотека динамической компоновки sort00001000.dll доступен в локальной системе. См. в разделе [ &lt;CompatSortNLSVersion&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Значения по умолчанию для сортировки строк [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и Unicode 5.0, включенные в этот домен приложения. Также успешно восстановление устаревший порядок сортировки требуется библиотека динамической компоновки sort00060101.dll доступен в локальной системе.|  
|«NetFx40_TimeSpanLegacyFormatMode»|<xref:System.TimeSpan> поведение для форматирования [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включена в этом домене приложения. См. в разделе [ &lt;TimeSpan_LegacyFormatMode&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и в разделе «Восстановление форматирование прежних версий TimeSpan» <xref:System.TimeSpan> раздела.|  
|«UseRandomizedStringHashAlgorithm»|Среда выполнения вычисляет хэш-коды для строк на основе доменов приложения, вместо использования один алгоритм хэширования, который создает последовательный хэш-код между доменами приложений. См. в разделе [ &lt;UseRandomizedStringHashAlgorithm&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; элемент</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; элемент</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Массив, содержащий XML-данные конфигурации для домена приложения.</param>
        <summary>Предоставляет XML-данные конфигурации для домена приложения, заменяя XML-данные конфигурации приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод предоставляет способ заменить данные конфигурации приложения, которое создает новый домен приложения. Сведения о файле конфигурации в `value` заменяет сведения о файле конфигурации приложения. Например когда приложение Example.exe создает новый домен приложения, его можно заменить данные конфигурации, первоначально полученную из файла Example.exe.config.  
  
> [!IMPORTANT]
>  Некоторые пользователи информации из файла конфигурации, не используйте сведения, сохраненные с <xref:System.AppDomainSetup.SetConfigurationBytes%2A> метод. Среда выполнения это не применяется. Чтобы убедиться, что все сведения о файле конфигурации будет заменен в новый домен приложения, используйте <xref:System.AppDomainSetup.ConfigurationFile%2A> свойство, чтобы указать файл конфигурации. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Метод влияет на привязки сборок.  
  
 XML-данные в `value` совпадает со значением XML в файле конфигурации normal, за исключением того, что он хранился в качестве <xref:System.Byte> массива.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Схема параметров среды выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">Имя переопределяемой функции сравнения строк.</param>
        <param name="functionVersion">Версия функции. Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] значение должно быть больше или равно 1.</param>
        <param name="functionPointer">Указатель на функцию, переопределяющую <paramref name="functionName" />.</param>
        <summary>Предоставляет среду CLR с резервной реализацией функции сравнения строк.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующее строковое сравнение и сортировка методы могут быть переопределены <xref:System.AppDomainSetup.SetNativeFunction%2A> метод:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Сведения об этих функциях см. в разделе [функции поддержки национального языка](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="functionVersion" /> не равно 1 или выше.  
  
-или- 
 <paramref name="functionPointer" /> — <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имена каталогов, содержащих сборки, для которых будут созданы теневые копии.</summary>
        <value>Список имен каталогов, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если теневое копирование включено, значение по умолчанию является теневой копии всех сборок, найденные в процессе поиска; то есть из каталогов, указанных <xref:System.AppDomainSetup.PrivateBinPath%2A> и <xref:System.AppDomainSetup.ApplicationBase%2A> свойства. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Свойство ограничивает теневое копирование сборок в каталогах, указанных <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Если не присвоить строку <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> свойство, или если это свойство задано `null`, все сборки в каталогах, указанных <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> свойства создаются теневые копии.  
  
> [!IMPORTANT]
>  Пути к каталогам не должны содержать точку с запятой, так как она является разделителем. Escape-символа для точки с запятой не существует.  
  
 При теневое копирование включено, файлы сборки копируются в другое место, прежде чем сборки загружаются. Исходный файл сборки не заблокирован, поэтому он может быть обновлен. Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строку, позволяющую определить, включено ли теневое копирование.</summary>
        <value>Строковое значение true, свидетельствующее о том, что теневое копирование включено, или значение false, указывающее на то, что оно отключено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку, которая задает целевую версию и профиль .NET Framework для домена приложения, в формате, который может быть проанализирован конструктором <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />.</summary>
        <value>Целевая версия и профиль платформы .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установите это свойство, чтобы сообщить выполняющаяся версия платформы .NET Framework, что домен приложения будет использоваться для загрузки и запуска сборок, которые были скомпилированы для целевой версии или профиля. Если выполняющаяся версия платформы .NET Framework необязательно варианты поведения, влияющие на совместимость кода, который был скомпилирован с целевой версией, его можно включить или отключить эти варианты поведения, чтобы улучшить совместимость соответствующим образом. Это может быть полезно, если приложение поддерживает надстройки, скомпилированные с несколькими версиями платформы .NET Framework, запуская их в отдельных доменах приложений.  
  
 Для клиентских приложений, значение <xref:System.AppDomainSetup.TargetFrameworkName%2A> свойства выводится из <xref:System.Runtime.Versioning.TargetFrameworkAttribute> атрибута. В [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] и более поздней версии, этот атрибут добавляется к сборке, автоматически на основе параметра проекта **требуемой версии .NET Framework** свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>