<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b76c85e1e9a70132f964767500d5f63f74d6880" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951790" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет делегат — структуру данных, указывающую на статический метод или на экземпляр класса и метод экземпляра этого класса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Класс является базовым классом для типов делегатов. Однако только система и компиляторы могут явно наследовать <xref:System.Delegate> класс или из <xref:System.MulticastDelegate> класса. Допускается также не наследовать новый тип является типом делегата. <xref:System.Delegate> Класс не является типом делегата; это класс, используемый для получения типов делегата.  
  
 Большинство языков реализовать `delegate` ключевое слово и компиляторы для этих языков, могут наследовать <xref:System.MulticastDelegate> класса; таким образом, пользователи должны использовать `delegate` ключевое слово языка.  
  
> [!NOTE]
>  Среда CLR предоставляет `Invoke` метод для каждого типа делегата с сигнатурой делегата. У вас нет явно вызвать этот метод из C#, Visual Basic или Visual C++, поскольку компиляторы вызывают его автоматически. `Invoke` Метод полезен в [отражения](~/docs/framework/reflection-and-codedom/reflection.md) , если требуется найти сигнатуре типа делегата.  
  
 Среда CLR предоставляет каждый тип делегата с `BeginInvoke` и `EndInvoke` методы, для поддержки асинхронного вызова делегата. Дополнительные сведения об этих методах см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Объявление типа делегата устанавливает контракт, определяющий сигнатуру одного или нескольких методов. Делегат — это экземпляр типа делегата, который есть ссылки на:  
  
-   Метод экземпляра типа и может быть назначен для типа целевого объекта.  
  
-   Метод экземпляра типа, скрытые `this` параметр в списке формальных параметров. Считается, что делегат является делегат открытого экземпляра.  
  
-   Статический метод.  
  
-   Статический метод и целевым объектом может быть назначен к первому параметру метода. Делегат называют закрытым в отношении своего первого аргумента.  
  
 Дополнительные сведения о привязке делегата, см. в разделе <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 делегат может представлять метод только в том случае, если подпись метода точно соответствует сигнатуре, указанной в типе делегата. Таким образом поддерживаются только первый и третий элементы в списке выше, и первый элемент требует точного соответствия типов.  
  
 Когда делегат представляет метод экземпляра, закрытый в отношении своего первого аргумента (наиболее распространенный случай), делегат содержит ссылку на точку входа метода и ссылку на объект, называемый целевым, которые имеют тип, может быть назначен для типа, который определен метод. Если делегат представляет открытый метод экземпляра, он хранит ссылку на точку входа метода. Сигнатура делегата должна содержать скрытого `this` параметр в списке формальных параметров; таким образом, делегат имеет ссылку на целевой объект и целевой объект указывается при вызове делегата.  
  
 Когда делегат представляет статический метод, делегат содержит ссылку на точку входа метода. Когда делегат представляет статический метод, закрытый в отношении своего первого аргумента, делегат сохраняет ссылку на точку входа метода и ссылку на целевой объект может быть назначен типу первого аргумента метода. При вызове делегата первый аргумент статического метода получает целевой объект.  
  
 Список вызовов делегата представляет упорядоченный набор делегатов, в которых каждый элемент списка вызывает один из методов, представленный делегатом. Список вызовов может содержать повторяющиеся методы. Во время вызова методы вызываются в порядке, в котором они появляются в списке вызовов. Делегат пытается вызвать все методы в своем списке вызовов; дубликаты вызываются в том случае, когда каждый раз, они отображаются в списке вызовов. Делегаты являются неизменными. После создания списка вызовов делегата остается неизменным.  
  
 Делегаты называются групповыми или combinable, так как делегат может вызывать один или несколько методов и могут использоваться в операции объединения.  
  
 Объединение операций, таких как <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A>, не изменяют существующие делегатов. Вместо этого такие операции возвращают новый делегат, который содержит результаты операции, делегат без изменений или `null`. Возвращает операцию объединения `null` когда результатом операции является делегатом, который не ссылается хотя бы один метод. Операцию объединения возвращает делегат без изменений, если запрошенная операция не влияет.  
  
> [!NOTE]
>  Управляемые языки используйте <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A> методы для реализации операций делегата. К ним относятся `AddHandler` и `RemoveHandler` операторы объявления в Visual Basic и операторов += и-= на типы делегатов в C#.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], универсальный делегат типы могут иметь параметры вариантного типа. Параметры контравариантного типа может использоваться как типы параметров делегата, а параметр ковариантного типа может использоваться в качестве возвращаемого типа. Эта функция позволяет универсальный метод-делегат типами, полученными из одного определения универсального типа, чтобы быть совместимы по назначению Если аргументов их типа являются ссылочными типами в отношение наследования, как описано в [ковариации и Контрвариантность](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, но не могут сочетаться два делегата, так как типы не совпадают.  
  
 Если вызываемый метод вызывает исключение, выполнение этого метода прекращается, исключение передается обратно в вызывающий объект делегата и остальные методы в списке вызова не вызываются. Перехват исключения в вызывающий объект не изменяет это поведение.  
  
 Если подпись методы, вызываемые через делегат содержит возвращаемое значение, делегат возвращает возвращаемое значение последнего элемента в списке вызовов. Когда сигнатура включает параметр, который передается по ссылке, конечное значение параметра является результатом каждый метод в списке вызовов, последовательное выполнение и обновление значения параметра.  
  
 Ближайшим эквивалентом делегата в C является указатель на функцию. Делегат может представлять статический метод или метод экземпляра. Когда делегат представляет метод экземпляра, он сохраняет не только ссылку на точку входа метода, но ссылка на экземпляр класса. В отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированным.  
  
   
  
## Examples  
 В следующем примере показано, как определить делегат с именем `myMethodDelegate`. Экземпляры этого делегата создаются для метода экземпляра и статический метод вложенного `mySampleClass` класса. Делегат для метода экземпляра требуется экземпляр `mySampleClass`. `mySampleClass` Экземпляр сохраняется в переменной с именем `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Асинхронный вызов синхронных методов</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Делегаты (Руководство по программированию на C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Делегаты (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Практическое руководство. Определение и использование делегатов (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Обработка и вызов событий</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый делегат.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Экземпляр класса, метод <paramref name="method" /> которого вызывает делегат.</param>
        <param name="method">Имя представленного делегатом метода экземпляра.</param>
        <summary>Инициализирует делегат, вызывающий заданный метод экземпляра указанного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не может использоваться в коде приложения. Для создания делегата путем указания имени метода экземпляра, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метод, который задает имя метода и целевым объектом. Например <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> перегрузку метода создает делегат для метода экземпляра с заданным именем.  
  
 Этот конструктор создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Произошла ошибка связывания с целевым методом.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором определен метод <paramref name="method" />.</param>
        <param name="method">Имя представленного делегатом статического метода.</param>
        <summary>Инициализирует делегат, вызывающий заданный статистический метод указанного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не может использоваться в коде приложения. Для создания делегата, указав имя статического метода, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метод, который задает имя метода, но не указывает на целевой объект. Например <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> перегруженная версия метода создает статический делегат для метода с указанным именем.  
  
 Этот конструктор создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="target" /> представляет открытый универсальный тип.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию делегата.</summary>
        <returns>Неполная копия делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клон имеет такую же <xref:System.Type>, целевой объект, метод и список вызовов, что и исходный делегат.  
  
 Неполная копия создает новый экземпляр того же типа, что и исходный объект, а затем копирует нестатические поля исходного объекта. Если поле является типом значения, выполняется копию бит за битом поля. Если поле является ссылочным типом, ссылка копируется, а не объект, который указывает ссылка; Следовательно ссылки в исходном объекте и в клоне указывают на тот же объект. Напротив глубокую копию объекта дублирует все, что прямо или косвенно ссылаться на поля в объекте.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сцепляет списки вызовов заданных групповых (комбинируемых) делегатов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Массив комбинируемых делегатов.</param>
        <summary>Сцепляет списки вызовов массива делегатов.</summary>
        <returns>Новый делегат со списком вызовов, представляющим собой сцепление списков вызовов делегатов, заданных в массиве <paramref name="delegates" />. Возвращает <see langword="null" />, если <paramref name="delegates" /> имеет значение <see langword="null" />, либо <paramref name="delegates" /> содержит нуль элементов, либо каждый элемент в <paramref name="delegates" /> имеет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `delegates` массив содержит элементы, являющиеся `null`, эти элементы игнорируются.  
  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, как описано в [Ковариация и контравариация](~/docs/standard/generics/covariance-and-contravariance.md), но не могут сочетаться два делегата, так как типы не полностью совпадают.  
  
 <xref:System.Delegate.Combine%2A> полезно для создания обработчиков событий, которое происходит вызов несколько методов время события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не все ненулевые элементы в <paramref name="delegates" /> являются экземплярами одного типа делегата.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Делегат, список вызовов которого передан первым.</param>
        <param name="b">Делегат, список вызовов которого передан вторым.</param>
        <summary>Сцепляет списки вызовов двух делегатов.</summary>
        <returns>Новый делегат со списком вызовов, представляющим собой сцепление списков вызовов, заданных в параметрах <paramref name="a" /> и <paramref name="b" /> в указанном порядке. Возвращает <paramref name="a" />, если <paramref name="b" /> имеет значение <see langword="null" />; возвращает <paramref name="b" />, если <paramref name="a" /> является пустой ссылкой; возвращает пустую ссылку, если <paramref name="a" /> и <paramref name="b" /> являются пустыми ссылками.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, как описано в [Ковариация и контравариация](~/docs/standard/generics/covariance-and-contravariance.md), но не могут сочетаться два делегата, так как типы не полностью совпадают.  
  
 <xref:System.Delegate.Combine%2A> полезно для создания обработчиков событий, которое происходит вызов несколько методов время события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение обоих параметров, <paramref name="a" /> и <paramref name="b" />, не равно <see langword="null" />, и эти параметры <paramref name="a" /> и <paramref name="b" /> не являются экземплярами одного и того же типа делегата.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Групповой (комбинируемый) делегат, чей список вызовов необходимо добавить в конец списка вызовов текущего группового (комбинируемого) делегата.</param>
        <summary>Сцепляет списки вызовов заданного группового (комбинируемого) делегата и текущего группового (комбинируемого) делегата.</summary>
        <returns>Новый групповой (комбинируемый) делегат со списком вызовов, состоящим из сцепления списков вызовов текущего группового (комбинируемого) делегата и делегата, заданного в параметре <paramref name="d" />, или текущий групповой (комбинируемый) делегат, если <paramref name="d" /> имеет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применим только в том случае, если текущий делегат является многоадресным (комбинируемый).  
  
 Текущая реализация просто вызывает <xref:System.MulticastNotSupportedException>.  
  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Создается всегда.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает делегат указанного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом. На платформе .NET Framework версий 1.0 и 1.1 поддерживаются только статические методы.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версий 1.0 и 1.1 перегрузка метода создает делегаты только для статических методов. В .NET Framework версии 2.0 перегрузка метода также можно создать открытый экземпляр метода делегатов. то есть методы экземпляра делегатов, которые явным образом предоставить скрытые первый аргумент. Подробное описание см. в разделе Дополнительные Общие <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегрузку метода, который позволяет создать все комбинации открытых или закрытых делегатов для экземпляров или статических методов и при необходимости укажите в качестве первого аргумента.  
  
> [!NOTE]
>  Эта перегрузка метода следует использовать при делегат не закрыт в отношении своего первого аргумента, так как она работает немного быстрее в этом случае.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода с указанием `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 В .NET Framework версии 2.0 типы параметров и тип возвращаемого значения делегата, созданного с помощью этой перегрузки метода должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать. Это значение представляет это ослабление поведение привязки в .NET Framework версий 1.0 и 1.1, где типы должны в точности совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано два типа делегатов, которые могут быть созданы с помощью этой перегрузки метода: Откройте метода экземпляра, а через статический метод.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа, делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод <xref:System.Reflection.MethodInfo> , но первый аргумент; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и два типа делегата: `D1` принимает экземпляр `C` и типа string, и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является статическим методом и платформа .NET Framework имеет версию 1.0 или 1.1.  
  
-или- 
 Не удалось выполнить связывание <paramref name="method" />.  
  
-или- 
 <paramref name="method" /> не является объектом <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="firstArgument">Объект, с которым связан делегат, или <see langword="null" /> для интерпретации <paramref name="method" /> как <see langword="static" /> (<see langword="Shared" /> в Visual Basic).</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод или метод экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода с указанием `true` для `throwOnBindFailure`. Эти две перегрузки предоставляют самый гибкий способ создания делегатов. Их можно использовать для создания делегатов для статических методов или методов экземпляра и при необходимости укажите первый аргумент.  
  
> [!NOTE]
>  Если первый аргумент не указан, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метода, должны иметь совместимые типы возвращаемых значений. То есть тип возвращаемого значения `method` должен быть назначен тип возвращаемого значения `type`.  
  
 Если `firstArgument` будет указано, оно передается `method` каждый раз при вызове делегата; `firstArgument` говорят, что для привязки делегата, и делегат называется закрытым в отношении своего первого аргумента. Если `method` — `static` (`Shared` в Visual Basic), аргумент, предоставленный при вызове делегата список включает все параметры, кроме первого, если `method` является методом экземпляра, затем `firstArgument` передается со скрытым экземпляром параметр (представленный `this` в C#, либо by `Me` в Visual Basic).  
  
 Если `firstArgument` предоставляется, первый параметр `method` должен быть ссылочным типом, и `firstArgument` должны быть совместимы с этим типом.  
  
> [!IMPORTANT]
>  Если `method` — `static` (`Shared` в Visual Basic) и ее первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, затем `firstArgument` может быть типом значения. В этом случае `firstArgument` упаковывается автоматически. Автоматическая упаковка-преобразование не происходит для других аргументов, как в C# или Visual Basic функции вызвать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `type` явно включает в себя скрытый первый параметр `method`, говорят, что для представления открытый метод экземпляра делегата. При вызове делегата первый аргумент в списке аргументов передается в параметр скрытым экземпляром `method`.  
  
-   Если подписи `method` и `type` совпадают (то есть всех типов параметров совместимы), то делегат называется закрытым в отношении пустой ссылкой. Вызов делегата аналогично вызову метода экземпляра в неопределенном экземпляре, который не является особенно удобно, что необходимо сделать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является статическим, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `method` и `type` совпадают (то есть всех типов параметров совместимы), делегат называют представляющим открытый статический метод. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода.  
  
-   Если подпись `type` начинается со вторым параметром `method` и остальные типы параметров совместимы, то делегат называется закрытым в отношении пустой ссылкой. При вызове делегата, для первого параметра передается пустая ссылка `method`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 должны полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов делегата может представлять  
 Другой полезный способ представить гибкие Эта перегрузка <xref:System.Delegate.CreateDelegate%2A> — это то, что любой делегат может представлять четыре различных сочетаний сигнатуру метода и тип метода (статический или экземпляр). Рассмотрим тип делегата `D` с одним аргументом типа `C`. Ниже описаны методы `D` может представлять, игнорируя тип возвращаемого значения, так как он должен соответствовать во всех случаях:  
  
-   `D` может представлять любой метод экземпляра, который имеет ровно один аргумент типа `C`, независимо от того, какой тип принадлежит метод экземпляра. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром типа `method` принадлежит, и результирующий делегат называется закрытым в отношении этого экземпляра. (Разумеется, `D` также может быть закрыт на ссылку на null Если `firstArgument` является пустой ссылкой.)  
  
-   `D` может представлять метод экземпляра `C` , не имеет аргументов. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принимает один аргумент типа `C`, и что метод может принадлежать к любому типу. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый статический метод и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и тип `C`. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром класса `F`. Результирующий делегат представляет статический метод, который закрывается в отношении этого экземпляра `F`. Обратите внимание, что в случае, когда `F` и `C` относятся к одному типу, статический метод имеет два аргумента этого типа. (В этом случае `D` закрыт в отношении ссылкой на null, если `firstArgument` является пустой ссылкой.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показано четыре вида делегатов, которые могут быть созданы: закрытые методом экземпляра, открытый в отношении метода экземпляра, открытый в отношении статический метод и закрытый в отношении статического метода.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 В третьем примере код определяет единственный тип делегата и показано, что все методы, которые он может представлять.  
  
 **Пример 1**  
  
 В следующем примере кода демонстрируется четыре способа делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и три типа делегатов: `D1` принимает экземпляр `C` строку и `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`закрытых через экземпляр `C`, создается для метода экземпляра `M1`. Он вызывается с другими строками, чтобы показать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
-   Наконец, делегат типа `D3`, закрытый в отношении строки, создается для статического метода `M2`. Метод вызывается, чтобы показать, что он использует связанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показаны все методы могут представлять один тип делегата, с помощью <xref:System.Delegate.CreateDelegate%2A> метод для создания делегатов.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере кода определяется два класса `C` и `F`и тип делегата `D` с одним аргументом типа `C`. Классы иметь совпадающие статических методов и методов экземпляра `M1`, `M3`, и `M4`и класс `C` также содержит метод экземпляра `M2` , не имеет аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для экземпляра метода `M1` типа `C` и тип `F`; каждый из них закрыт через экземпляр соответствующего типа. Метод `M1` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа `C`. Это делегат открытого экземпляра, в котором аргумент делегата представляет скрытый первый аргумент метода экземпляра. Метод не имеет аргументов. Он называется, как будто это статический метод.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и тип `F`; это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и тип `F`; каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрыты в отношении своих первых аргументов . Метод `M4` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 Не удалось выполнить связывание <paramref name="method" />.  
  
-или- 
 <paramref name="method" /> не является объектом <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `false` для `ignoreCase` и `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является методом экземпляра.  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод, с заданным поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку метода можно создать открытый статический метод делегаты и открытые делегаты методов экземпляра — то есть делегаты, которые предоставляют скрытый первый аргумент методы экземпляра. Подробное описание см. в разделе Дополнительные Общие <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода, который позволяет создавать все комбинации открытых или закрытых делегатов для экземпляра или статические методы.  
  
> [!NOTE]
>  Эта перегрузка метода следует использовать при делегат не закрыт в отношении своего первого аргумента, так как она работает немного быстрее в этом случае.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 должны полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано два типа делегатов, которые могут быть созданы с помощью этой перегрузки метода: Откройте метода экземпляра, а через статический метод.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа, делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод <xref:System.Reflection.MethodInfo> , но первый аргумент; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и два типа делегата: `D1` принимает экземпляр `C` и типа string, и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является объектом <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод заданного класса.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `false` для `ignoreCase` и `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
-или- 
 <paramref name="target" /> представляет собой открытый универсальный тип. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Объект <see cref="T:System.Type" />, представляющий тип создаваемого делегата.</param>
        <param name="firstArgument"><see cref="T:System.Object" />, являющийся первым аргументом метода, представленного делегатом. Для методов экземпляра он должен быть совместим с типом экземпляра.</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом и поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат заданного типа, представляющий указанный статический метод или метод экземпляра, либо значение <see langword="null" />, если значение параметра <paramref name="throwOnBindFailure" /> равно <see langword="false" /> и делегат не удалось связать с методом <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода и <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегрузку метода, который всегда создает исключение в случае сбоя процесса привязки, предоставляют самый гибкий способ для создания делегатов. Их можно использовать для создания делегатов для статических методов или методов экземпляра с или без первого аргумента.  
  
> [!NOTE]
>  Если первый аргумент не указан, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метода, должны иметь совместимые типы возвращаемых значений. То есть тип возвращаемого значения `method` должен быть назначен тип возвращаемого значения `type`.  
  
 Если `firstArgument` будет указано, оно передается `method` каждый раз при вызове делегата; `firstArgument` говорят, что для привязки делегата, и делегат называется закрытым в отношении своего первого аргумента. Если `method` — `static` (`Shared` в Visual Basic), аргумент, предоставленный при вызове делегата список включает все параметры, кроме первого, если `method` является методом экземпляра, затем `firstArgument` передается со скрытым экземпляром параметр (представленный `this` в C#, либо by `Me` в Visual Basic).  
  
 Если `firstArgument` предоставляется, первый параметр `method` должен быть ссылочным типом, и `firstArgument` должны быть совместимы с этим типом.  
  
> [!IMPORTANT]
>  Если `method` — `static` (`Shared` в Visual Basic) и ее первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, затем `firstArgument` может быть типом значения. В этом случае `firstArgument` упаковывается автоматически. Автоматическая упаковка-преобразование не происходит для других аргументов, как в C# или Visual Basic функции вызвать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `type` явно включает в себя скрытый первый параметр `method`, говорят, что для представления открытый метод экземпляра делегата. При вызове делегата первый аргумент в списке аргументов передается в параметр скрытым экземпляром `method`.  
  
-   Если подписи `method` и `type` совпадают (то есть всех типов параметров совместимы), то делегат называется закрытым в отношении пустой ссылкой. Вызов делегата аналогично вызову метода экземпляра в неопределенном экземпляре, который не является особенно удобно, что необходимо сделать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является статическим, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `method` и `type` совпадают (то есть всех типов параметров совместимы), делегат называют представляющим открытый статический метод. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода.  
  
-   Если подпись `type` начинается со вторым параметром `method` и остальные типы параметров совместимы, то делегат называется закрытым в отношении пустой ссылкой. При вызове делегата, для первого параметра передается пустая ссылка `method`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версии 1.0 и 1.1 должен полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов делегата может представлять  
 Другой полезный способ представить гибкие Эта перегрузка <xref:System.Delegate.CreateDelegate%2A> — это то, что любой делегат может представлять четыре различных сочетаний сигнатуру метода и тип метода (статический или экземпляр). Рассмотрим тип делегата `D` с одним аргументом типа `C`. Ниже описаны методы `D` может представлять, игнорируя тип возвращаемого значения, так как он должен соответствовать во всех случаях:  
  
-   `D` может представлять любой метод экземпляра, который имеет ровно один аргумент типа `C`, независимо от того, какой тип принадлежит метод экземпляра. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром типа `method` принадлежит, и результирующий делегат называется закрытым в отношении этого экземпляра. (Разумеется, `D` также может быть закрыт на ссылку на null Если `firstArgument` является `null`.)  
  
-   `D` может представлять метод экземпляра `C` , не имеет аргументов. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принимает один аргумент типа `C`, и что метод может принадлежать к любому типу. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый статический метод и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и тип `C`. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром класса `F`. Результирующий делегат представляет статический метод, который закрывается в отношении этого экземпляра `F`. Обратите внимание, что в случае, когда `F` и `C` относятся к одному типу, статический метод имеет два аргумента этого типа. (В этом случае `D` закрыт в отношении ссылкой на null, если `firstArgument` является `null`.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показано четыре вида делегатов, которые могут быть созданы: закрытые методом экземпляра, открытый в отношении метода экземпляра, открытый в отношении статический метод и закрытый в отношении статического метода.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 В третьем примере код определяет единственный тип делегата и показано, что все методы, которые он может представлять.  
  
 **Пример 1**  
  
 В следующем примере кода демонстрируется четыре способа делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и три типа делегатов: `D1` принимает экземпляр `C` строку и `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`закрытых через экземпляр `C`, создается для метода экземпляра `M1`. Он вызывается с другими строками, чтобы показать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
-   Наконец, делегат типа `D3`, закрытый в отношении строки, создается для статического метода `M2`. Метод вызывается, чтобы показать, что он использует связанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показано, все методы, которые могут представлять один тип делегата.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере кода определяется два класса `C` и `F`и тип делегата `D` с одним аргументом типа `C`. Классы иметь совпадающие статических методов и методов экземпляра `M1`, `M3`, и `M4`и класс `C` также содержит метод экземпляра `M2` , не имеет аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для экземпляра метода `M1` типа `C` и тип `F`; каждый из них закрыт через экземпляр соответствующего типа. Метод `M1` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа `C`. Это делегат открытого экземпляра, в котором аргумент делегата представляет скрытый первый аргумент метода экземпляра. Метод не имеет аргументов.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и тип `F`; это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и тип `F`; каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрыты в отношении своих первых аргументов . Метод `M4` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является объектом <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <summary>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается из заданного экземпляра класса с заданной установкой учета регистра.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является методом экземпляра.  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод заданного класса с заданной установкой учета регистра.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
-или- 
 <paramref name="target" /> представляет собой открытый универсальный тип. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод, вызываемый для заданного экземпляра класса с заданной установкой учета регистра и заданным поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является методом экземпляра.  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат заданного типа, представляющий заданный статический метод заданного класса с заданными установками учета регистра и поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
-или- 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
-или- 
 <paramref name="target" /> представляет собой открытый универсальный тип. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.  
  
-или- 
 Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</param>
        <summary>Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</summary>
        <returns>Объект, возвращаемый методом, представленным делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).  
  
-или- 
Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</exception>
        <exception cref="T:System.ArgumentException">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.  
  
-или- 
Один из инкапсулированных методов выбрасывает исключение.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.  
  
-или- 
 Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</param>
        <summary>Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</summary>
        <returns>Объект, возвращаемый методом, представленным делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод <xref:System.Delegate.DynamicInvoke%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).  
  
-или- 
Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</exception>
        <exception cref="T:System.ArgumentException">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.  
  
-или- 
Один из инкапсулированных методов выбрасывает исключение.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с текущим делегатом.</param>
        <summary>Определяет, принадлежат ли заданный объект и текущий делегат к одному типу, и одинаковы ли их целевые объекты, методы и списки вызовов.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="obj" /> и текущий делегат имеют одинаковые целевые объекты, методы и списки вызовов. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата были считаются равными, если их целевые объекты, методы и списки вызовов равны, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов, считаются идентичными только в том случае, если они имеют порядке и соответствующие элементы двух списков представляют один и тот же метод и целевой объект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код делегата.</summary>
        <returns>Хэш-код делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение этого метода не должны сохраняться по двум причинам. Во-первых хэш-функции класса может быть изменена для создания лучшего распределения. Во-вторых реализация по умолчанию этого класса не гарантирует, что то же значение будет возвращаться разные экземпляры.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список вызовов делегата.</summary>
        <returns>Массив делегатов, представляющих список вызовов текущего делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый из делегатов в массиве представляет ровно один метод.  
  
 Порядок делегатов в массиве является том же порядке, в котором текущий делегат вызывает методы, которые представляют эти делегаты.  
  
   
  
## Examples  
 В следующем примере присваивается три метода к делегату. Затем он вызывает <xref:System.Delegate.GetInvocationList%2A> метод для получения общего числа методов, назначенный делегату, выполнение делегатов в обратном порядке, а также выполнять методы, имя которого не включают подстроки «File».  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает статический метод, представленный текущим делегатом.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод, представленный текущим делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применим только в том случае, если текущий делегат представляет статический метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Не поддерживается.</param>
        <param name="context">Не поддерживается.</param>
        <summary>Не поддерживается.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод, представленный делегатом.</summary>
        <value>Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий метод, представленный делегатом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Первый делегат для операции сравнения.</param>
        <param name="d2">Второй делегат для операции сравнения.</param>
        <summary>Определяет, равны ли два заданных делегата.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="d1" /> и <paramref name="d2" /> равны; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата одного типа с одинаковые целевые объекты, методы и списки вызовов, считаются равными.  
  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата были считаются равными, если их целевые объекты, методы и списки вызовов равны, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов, считаются идентичными, если они имеют порядке и соответствующие элементы двух списков представляют один и тот же метод и целевой объект.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Первый делегат для операции сравнения.</param>
        <param name="d2">Второй делегат для операции сравнения.</param>
        <summary>Определяет, являются ли заданные делегаты неравными.</summary>
        <returns><see langword="true" />, если значения <paramref name="d1" /> и <paramref name="d2" /> не равны; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата считаются неравными, если они принадлежат разным типам или имеют различные методы, целевые объекты или списки вызовов.  
  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата считаются равными, если их целевые объекты, методы и списки вызовов, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов не равны, если они имеют различные размеры, если они упорядочены по-разному, или в том случае, если хотя бы один элемент из одного списка представляет метод или целевой объект, отличный от представленного соответствующим элементом в другом списке.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</param>
        <param name="value">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</param>
        <summary>Удаляет последнее вхождение списка вызовов делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным путем удаления из <paramref name="source" /> последнего вхождения списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />. Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />. Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" /> либо <paramref name="source" /> является пустой ссылкой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов `source`, затем список вызовов `value` говорят, что в списке вызовов `source`. Если список вызовов `value` встречается более одного раза в списке вызовов `source`, удаляется последнее вхождение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <exception cref="T:System.ArgumentException">Типы делегатов не совпадают.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</param>
        <param name="value">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</param>
        <summary>Удаляет все вхождения списка вызовов одного делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным путем удаления из списка вызовов <paramref name="source" /> всех вхождений списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />. Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />. Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" />, либо список вызовов <paramref name="source" /> содержит только списки вызовов <paramref name="value" />, либо <paramref name="source" /> является пустой ссылкой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов `source`, затем список вызовов `value` говорят, что в списке вызовов `source`. Если список вызовов `value` встречается более одного раза в списке вызовов `source`, все вхождения удаляются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <exception cref="T:System.ArgumentException">Типы делегатов не совпадают.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов текущего делегата.</param>
        <summary>Удаляет список вызовов одного делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным удаления списка вызовов <paramref name="value" /> из списка вызовов текущего делегата, если список вызовов <paramref name="value" /> найден в списке вызовов текущего делегата. Возвращает текущий делегат, если <paramref name="value" /> имеет значение <see langword="null" /> или список вызовов <paramref name="value" /> не найден в списке вызовов текущего делегата. Возвращает <see langword="null" />, если список вызовов <paramref name="value" /> равен списку вызовов текущего делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов текущего делегата, а затем список вызовов `value` происходит в списке вызовов текущего делегата. Если список вызовов `value` встречается более одного раза в списке вызовов текущего делегата, удаляется последнее вхождение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса, метод которого вызывает текущий делегат.</summary>
        <value>Объект, для которого текущий делегат вызывает метод экземпляра, если делегат представляет метод экземпляра, либо <see langword="null" /> если делегат представляет статический метод.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Если делегат вызывает один или несколько методов экземпляра, это свойство возвращает цель последнего метода экземпляра из списка вызовов.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>