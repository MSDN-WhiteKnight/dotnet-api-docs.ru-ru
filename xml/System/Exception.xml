<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c317015116e31905a01da5c72fd152dc823323f9" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57915065" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет ошибки, происходящие во время выполнения приложения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс является базовым классом для всех исключений. При возникновении ошибки, системой или выполняющееся приложение выдает, создавая исключение, содержащее сведения об ошибке. После создается исключение, он обрабатывается приложением или обработчиком исключений по умолчанию.  
  
 Содержание  
  
 [Ошибки и исключения](#Errors)   
 [Блоки try/catch](#TryCatch)   
 [Возможности типов исключений](#Features)   
 [Свойства класса исключений](#Properties)   
 [Вопросы производительности](#Performance)   
 [Повторное создание исключения](#Rethrow)   
 [Выбор стандартных исключений](#Standard)   
 [Реализация пользовательских исключений](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Ошибки и исключения  
 Ошибки времени выполнения может возникнуть по ряду причин. Однако не все ошибки должны обрабатываться как исключения в своем коде. Ниже приведены некоторые категории ошибок, которые могут возникнуть во время выполнения и соответствующие способы реагирования на них.  
  
-   **Ошибки использования.** Ошибка использования представляет ошибку в логике программы, которая может привести к исключению. Тем не менее ошибка должна быть устранена, не с помощью обработки исключений, но, изменив ошибочный код. Например, переопределение метода <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод в следующем примере предполагается, что `obj` аргумент всегда должен иметь значение null.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException> Исключение, которое возникает при `obj` — `null` можно устранить путем изменения в исходном коде явным образом проверки на значения null перед вызовом <xref:System.Object.Equals%2A?displayProperty=nameWithType> "override" и повторной компиляции. В следующем примере содержится исправленный исходный код, обрабатывающий `null` аргумент.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Вместо того чтобы использовать обработку исключений для ошибки использования, можно использовать <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> метод выявления ошибок использования в отладочных сборках и <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> метод выявления ошибок использования в отладочной и окончательной сборки. Дополнительные сведения см. в разделе [Утверждения в управляемом коде](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Ошибки программы.** Ошибки в программе является ошибкой времени выполнения, которая всегда является обязательной, написав код без ошибок.  
  
     В некоторых случаях ошибки в программе может отражать ожидаемое или подпрограмму ошибку. В этом случае можно избежать использования обработки исключений, чтобы разбираться с записью ошибок программы и вместо этого повторите операцию. Например, если пользователь должен ввести дату в определенном формате, можно выполнить синтаксический анализ строки даты, вызвав <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> метод, возвращающий <xref:System.Boolean> значение, указывающее, успешно ли операция анализа выполнена, вместо использования <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>метод, который вызывает <xref:System.FormatException> исключение, если строка даты невозможно преобразовать в <xref:System.DateTime> значение. Аналогично, если пользователь пытается открыть файл, который не существует, сначала можно вызвать <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> метод для проверки, является ли файл существует и, если оно отсутствует, запрос пользователю хочет создать его.  
  
     В других случаях ошибки в программе отражает условием непредвиденные ошибки, которое может быть обработано в коде. Например даже если вы проверили, чтобы убедиться, что файл существует, его могут быть удалены перед его можно открыть, или он может быть поврежден. В этом случае при попытке открыть файл путем создания экземпляра <xref:System.IO.StreamReader> объекта или вызова <xref:System.IO.File.Open%2A> метод может генерировать <xref:System.IO.FileNotFoundException> исключение. В таких случаях следует использовать обработку исключений для устранения таких ошибок.  
  
-   **Сбои системы.** Сбой системы является ошибкой времени выполнения, которая не могут быть обработаны программным способом в осмысленном виде. Например, можно вызывать любой метод <xref:System.OutOfMemoryException> исключение, если среда CLR не сможет выделить дополнительную память. Как правило системные сбои не обрабатываются с помощью обработки исключений. Вместо этого можно использовать события, такие как <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> и вызвать <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> метода для входа сведения об исключении и уведомлять пользователя о сбое, перед завершением работы приложения.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Блоки try/catch  
 Среда CLR предоставляет модель обработки исключений, основанный на представлении исключений как объектов и разделение программного кода и кода обработки исключения на `try` блоков и `catch` блоков. Может существовать один или несколько `catch` блокирует, каждое из которых для обработки конкретного типа исключения, или один блок, позволяющий перехватить исключение более конкретного, чем другой.  
  
 Если приложение обрабатывает исключения, возникающие во время выполнения блока кода приложения, код должен быть помещен в `try` инструкции и вызывается `try` блока. Код приложения, который обрабатывает исключения, создаваемые `try` помещен в блок `catch` инструкции и вызывается `catch` блока. Ноль или более `catch` блоки связаны с `try` блока, при этом каждая `catch` блок содержит фильтр типа, который определяет типы исключений, он обрабатывает.  
  
 При возникновении исключения в `try` блока, система осуществляет поиск связанных `catch` блоков в порядке, они отображаются в коде приложения, пока не найдет `catch` блок, который обрабатывает исключение. Объект `catch` обрабатывает исключение типа `T` Если тип фильтра блока catch указывает `T` или любой тип, который `T` является производным от. Система прекращает поиск после он находит первый `catch` блок, который обрабатывает исключение. По этой причине в коде приложения `catch` блок обработки типа должны быть указаны до `catch` блок, который обрабатывает его базовых типов, как показано в следующем примере в этом разделе. Блок catch, обрабатывающий `System.Exception` указывается в последнюю очередь.  
  
 Если ни один из `catch` блоки, связанный с текущим `try` блок обработки исключения и текущий `try` блок, вложены в другие `try` блокирует в текущем вызове `catch` блокировок, сопоставленных со следующим заключив `try` блок производится поиск. Если нет `catch` блокировка для исключения найдена, система осуществляет поиск предыдущих уровней вложенности в текущем вызове. Если не `catch` блоков найден в текущем вызове, исключение передается вверх по стеку вызовов и предыдущего кадра стека в поисках `catch` блок, который обрабатывает исключение. Поиск стека вызовов продолжается, пока исключение не будет обработано или пока не закончатся в стеке вызовов. По достижении верхней части стека вызовов без поиск `catch` блок, который обрабатывает исключение, обработчик исключений по умолчанию обрабатывает его и приложение завершает работу.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Возможности типов исключений  
 Типы исключений поддерживают следующие функции:  
  
-   Удобочитаемый текст с описанием ошибки. При возникновении исключения среда выполнения предоставляет текстовое сообщение для информировать пользователей об характер ошибки, и предлагает способы ее устранения. Текстовое сообщение хранится в <xref:System.Exception.Message%2A> свойства объекта исключения. Во время создания объекта исключения можно передать строку текста в конструктор для описания сведений данного исключения. Если аргумент сообщения об предоставляется конструктору, используется сообщение по умолчанию. Дополнительные сведения см. в описании свойства <xref:System.Exception.Message%2A>.  
  
-   Состояние стека вызовов, когда возникло исключение. <xref:System.Exception.StackTrace%2A> Несет трассировку стека, который может использоваться для определения, где произошла ошибка в коде. Трассировка стека перечислены все вызываемые методы и номера строк в исходном файле, в которой выполняются вызовы.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Свойства класса исключений  
 <xref:System.Exception> Класс содержит ряд свойств, которые помогают определить расположения кода, тип, файл справки и причины исключения: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, и <xref:System.Exception.Data%2A>.  
  
 Если существует причинно-следственной связи между два или несколько исключений, <xref:System.Exception.InnerException%2A> свойство обслуживание этой информации. Внешнее исключение в ответ на это внутреннее исключение. Код, который обрабатывает внешнее исключение можно использовать сведения из ранее внутреннего исключения для более качественной обработки ошибки. С дополнительными сведениями об исключении могут храниться в виде коллекции пар "ключ значение" в <xref:System.Exception.Data%2A> свойство.  
  
 Строка сообщения об ошибке, передаваемый в конструктор при создании объекта исключения должно быть локализовано и может предоставляться из файла ресурсов с помощью <xref:System.Resources.ResourceManager> класса. Дополнительные сведения о локализованных ресурсов, см. в разделе [Создание вспомогательных сборок](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) и [упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) разделы.  
  
 Чтобы обеспечить пользователю с подробными сведениями о возникновения исключения, <xref:System.Exception.HelpLink%2A> свойство может содержать URL-адрес (или URN) файла справки.  
  
 <xref:System.Exception> Класс использует COR_E_EXCEPTION HRESULT, которое имеет значение 0x80131500.  
  
 Список начальных значений свойств для экземпляра <xref:System.Exception> , представлена в разделе <xref:System.Exception.%23ctor%2A> конструкторы.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Особенности производительности  
 Создание или обработка исключений потребляет значительный объем системных ресурсов и времени выполнения. Создавать исключения только для обработки по-настоящему чрезвычайных ситуаций, не для обработки предсказуемых событий или управления потоком. Например в некоторых случаях, например если вы разрабатываете библиотеку классов, разумно создавалось исключение аргумента метода недопустимо, так как предполагается, что метод может вызываться с допустимыми параметрами. Недопустимый метод аргумента, если он не является результатом ошибки об использовании, означает, что произошло что-то дополнительной. И наоборот не следует генерировать исключения, если входные данные пользователя недопустимо, так как можно ожидается, что пользователи иногда ввести недопустимые данные. Вместо этого предоставляют механизм повтора, поэтому пользователи могут вводить допустимые входные данные. И не следует использовать исключения для обработки ошибок для использования. Вместо этого используйте [утверждения](/visualstudio/debugger/assertions-in-managed-code) для выявления и устранения ошибок использования.  
  
 Кроме того не выдает исключение при достаточно кода возврата; код возврата не преобразуются в исключения; сделать не контролирует catch исключения, игнорируйте его и затем продолжить обработку.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Повторное создание исключения  
 Во многих случаях обработчик исключений просто хочет передать исключение в вызывающий объект. Это часто происходит в:  
  
-   Библиотека классов, которая в свою очередь служит оболочкой для вызова методов в библиотеке классов .NET Framework или других библиотек классов.  
  
-   Приложение или библиотека, которая обнаруживает неустранимое исключение. Обработчик исключений можно занести исключение в журнал и заново создать исключение.  
  
 Рекомендуемый способ повторного создания исключения, — просто использовать [throw](~/docs/csharp/language-reference/keywords/throw.md) инструкции на языке C# и [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) инструкции в Visual Basic, не включая выражения. Это гарантирует, что все сведения стека вызовов сохраняется, когда исключение передается вызывающему. Это показано в следующем примере. Метод расширения строки, `FindOccurrences`, служит оболочкой для вызова одной или нескольких <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> без проверки аргументов заранее.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Вызывающий объект затем вызывает `FindOccurrences` дважды. Во втором вызове к `FindOccurrences`, вызывающий объект передает `null` как строка поиска, какие варианты <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> метод выдает исключение <xref:System.ArgumentNullException> исключение. Это исключение обрабатывается `FindOccurrences` метод и передан вызывающей стороне. Так как инструкция throw используется без выражения, выходные данные примера показано, что сохраняется стек вызовов.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Напротив, если исключение повторно создается с помощью  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 инструкции, полный стек вызова не сохраняется, и в примере будет создано следующее:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Немного более громоздким, альтернативой является для генерации нового исключения, а также сохранить исходное исключение сведений стека вызовов в внутреннее исключение. Вызывающая сторона может использовать это новое исключение <xref:System.Exception.InnerException%2A> свойство для извлечения кадра стека и другие сведения об исходном исключении. В этом случае инструкция throw является:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Пользовательский код, который обрабатывает исключение должен знать, <xref:System.Exception.InnerException%2A> свойство содержит сведения об исходном исключении, как показано в следующем обработчика исключений.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Выбор стандартных исключений  
 При наличии для создания исключения, часто можно использовать существующий тип исключений в .NET Framework вместо реализации пользовательского исключения. Следует использовать тип стандартное исключение в этих двух условий:  
  
-   Вы исключение, вызванное Ошибка использования (то есть за ошибки в логике программы разработчика, который вызывает метод). Как правило, может генерировать исключение, такие как <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, или <xref:System.NotSupportedException>. Строка, передаваемые конструктору объекта исключения при создании экземпляра объекта исключения следует описания ошибки, таким образом, разработчик может устранить проблему. Дополнительные сведения см. в описании свойства <xref:System.Exception.Message%2A>.  
  
-   Обработки ошибок, можно сообщить в вызывающий объект с существующей исключения .NET Framework. Наиболее производный исключение возможных необходимо вызвать исключение. Например, если метод требует аргумента допустимый член типа перечисления, необходимо вызвать исключение <xref:System.ComponentModel.InvalidEnumArgumentException> (наиболее производный класс), а не <xref:System.ArgumentException>.  
  
 Ниже перечислены общие типы исключений и условия, при которых создавал исключение, их.  
  
|Исключение|Условие|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Недопустимый аргумент отличное от null, который передается в метод.|  
|<xref:System.ArgumentNullException>|Аргумент, передаваемый в метод `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Значение аргумента находится вне диапазона допустимых значений.|  
|<xref:System.IO.DirectoryNotFoundException>|Часть пути каталога является недопустимым.|  
|<xref:System.DivideByZeroException>|Знаменатель в целое число или <xref:System.Decimal> операции деления равно нулю.|  
|<xref:System.IO.DriveNotFoundException>|Диск недоступен или не существует.|  
|<xref:System.IO.FileNotFoundException>|Файл не существует.|  
|<xref:System.FormatException>|Значение не находится в соответствующий формат для преобразования из строки с помощью метода преобразования таких как `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Индекс находится вне границ массива или коллекции.|  
|<xref:System.InvalidOperationException>|Вызов метода является недопустимым в текущем состоянии объекта.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Не удается найти указанный ключ для обращения к элементу в коллекции.|  
|<xref:System.NotImplementedException>|Метод или операция не реализованы.|  
|<xref:System.NotSupportedException>|Метод или операция не поддерживается.|  
|<xref:System.ObjectDisposedException>|Операция выполняется на объекте, который был удален.|  
|<xref:System.OverflowException>|Операция арифметического приведения или преобразования приводит к переполнению.|  
|<xref:System.IO.PathTooLongException>|Путь или имя файла превышает максимальную длину определяемого системой.|  
|<xref:System.PlatformNotSupportedException>|Операция не поддерживается на текущей платформе.|  
|<xref:System.RankException>|Массив с неверным числом размерностей передается в метод.|  
|<xref:System.TimeoutException>|Истек интервал времени, выделенное для выполнения операции.|  
|<xref:System.UriFormatException>|Используется недопустимый универсальный код ресурса (URI).|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Реализация пользовательских исключений  
 В следующих случаях использование существующих исключения .NET Framework для обработки ошибки не подходит:  
  
-   Когда исключение отражает уникальный ошибки не может быть сопоставлен существующей исключения .NET Framework.  
  
-   Когда исключение требует обработки, который отличается от обработки, который подходит для существующих исключения .NET Framework, или исключение должно однозначно из аналогичное исключение. Например, если вызывается <xref:System.ArgumentOutOfRangeException> исключение при синтаксическом анализе численное представление строки, которая выходит за пределы диапазона целочисленных типа целевого объекта, вам не следует использовать то же исключение для ошибки, полученный в результате вызывающий объект не указываются соответствующие значения ограничением при вызове метода.  
  
 <xref:System.Exception> Класс является базовым классом для всех исключений в .NET Framework. Многие производные классы зависят от поведения наследуемых членов <xref:System.Exception> класса; они не переопределяли членами <xref:System.Exception>, ни они определяют любой уникальных элементов.  
  
 Чтобы определить собственный класс исключения:  
  
1.  Определите класс, наследуемый от <xref:System.Exception>. При необходимости определите все уникальные члены, необходимые вашим классом, для предоставления дополнительных сведений об исключении. Например <xref:System.ArgumentException> класс включает <xref:System.ArgumentException.ParamName%2A> свойство, указывающее имя параметра, чей аргумент вызвала исключение, и <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> включает свойство <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> свойство, указывающее интервал времени ожидания.  
  
2.  При необходимости Переопределите все унаследованные члены, функциональность которого вы хотите изменить или изменить. Обратите внимание, что большинство существующих производными классами от <xref:System.Exception> не переопределить поведение унаследованных членов.  
  
3.  Определите, сериализуем ли объект пользовательское исключение. Сериализация позволяет сохранить сведения об исключении и разрешает сведения об исключении для совместного использования сервера и прокси-сервер клиента в контексте удаленного взаимодействия. Чтобы сделать объект исключения сериализуемым, отметить его атрибутом <xref:System.SerializableAttribute> атрибута.  
  
4.  Определите конструкторы класса исключения. Как правило классы исключений имеют один или несколько из следующих конструкторов:  
  
    -   <xref:System.Exception.%23ctor>, использующий значения по умолчанию для инициализации свойства объекта исключения.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, который инициализирует объект исключения с указанным сообщением об ошибке.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, который инициализирует объект исключения с сообщением и внутренним исключением указанной ошибки.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, который является `protected` конструктор, который инициализирует новый объект исключения из сериализованных данных. Этот конструктор следует реализовать, если вы решили сделать сериализуемым объекта исключения.  
  
 Следующий пример иллюстрирует использование класса пользовательского исключения. Он определяет `NotPrimeException` исключение, возникающее, когда клиент пытается получить последовательность простых чисел, указав начальный номер, который не является простым. Исключение определяет новое свойство, `NonPrime`, который возвращает не простое число, вызвавшего исключение. Помимо реализации защищенный конструктор без параметров и конструктор с <xref:System.Runtime.Serialization.SerializationInfo> и <xref:System.Runtime.Serialization.StreamingContext> параметры для сериализации, `NotPrimeException` класс определяет три дополнительные конструкторы для поддержки `NonPrime` свойство.  Каждый конструктор вызывает конструктор базового класса в дополнение к сохранение из простых нечисловое значение. `NotPrimeException` Класса также задано <xref:System.SerializableAttribute> атрибута.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` Класс, показанный в следующем примере использует "решето Эратосфена", чтобы вычислить последовательность простых чисел от 2 до предела, указанное клиентом в вызове конструктора класса. `GetPrimesFrom` Метод возвращает все простые числа не меньше указанного нижний предел, но создает исключение `NotPrimeException` Если, нижний предел не простое число.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 В следующем примере создается два вызова `GetPrimesFrom` метод с непростых чисел, один из которых за пределами домена приложения. В обоих случаях исключение создается и успешно обработано в коде клиента.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Среда выполнения Windows и [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 В [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] для [!INCLUDE[win8](~/includes/win8-md.md)], некоторые сведения об исключении обычно теряется, если исключение распространяется через кадры стека .NET Framework. Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)] и [!INCLUDE[win81](~/includes/win81-md.md)], среда CLR по-прежнему будет использоваться исходное <xref:System.Exception> объекта, созданного исключения, если это исключение был изменен в кадр стека .NET Framework.  
  
   
  
## Examples  
 В следующем примере демонстрируется `catch` блок, который определен для обработки <xref:System.ArithmeticException> ошибки. Это `catch` также блокировать перехватываются <xref:System.DivideByZeroException> ошибки, так как <xref:System.DivideByZeroException> является производным от <xref:System.ArithmeticException> и не `catch` блок, явно определенный для <xref:System.DivideByZeroException> ошибок.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов в приложениях для настольных систем</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Утверждения в управляемом коде</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует свойство <xref:System.Exception.Message%2A> нового экземпляра, используя системное сообщение, которое описывает ошибку и учитывает текущий язык и региональные параметры системы.  
  
 Все производные классы должны предоставлять конструктор по умолчанию. В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Локализованное описание, предоставляемое системой.|  
  
   
  
## Examples  
 В следующем примере кода является производным `Exception` , использующий стандартные сообщения. В коде показано использование конструктора без параметров для производного класса, а также базовый `Exception` класса.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, описывающее ошибку.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> с указанным сообщением об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A> свойства нового экземпляра с помощью `message` параметра. Если `message` параметр `null`, это то же самое, что и вызов метода <xref:System.Exception.%23ctor%2A> конструктор.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
   
  
## Examples  
 В следующем примере кода является производным `Exception` для определенного условия. В коде показано использование конструктора, который принимает в качестве параметра, базовый и производный класс сообщения, определенном вызывающей стороной `Exception` класса.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> с сериализованными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конструктор вызывается в процессе десериализации для воссоздания объекта исключения, переданного в потоке. Дополнительные сведения см. в разделе [сериализация XML и SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 В следующем примере кода определяется производный сериализуемый `Exception` класса. Код вызывает ошибку деления на ноль, а затем создается экземпляр производного исключения, используя (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) конструктора. Код выполняет сериализацию экземпляра в файл, десериализацию файла в новое исключение, исключение, а затем перехватывает и отображает данные исключения.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Имя класса — <see langword="null" />, или <see cref="P:System.Exception.HResult" /> равно нулю (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
        <param name="innerException">Исключение, вызвавшее текущее исключение, или указатель null (<see langword="Nothing" /> в Visual Basic), если внутреннее исключение не задано.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Exception" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, должно содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.Exception>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
   
  
## Examples  
 В следующем примере кода является производным `Exception` для определенного условия. В коде показано использование конструктора, который принимает сообщение и внутреннее исключение в качестве параметров для базового и производного класса `Exception` класса.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию пар ключ/значение, предоставляющие дополнительные сведения об исключении, определяемые пользователем.</summary>
        <value>Объект, который реализует интерфейс <see cref="T:System.Collections.IDictionary" /> и содержит в себе коллекцию пар "ключ-значение". По умолчанию является пустой коллекцией.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Collections.IDictionary?displayProperty=nameWithType> объект, возвращаемый <xref:System.Exception.Data%2A> свойство для хранения и извлечения с дополнительными сведения, относящиеся к исключению. Эта информация содержится в виде произвольное число пар ключ/значение, определяемые пользователем. Ключевым компонентом каждой пары "ключ значение" обычно является строка, идентифицирующая, а компонент значения пары может быть объект любого типа.  
  
## <a name="keyvalue-pair-security"></a>Безопасность пар ключ значение  
 Пары ключ/значение, хранящихся в коллекции, возвращаемой <xref:System.Exception.Data%2A> свойства не являются безопасными. Если приложение вызывает вложенную последовательность подпрограмм, а каждая процедура содержит обработчики исключений, стек вызовов содержит иерархию этих обработчиков исключений. При возникновении исключения в подпрограмму более низкого уровня, все обработчики исключений верхнего уровня в иерархии стека вызова могут считывать и/или изменять пары "ключ значение", хранящихся в коллекции с любым другим обработчиком исключений. Это означает, что вы должны гарантировать, что данные в парах "ключ значение" не является конфиденциальной и что приложение будет правильно работать в случае повреждения данные в парах "ключ значение".  
  
## <a name="key-conflicts"></a>Конфликтов ключей  
 Конфликт ключей происходит при разных обработчиках исключений задан один и тот же ключ для доступа к паре ключ/значение. Будьте осторожны при разработке приложения, так как вследствие конфликта ключей обработчики исключений более низкого уровня случайно могут обмениваться данными с обработчиками исключений верхнего уровня, что это взаимодействие может привести к неочевидных ошибок программы. Тем не менее если вы являетесь осторожность можно использовать конфликтов ключей расширить свое приложение.  
  
## <a name="avoiding-key-conflicts"></a>Предотвращение конфликтов ключей  
 Избегайте конфликтов ключей, интегрируя именования, чтобы создавать уникальные ключи для пар "ключ значение". Например соглашение об именовании могут дать ключом, который состоит из имени приложения с разделителями точками, метод, который предоставляет дополнительные сведения для пары, а уникальный идентификатор.  
  
 Предположим, что два приложения с именем, продуктами и поставщиками, каждый имеет метод с именем Sales. Метод Sales в приложении Products предоставляет идентификационный номер (номера SKU единица или номер SKU) продукта. Метод Sales в приложении Suppliers предоставляет идентификационный номер или идентификатор безопасности, поставщика. Следовательно соглашение об именовании для этого примера дает ключей, «Products.Sales.SKU» и «Suppliers.Sales.SID».  
  
## <a name="exploiting-key-conflicts"></a>Использования конфликтов ключей  
 Воспользоваться конфликтов ключей с помощью наличие одного или нескольких специальных, применив ключей для управления обработкой. Предположим, что в одном случае обработчик исключений высокого уровня в иерархии стека вызова перехватывает все исключения, создаваемые обработчиков исключений более низкого уровня. Если существует пару "ключ значение" назначить специальный ключ, обработчик исключений высшего уровня форматирует оставшихся пар ключ/значение в <xref:System.Collections.IDictionary> объект либо нестандартным образом; в противном случае оставшихся пар ключ/значение форматируются в некоторых обычным способом.  
  
 Теперь предположим, что в другом сценарии обработчик исключений на каждом уровне иерархии стека вызова перехватывает исключение, вызванное Далее обработчик исключений более низкого уровня. Кроме того, каждому обработчику исключений известно в коллекцию, возвращаемую <xref:System.Exception.Data%2A> свойство содержит набор пар "ключ значение", доступных с помощью заданного набора ключей.  
  
 Каждый обработчик исключений использует заданный набор ключей для обновления компонента значение соответствующей пары ключ/значение сведениями, уникальными для этого обработчика исключений. После завершения процесса обновления, обработчик исключений создает исключение в обработчик исключений следующего более высокого уровня. Наконец обработчик исключений высокого уровня обращается к пары "ключ значение" и сведения о консолидированных обновления от всех обработчиков исключений нижнего уровня.  
  
   
  
## Examples  
 Приведенный ниже показано, как добавлять и извлекать сведения с помощью <xref:System.Exception.Data%2A> свойство.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает исключение <see cref="T:System.Exception" />, которое является корневой причиной одного или нескольких последующих исключений.</summary>
        <returns>В цепочке исключений создается первое исключение. Если свойством <see cref="P:System.Exception.InnerException" /> текущего исключения является пустая ссылка (<see langword="Nothing" /> в Visual Basic), это свойство возвращает текущее исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цепочка исключения состоит из набора исключений, таким образом, чтобы каждый в цепочке возникло исключение в результате исключения, на которые ссылается его `InnerException` свойство. Для данной цепи может существовать только одно исключение, вызвавшее других исключений в цепочке. Это исключение вызывается базовое исключение и его `InnerException` свойства всегда содержит пустую ссылку.  
  
 Для всех исключений, в цепочке исключений `GetBaseException` метод должен возвращать один и тот же объект (базовое исключение).  
  
 Используйте `GetBaseException` метод, если вы хотите найти причину исключения, но не обязательно сведения об исключениях, произошедших между текущее исключение и первое исключение.  
  
   
  
## Examples  
 В следующем примере кода определяются два производных `Exception` классы. Он вызывает исключение и затем вызывает его с каждым из производных классов. В коде показано использование `GetBaseException` метод для извлечения в исходное исключение.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" /> Метод переопределен в классах, которые требуют управления содержанием исключения или форматом.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
        <summary>При переопределении в производном классе задает сведения об исключении для <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `GetObjectData` загружает в объект <xref:System.Runtime.Serialization.SerializationInfo> все данные объекта исключения, предназначенные для сериализации. В процессе десериализации исключение воссоздается из объекта `SerializationInfo`, переданного в потоке.  
  
   
  
## Examples  
 В следующем примере кода определяется производный сериализуемый `Exception` класс, реализующий `GetObjectData`, который вносит незначительные изменения в два свойства, и затем вызывает базовый класс для выполнения сериализации. В примере вызывает ошибку деления на ноль и затем создается экземпляр производного исключения. Код выполняет сериализацию экземпляра в файл, десериализацию файла в новое исключение, исключение, а затем перехватывает и отображает данные исключения.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значением параметра <paramref name="info" /> является пустая ссылка (<see langword="Nothing" /> в Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает тип среды выполнения текущего экземпляра.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий точный тип среды выполнения текущего экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A> Метод служит для поддержки инфраструктуры .NET Framework и внутренне вызывает метод фундаментальные <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на файл справки, связанный с этим исключением.</summary>
        <value>URN или URL-адрес.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемым значением, представляющим файл справки, является URN или URL-адрес. Например `HelpLink` значение может быть:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 В следующем коде возникает исключение пример `Exception` , задает `HelpLink` свойства в его конструктор и перехватываются исключения и отображает `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HRESULT — кодированное числовое значение, присвоенное определенному исключению.</summary>
        <value>Значение HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT является 32-разрядное значение, разделены на три поля: код уровня ошибки, код устройства и код ошибки. Код серьезности указывает, представляет ли возвращаемое значение сведения, предупреждение или ошибка. Код устройства определяет область системы, за которой возникла ошибка. Код ошибки — уникальный номер, представляющий исключение. Каждое исключение сопоставляется с различными значениями HRESULT. Когда управляемый код создает исключение, среда выполнения передает значение HRESULT COM-клиент. Когда неуправляемый код возвращает ошибку, значение HRESULT преобразуется в исключение, которое затем создается средой выполнения. Сведения о значениях HRESULT и их соответствующие исключения .NET Framework, см. в разделе [как: Сопоставление значений HRESULT и исключений](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). См. в разделе [часто встречающихся значений HRESULT](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) в документации по Windows для получения списка значений, чаще всего возникают.  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Exception.HResult%2A> защищен методу задания свойства, а его метод считывания является открытым.  В предыдущих версиях .NET Framework защищены Get и set.  
  
   
  
## Examples  
 В следующем примере кода определяется производный `Exception` класс, который задает `HResult` свойство пользовательское значение в своем конструкторе.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Практическое руководство. Сопоставление значений HRESULT и исключений</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Часто встречающихся значений HRESULT</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса <see cref="T:System.Exception" />, который вызвал текущее исключение.</summary>
        <value>Объект, описывающий ошибку, которая вызвала текущее исключение. Свойство <see cref="P:System.Exception.InnerException" /> возвращает то же значение, что было передано в конструктор <see cref="M:System.Exception.#ctor(System.String,System.Exception)" />, или значение <see langword="null" />, если конструктору не было передано значение внутреннего исключения. Это свойство доступно только для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове исключения `X` вызывается как прямой результат предыдущего исключения `Y`, <xref:System.Exception.InnerException%2A> свойство `X` должен содержать ссылку на `Y`.  
  
 Свойство <xref:System.Exception.InnerException%2A> используется, чтобы получить набор исключений, ставших причиной текущего исключения.  
  
 Можно создать новое исключение, которое перехватывает исключение. Код, обрабатывающий второе исключение позволяют использовать дополнительные сведения из предыдущего исключения для более качественной обработки ошибки.  
  
 Предположим, что имеется функция, которая считывает файл и форматирует данные из этого файла. В этом примере, как код пытается считать файл <xref:System.IO.IOException> возникает исключение. Функция перехватит <xref:System.IO.IOException> и вызывает <xref:System.IO.FileNotFoundException>. <xref:System.IO.IOException> Может быть сохранен в <xref:System.Exception.InnerException%2A> свойство <xref:System.IO.FileNotFoundException>, включение код, который перехватывает <xref:System.IO.FileNotFoundException> чтобы определить причину исходной ошибки.  
  
 <xref:System.Exception.InnerException%2A> Свойство, которое содержит ссылку на внутреннее исключение, устанавливается при инициализации объекта исключения.  
  
   
  
## Examples  
 В следующем примере показано создание и перехват исключения, которое ссылается на внутреннее исключение.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сообщение, описывающее текущее исключение.</summary>
        <value>Сообщение об ошибке с объяснением причин исключения или пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сообщения об ошибках предназначены разработчик, который обрабатывает исключение. Текст <xref:System.Exception.Message%2A> свойство должен содержать полное описание ошибки и, если это возможно, следует также объясняется, как исправить эту ошибку. Обработчики исключений верхнего уровня может отображать сообщение для конечных пользователей, поэтому следует убедиться, что это грамматически правильных и что каждое предложение сообщения заканчивается точкой. Не используйте вопросительные знаки или восклицательных знаков. Если приложение использует локализованное исключение сообщений, следует убедиться, что они преобразуются точно.  
  
> [!IMPORTANT]
>  Не раскрывайте конфиденциальные сведения в сообщения об исключениях без проверки на наличие соответствующих разрешений.  
  
 Значение <xref:System.Exception.Message%2A> свойство включено в сведения, возвращаемые функцией <xref:System.Exception.ToString%2A>. <xref:System.Exception.Message%2A> Свойство имеет значение только в том случае, при создании <xref:System.Exception>. Если сообщение не было передано конструктору для текущего экземпляра, система передает сообщение по умолчанию, форматируется с использованием текущего языка и региональных параметров системы.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Среда выполнения Windows и [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)] и [!INCLUDE[win81](~/includes/win81-md.md)], повышается точность сообщения об ошибках из исключения, которые распространяются от типов среды выполнения Windows и члены, которые не являются частью платформы .NET Framework. В частности, исключение сообщения от расширения компонентов Visual C++ (C + +/ CX) теперь распространяются обратно в .NET Framework <xref:System.Exception> объектов.  
  
   
  
## Examples  
 В следующем примере кода создает исключение и затем перехватывает <xref:System.Exception> исключение, отображающее текст исключения сообщения с использованием <xref:System.Exception.Message%2A> свойство.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При создании исключения из свойства, и вам потребуется обратиться в тексте <see cref="P:System.Exception.Message" /> свойство аргументу, задать или получить, используйте «value» как имя свойства аргумента.</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" /> Переопределяется в классах, которые требуют управления содержимое сообщения или форматом. Код приложения обычно обращается к этому свойству, когда необходимо вывести сведения об исключении, которое возникло.  
  
Сообщение об ошибке должно быть локализовано.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда исключение сериализовано для создания объекта состояния исключения, содержащего сериализованные данные об исключении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализует объект состояния исключения <xref:System.Runtime.Serialization.ISafeSerializationData> интерфейс.  
  
 Когда <xref:System.Exception.SerializeObjectState> подписаться событий, десериализуется исключение и создан как исключение пустой. Конструктор исключения не запускается, и состояние исключения также десериализуется. <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> Таким образом, чтобы его можно отправить десериализованные данные в пустой исключение будет вызываться метод обратного вызова объекта состояния исключения.  
  
 <xref:System.Exception.SerializeObjectState> Событий позволяет прозрачным исключение типов для сериализации и десериализации данных исключения. Прозрачный код можно выполнять команды в пределах набора разрешений в пределах, работает оно, но нельзя выполнить, вызова, являются производными от или содержать критический код.  
  
 Если <xref:System.Exception.SerializeObjectState> событий не подписана, десериализации происходит обычным образом с помощью <xref:System.Exception.%23ctor%2A> конструктор.  
  
 Как правило, обработчик для <xref:System.Exception.SerializeObjectState> событие было добавлено в конструкторе исключения для обеспечения его сериализации. Но так как конструктор не выполняется при <xref:System.Exception.SerializeObjectState> выполнения обработчика событий, сериализация десериализованные исключение может вызвать исключение <xref:System.Runtime.Serialization.SerializationException> возникло исключение при попытке десериализации исключения. Чтобы избежать этого, также должны добавить обработчик для <xref:System.Exception.SerializeObjectState> событие в <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> метод. Пример в разделе примеров.  
  
   
  
## Examples  
 В следующем примере определяется `BadDivisionException` , обрабатывающий <xref:System.Exception.SerializeObjectState> событий. Он также содержит объект состояния, который является вложенным структура с именем `BadDivisionExceptionState` , реализующий <xref:System.Runtime.Serialization.ISafeSerializationData> интерфейс.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` Исключение создается в случае с плавающей запятой деление на ноль. Во время первого деления на ноль, в примере создается экземпляр `BadDivisionException` объект, сериализует его и создает исключение. При возникновении последующих подразделений деления на ноль, в примере десериализует ранее сериализованного объекта, сериализацию и создает исключение. Чтобы предоставить для сериализации, десериализации, reserialization и десериализации объектов, в примере добавляется <xref:System.Exception.SerializeObjectState> обработчик событий как в `BadDivisionException` конструктора класса и в <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> реализации.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если это событие является подписки и использования, все производные типы, выполните в иерархии наследования необходимо реализовать один и тот же механизм сериализации.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя приложения или объекта, вызывавшего ошибку.</summary>
        <value>Имя приложения или объекта, вызвавшего ошибку.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Exception.Source%2A> свойство не задано явно, среда выполнения автоматически устанавливает его в имя сборки, в котором возникло исключение.  
  
   
  
## Examples  
 В следующем примере возникает исключение `Exception` , задает `Source` свойства в его конструктор и перехватываются исключения и отображает `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Объект должен быть объектом среды выполнения <see cref="N:System.Reflection" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое представление непосредственных кадров в стеке вызова.</summary>
        <value>Строка, описывающая непосредственные фреймы стека вызова.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В стеке выполнения отслеживаются все методы, выполняемые в данный момент времени. Трассировка вызовов метода называется трассировкой стека. Список трассировок стека позволяет проследить стек вызовов на номер строки в методе, в котором происходит исключение.  
  
 <xref:System.Exception.StackTrace%2A> Свойство возвращает кадры стека вызовов, поступающих в расположении, где возникло исключение. Сведения о дополнительных кадров в стеке вызовов можно получить, создав новый экземпляр класса <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> , используя его <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> метод.  
  
 Среда CLR (CLR) обновляет трассировку стека, каждый раз, когда возникает исключение в коде приложения (с помощью `throw` ключевое слово). Если исключение в методе, который отличается от метода, где оно было изначально создано, трассировка стека содержит как расположение в методе, где первоначально было выдано исключение, так и расположение в методе, где исключение: создано повторно. Если исключение создается и позже повторно, в один и тот же метод, трассировка стека содержит только область, где было повторно вызвано исключение и не включает расположение, где первоначально было выдано исключение.  
  
 <xref:System.Exception.StackTrace%2A> Свойства могут не разглашать столько предполагаемых вызовах методов из-за преобразований кода, таких как встраивание, происходящих во время оптимизации.  
  
   
  
## Examples  
 В следующем коде возникает исключение пример `Exception` перехватывает его и отображает трассировку стека с помощью `StackTrace` свойство.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" /> Переопределяется в классах, которые требуют управления содержимым трассировки стека или форматом.  
  
По умолчанию трассировка стека фиксируется немедленно до объекта исключения. Используйте <see cref="P:System.Environment.StackTrace" /> для получения сведения о трассировке стека, если исключение не вызывается.</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод, создавший текущее исключение.</summary>
        <value>Метод <see cref="T:System.Reflection.MethodBase" />, выбрасывающий текущее исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод, который создает это исключение, недоступен и трассировка стека не является пустой ссылкой (`Nothing` в Visual Basic), <xref:System.Exception.TargetSite%2A> получает метод из трассировки стека. Если трассировка стека является нулевой ссылкой, то <xref:System.Exception.TargetSite%2A> также возвращает нулевую ссылку.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> Свойство может неточно сообщать имя метода, в котором возникло исключение, если обработчик исключений обрабатывает исключение через границы домена приложения.  
  
   
  
## Examples  
 В следующем коде возникает исключение пример `Exception` перехватывает его и отображается в режиме исходного метода `TargetSite` свойство.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление текущего исключения.</summary>
        <returns>Строковое представление текущего исключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Возвращает представление текущего исключения, которое должно быть понятно пользователю. Если исключение содержит данные, зависящие от языка и региональных параметров, возвращаемых строковое представление `ToString` необходимо принимать во внимание текущего языка и региональных параметров системы. Несмотря на то, что требования не предусмотрены точный формат возвращаемой строки, следует попытаться отражает значение свойства объекта, воспринимаемое пользователем.  
  
 Реализация по умолчанию <xref:System.Exception.ToString%2A> получает имя класса, который вызвал текущее исключение, сообщение, результат вызова метода <xref:System.Exception.ToString%2A> на внутреннее исключение и результат вызова метода <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Если какие-либо из этих членов `null`, его значение не включается в возвращаемую строку.  
  
 Если сообщение об ошибке, или если это пустая строка ("»), то сообщение об ошибке не возвращается. Имя внутреннего исключения и трассировку стека, возвращаются только в том случае, если они не `null`.  
  
 Этот метод переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Следующий пример приводит к возникновению исключения и отображает результат вызова метода <xref:System.Exception.ToString%2A> на это исключение. Обратите внимание, что <xref:System.Exception.ToString%2A?displayProperty=nameWithType> метод вызывается неявно, когда экземпляр класса Exception появится в списке аргументов <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>