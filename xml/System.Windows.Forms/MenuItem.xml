<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e96b9a562587ce1b84c0314819619ffe1f760d2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55340289" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет отдельный элемент, отображаемый в меню <see cref="T:System.Windows.Forms.MainMenu" /> или <see cref="T:System.Windows.Forms.ContextMenu" />. Хотя элемент управления <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> заменяет элемент управления <see cref="T:System.Windows.Forms.MenuItem" /> предыдущих версий и расширяет его функциональные возможности, однако при необходимости элемент управления <see cref="T:System.Windows.Forms.MenuItem" /> можно сохранить для обратной совместимости и использования в будущем.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы <xref:System.Windows.Forms.MenuItem> отображался, необходимо добавить его к <xref:System.Windows.Forms.MainMenu> или <xref:System.Windows.Forms.ContextMenu>. Чтобы создать подменю, можно добавить <xref:System.Windows.Forms.MenuItem> объектов <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство родительского объекта <xref:System.Windows.Forms.MenuItem>.  
  
 <xref:System.Windows.Forms.MenuItem> Класс предоставляет свойства, которые позволяют настроить внешний вид и функциональные возможности элемента меню. Чтобы отобразить флажок рядом с элементом меню, используйте <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство. Эту функцию можно использовать для идентификации элемента меню, который выбран в списке взаимно исключают друг друга элементов. Например, если у вас есть набор пунктов меню для задания цвета текста в <xref:System.Windows.Forms.TextBox> элемента управления, можно использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство, чтобы определить, какой цвет выбран в данный момент. <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Свойство может использоваться для определения сочетания клавиш, которые можно нажать для выбора пункта меню.  
  
 Для <xref:System.Windows.Forms.MenuItem> объектов, отображаемых в приложении многодокументного интерфейса (MDI), можно использовать <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> родительский метод для слияния меню MDI с, ее дочерних форм, чтобы создать структуру консолидированное меню. Так как <xref:System.Windows.Forms.MenuItem> нельзя использовать повторно в нескольких местах в то же время, например в <xref:System.Windows.Forms.MainMenu> и <xref:System.Windows.Forms.ContextMenu>, можно использовать <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> метод, чтобы создать копию <xref:System.Windows.Forms.MenuItem> для использования в другом месте.  
  
 <xref:System.Windows.Forms.MenuItem.Popup> Событие позволяет выполнять задачи, перед отображением меню. Например можно создать обработчик событий для этого события отобразить или скрыть элементы меню, исходя из состояния кода. <xref:System.Windows.Forms.MenuItem.Select> Событие позволяет выполнять задачи, например для предоставления подробную справку для пунктов меню приложения, когда пользователь наводит указатель мыши на элемент меню.  
  
   
  
## Examples  
 В следующем примере кода создается структура меню для формы. В примере кода добавляется <xref:System.Windows.Forms.MenuItem> для представления элемента меню верхнего уровня, к нему добавляется элемент вложенного меню для выбора размера шрифта, а затем добавляет два подменю к этому элементу, предоставляющие возможность выбора больших и маленьких шрифтов в приложении. В примере требуется наличие <xref:System.Windows.Forms.MainMenu> объект с именем `mainMenu1` и четыре <xref:System.Windows.Forms.MenuItem> объектов с именем `menuItem1`, `menuItem2`, `menuItem3`, и `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует элемент <see cref="T:System.Windows.Forms.MenuItem" /> без надписи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания пустой <xref:System.Windows.Forms.MenuItem> с помощью этого конструктора, можно использовать свойства и методы <xref:System.Windows.Forms.MenuItem> классу, чтобы задать внешний вид и поведение вашей <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> с помощью данной версии конструктора.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" /> с заданной надписью для элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню с `text` параметр, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры.  
  
 Установка `text` параметр "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> , задающий надпись элемента меню во время его создания.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса с заданной надписью и обработчиком для события <see cref="E:System.Windows.Forms.MenuItem.Click" /> данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню с `text` параметр, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры.  
  
 Установка `text` параметр "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 Кроме того, этот конструктор можно использовать для указания делегата, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> события для создаваемого элемента меню. <xref:System.EventHandler> Передать этот конструктор должен быть настроен на вызов обработчика событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> объекта с заданной надписью и <xref:System.EventHandler> делегата, подключенные к обработчику событий, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий для элемента меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="items">Массив объектов <see cref="T:System.Windows.Forms.MenuItem" />, содержащих элементы вложенного меню для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса с заданной подписью и массивом элементов вложенного меню для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню с `text` параметр, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры.  
  
 Установка `text` параметр "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 `items` Параметр позволит назначить массив элементов меню для определения вложенного данного пункта меню. Каждый элемент в массиве также может иметь массив элементов меню. Это позволяет создать полный меню структур и назначить их в конструктор для пункта меню.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создает объект с заданной надписью, обработчик событий, подключенным к методу, который будет обрабатывать событие каждый пункт меню в массиве элементов вложенного меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <param name="shortcut">Одно из значений <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <summary>Инициализирует новый экземпляр класса с заданной подписью, обработчиком событий и сочетанием клавиш для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню с `text` параметр, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры. Этот конструктор также позволяет задать сочетание клавиш, а также ключ доступа для предоставления с помощью клавиатуры. Сочетания клавиш позволяют пользователю указать сочетания клавиш, которые могут использоваться для активации элемента меню.  
  
 Установка `text` параметр "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 Кроме того, этот конструктор можно использовать для указания делегата, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> события для создаваемого элемента меню. <xref:System.EventHandler> Передать этот конструктор должен быть настроен на вызов обработчика событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается объект с заданной надписью, сочетание клавиш или клавиша и обработчик событий, подключенным к методу, который будет обрабатывать событие для элемента меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Одно из значений <see cref="T:System.Windows.Forms.MenuMerge" />.</param>
        <param name="mergeOrder">Относительное положение, которое будет занимать данный элемент в меню после слияния.</param>
        <param name="shortcut">Одно из значений <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <param name="onPopup">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Popup" /> для данного элемента меню.</param>
        <param name="onSelect">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Select" /> для данного элемента меню.</param>
        <param name="items">Массив объектов <see cref="T:System.Windows.Forms.MenuItem" />, содержащих элементы вложенного меню для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" /> с заданной надписью. Определяет обработчики событий для событий <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> и <see cref="E:System.Windows.Forms.MenuItem.Popup" />, сочетание клавиш, тип слияния и порядок, задаваемый для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню с `text` параметр, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры.  
  
 Установка `text` параметр "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 `items` Параметр позволит назначить массив элементов меню для определения вложенного данного пункта меню. Каждый элемент в массиве также может иметь массив элементов меню. Это позволяет создать полный меню структур и назначить их в конструктор для пункта меню.  
  
 `mergeType` И `mergeOrder` параметры могут быть использованы для определения того, как будет вести себя данный элемент меню при слиянии с другим меню пункта меню. В зависимости от значения, указываемые для `mergeType` параметр, можно добавить, удалить, заменить или слияния пункта меню и пунктов подменю с меню, которое объединяется с. `mergeOrder` Параметр определяет, где будет располагаться создаваемого элемента меню при слиянии меню.  
  
 Кроме того, можно использовать этот конструктор для создания <xref:System.Windows.Forms.MenuItem> и подключения его к обработчику событий в коде, который будет обрабатывать щелчок элемента меню. <xref:System.EventHandler> , Передаваемый в этот конструктор должен вызывать обработчик событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. С помощью этой версии конструктора, можно также подключиться <xref:System.Windows.Forms.MenuItem.Popup> и <xref:System.Windows.Forms.MenuItem.Select> событий, чтобы определить, при выборе этого пункта меню. Эти события можно использовать для задач, таких как определение наличия флажок рядом с элементами вложенного меню или включение или отключение пунктов меню, исходя из состояния приложения. <xref:System.Windows.Forms.MenuItem.Select> И <xref:System.Windows.Forms.MenuItem.Click> события создаются только для <xref:System.Windows.Forms.MenuItem> объекты, которые являются не родительских элементов меню. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню с надписью и сочетанием клавиш. Пункт меню также имеет обработчики для событий <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, и <xref:System.Windows.Forms.MenuItem.Select> события. Данная команда меню при слиянии, добавит пункта меню к меню с порядком слияния, равным нулю.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, размещается ли <see cref="T:System.Windows.Forms.MenuItem" /> в новой строке (для элемента меню, добавленного к объекту <see cref="T:System.Windows.Forms.MainMenu" />) или в новом столбце (для элемента вложенного меню или элемента меню, отображаемого в <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value>Значение <see langword="true" />, если элемент меню размещается в новой строке или в новом столбце, и значение <see langword="false" />, если данный элемент меню остается в положении по умолчанию. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.BarBreak%2A> свойства для создания меню, где каждый элемент меню размещается рядом с друг с другом по горизонтали вместо в вертикальном списке. Это свойство также можно создать строку меню, который содержит несколько строк элементов меню верхнего уровня.  
  
 Это свойство отличается от <xref:System.Windows.Forms.MenuItem.Break%2A> свойство, в том, что полоска отображалась у левого края каждого элемента меню с <xref:System.Windows.Forms.MenuItem.Break%2A> свойство значение `true`. Панель отображается только в том случае, если элемент меню не является элементом меню верхнего уровня.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> с двумя элементами вложенного меню. Два элемента вложенного меню отображаются горизонтально, вместо использования по вертикали <xref:System.Windows.Forms.MenuItem.BarBreak%2A> свойство.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, размещается ли элемент на новой строке (для элемента меню, добавленного к объекту <see cref="T:System.Windows.Forms.MainMenu" />) или в новом столбце (для элемента меню или элемента вложенного меню, отображаемого в <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value>Значение <see langword="true" />, если элемент меню размещается в новой строке или в новом столбце, и значение <see langword="false" />, если данный элемент меню остается в положении по умолчанию. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.Break%2A> свойства для создания меню, где размещается каждое меню рядом с друг с другом по горизонтали вместо в вертикальном списке. Это свойство также можно создать строку меню, который содержит несколько строк элементов меню верхнего уровня.  
  
   
  
## Examples  
 В следующем примере кода создается меню с двумя элементами меню верхнего уровня в верхней строке и один элемент меню в нижней строке.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли отображаться флажок рядом с текстом элемента меню.</summary>
        <value>Значение <see langword="true" />, если рядом с элементом меню устанавливается флажок, и значение <see langword="false" /> в противном случае. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство в сочетании с другими элементами меню в меню, чтобы передавать состояние для приложения. Например можно поместить флажок для пункта меню в группе элементов, определяющих размер шрифта для текста в приложении. Можно также использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство для идентификации выбранного пункта в группу пунктов меню взаимно исключают друг друга.  
  
> [!NOTE]
>  Это свойство не может быть присвоено `true` пункты меню верхнего уровня.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Windows.Forms.MenuItem.Checked%2A> свойства для передачи состояния в приложении. В этом примере группа элементов меню используются для указания цвета для текста в <xref:System.Windows.Forms.TextBox> элемента управления. Предоставленный обработчик событий используется <xref:System.Windows.Forms.MenuItem.Click> событий из трех пунктов меню. Каждый пункт меню задает цвет текста, `menuItemRed` (красный), `menuItemGreen` (зеленый), или `menuItemBlue` (синий). Обработчик событий определяет, какой пункт меню выбран, устанавливает флажок для выбранного пункта меню и изменяет цвет текста в формате <xref:System.Windows.Forms.TextBox> элемента управления. В этом примере требуется <xref:System.Drawing> форму, этот код помещается в пространство имен был добавлен. В этом примере также требуется <xref:System.Windows.Forms.TextBox> был добавлен в форму, расположенных в этом примере кода с именем `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Элемент <see cref="T:System.Windows.Forms.MenuItem" /> является элементом верхнего меню или содержит дочерние элементы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент меню выбирается щелчком мыши, с помощью сочетания клавиш или клавиши доступа, определенных для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click> Событие возникает при это <xref:System.Windows.Forms.MenuItem> нажатой пользователем. Это событие также возникает, если пользователь выбирает пункт меню, с помощью клавиатуры и нажимает клавишу ВВОД. Он также может возникать при нажатии клавиши доступа или сочетание клавиш, связанное с <xref:System.Windows.Forms.MenuItem>. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство для <xref:System.Windows.Forms.MenuItem> содержит элементы, это событие не возникает. Это событие не вызывается для родительских элементов меню.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Click> событию для выполнения задач при <xref:System.Windows.Forms.MenuItem> нажатии. В примере создается <xref:System.Windows.Forms.MainMenu> вызывается `mainMenu1` и складывает два <xref:System.Windows.Forms.MenuItem> объектов, `topMenuItem` (`File`) и `menuItem1` (`Open`). Затем подключается `Click` событие `menuItem1_Click` обработчик событий. Когда пользователь щелкает `Open` пункта меню, <xref:System.Windows.Forms.OpenFileDialog> инициализируется и отображается. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает копию <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает копию текущего поставщика <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий скопированный элемент меню.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> объекты не может использоваться в нескольких местах, если только вы получите копию <xref:System.Windows.Forms.MenuItem>. Можно вызвать этот метод для создания копии данного пункта меню для использования в <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, или других <xref:System.Windows.Forms.MenuItem> в вашем приложении. Когда элемент меню будет клонирована, все обработчики событий, указанный в исходном элементе меню будет продолжать работать в клонированный версии элемента меню. Например, если вы создали <xref:System.Windows.Forms.MenuItem> и подключения его <xref:System.Windows.Forms.MenuItem.Click> событий к обработчику событий. При клонировании пункта меню данного элемента меню копия будет вызывать тот же обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода примера клонов <xref:System.Windows.Forms.MenuItem> и отображает его в <xref:System.Windows.Forms.ContextMenu>. В этом примере требуется <xref:System.Windows.Forms.MenuItem> существует в <xref:System.Windows.Forms.MainMenu> на форму с именем `menuItem1` и что <xref:System.Windows.Forms.ContextMenu> объект с именем `contextMenu1` также существует в форме.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий копируемый элемент меню.</param>
        <summary>Создает копию заданного объекта <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для создания копий пунктов меню, которые вы уже создали для использования в контекстном меню или в другой структуре меню приложения. Эта версия <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> позволяет указать конкретный <xref:System.Windows.Forms.MenuItem> копируемые вместо пункта меню, который вызывает метод. Этот метод можно использовать для инициализации нового <xref:System.Windows.Forms.MenuItem> объект с копией другого <xref:System.Windows.Forms.MenuItem>. Когда элемент меню будет клонирована, все обработчики событий, указанный в исходном элементе меню будет продолжать работать в клонированный версии элемента меню. Например, если вы создали <xref:System.Windows.Forms.MenuItem> и подключения его <xref:System.Windows.Forms.MenuItem.Click> событий к обработчику событий. При клонировании пункта меню данного элемента меню копия будет вызывать тот же обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода инициализируется новый <xref:System.Windows.Forms.MenuItem> копию существующего <xref:System.Windows.Forms.MenuItem> , используемый в <xref:System.Windows.Forms.MainMenu> в форме. Затем код добавляет клонированный <xref:System.Windows.Forms.MenuItem> для <xref:System.Windows.Forms.ContextMenu> в форме. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> уже создан и с именем `menuItem1` и что <xref:System.Windows.Forms.ContextMenu> элемент управления создан и с именем `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, является ли данный элемент меню элементом по умолчанию.</summary>
        <value>Значение <see langword="true" />, если данный элемент меню является элементом меню по умолчанию, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент меню по умолчанию для меню отображается полужирным шрифтом. При двойном щелчке подменю, содержащий элемент по умолчанию выбран элемент по умолчанию и закрывается подменю. Можно использовать <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> свойство, указывающее, действие по умолчанию, которая ожидается в меню или в контекстном меню.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню с двумя элементами вложенного меню. В примере задается `menuItem2` как элемент меню по умолчанию с помощью <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> свойство.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> по окончании использования класса <xref:System.Windows.Forms.MenuItem>. Метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> оставляет класс <xref:System.Windows.Forms.MenuItem> в непригодном для использования состоянии. После вызова метода <xref:System.Windows.Forms.MenuItem.Dispose%2A>, необходимо освободить все ссылки на <xref:System.Windows.Forms.MenuItem> , занимаемая ими память может быть освобожден при коллекцией мусора.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> перед освобождением последней ссылки на класс <xref:System.Windows.Forms.MenuItem>. В противном случае ресурсы <xref:System.Windows.Forms.MenuItem> является не будут освобождены до сборки мусора не будет <xref:System.Windows.Forms.MenuItem> вызов деструктора объекта основы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда свойство <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> элемента меню устанавливается в значение <see langword="true" /> и выполняется запрос на отображение данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DrawItemEventArgs> Аргумент, передаваемый <xref:System.Windows.Forms.MenuItem.DrawItem> предоставляет обработчик событий <xref:System.Drawing.Graphics> объект, который позволяет выполнять рисование и другие графические операции на поверхности элемента меню. Этот обработчик событий можно использовать для создания пользовательских меню, соответствующие потребностям вашего приложения. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как обрабатывать <xref:System.Windows.Forms.MenuItem.DrawItem> событий. В этом примере рисуется элемент меню с использованием <xref:System.Drawing.Brush> и <xref:System.Drawing.Font>, а затем выводит <xref:System.Drawing.Rectangle> вокруг элемента меню. Рисование выполняется с помощью <xref:System.Drawing.Graphics> объект, который передается обработчику событий в <xref:System.Windows.Forms.DrawItemEventArgs> параметра. В этом примере требуется, что при инициализации <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойства для элемента `true`. В примере C# добавьте следующий код в конструктор формы после `InitializeComponent`, чтобы подключить событие:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включен ли элемент меню.</summary>
        <value>Значение <see langword="true" />, если данный пункт меню включен; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Forms.MenuItem> то есть отключено отображается серым цветом, чтобы сообщать о своем состоянии. Если родительский элемент меню отключен, не отображаются все элементы вложенного меню.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объекты, которые обеспечивают поддержку для вырезания, копирования и удаления, выполняемых включены перед отображением меню, они отображаются в. В примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, имеет фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> объекты создаются именованные `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее положение элемента меню в его родительском меню.</summary>
        <value>Отсчитываемый от нуля индекс, указывающий положение данного элемента в его родительском меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет индексированного положения элемента меню в коллекции элементов меню из его родительском меню. Это свойство можно использовать для перемещения элемента меню в другое расположение в пределах меню. Это свойство также можно использовать при создании <xref:System.Windows.Forms.MenuItem> для указания его позиции в структуре меню во время создания.  
  
   
  
## Examples  
 В следующем примере кода меняются местами два пункта меню в меню. В следующем примере кода требует двух <xref:System.Windows.Forms.MenuItem> объекты создаются именованные `menuItem1` и `menuItem2`. `menuItem1` Элемент меню перемещается на одну позицию вниз в меню, а `menuItem2` перемещается на одну позицию вверх.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение меньше нуля или больше, чем число элементов.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, содержит ли данный элемент меню дочерние элементы меню.</summary>
        <value>Значение <see langword="true" />, если данный элемент меню содержит дочерние элементы меню, и значение <see langword="false" />, если данное меню — отдельный элемент меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать это свойство с <xref:System.Windows.Forms.MenuItem.Parent%2A> свойство для перехода в код с помощью структуры всего меню.  
  
   
  
## Examples  
 В следующем примере кода определяется наличие любых подменю, связанные с <xref:System.Windows.Forms.MenuItem> с именем `menuItem1`. Если вложенные существует, он отключает их, задав <xref:System.Windows.Forms.MenuItem.Enabled%2A> свойства `false`. В примере требуется наличие <xref:System.Windows.Forms.MenuItem> названный `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли данный элемент меню заполняться с помощью списка дочерних окон интерфейса MDI, отображаемых в связанной форме.</summary>
        <value>Значение <see langword="true" />, если в этом элементе меню отображается список дочерних окон интерфейса MDI, и значение <see langword="false" /> в противном случае. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выборе пункта меню для отображения списка дочерних окон интерфейса MDI список как подменю для пункта меню. В списке окон отображаются только формы, которые определены как дочерних MDI-форм. Одновременно можно отобразить только девять дочерних окон. При наличии более девяти окон, пункт меню «Дополнительные Windows...» отображается в конце списка. При выборе этого пункта меню отображает диалоговое окно с полным списком дочерних окон, которые в настоящее время активны.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> , используемый для отображения списка открытых дочерних MDI-форм в форме MDI.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда меню требуются сведения о размере элемента меню перед его отрисовкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы это событие, необходимо иметь <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойство пункта меню значение `true`. Это событие вызывается до отрисовки меню его владельцем чтобы позволяют производить указать размер элемента меню. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.MenuItem.MeasureItem> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.MenuItem> с именем `MenuItem1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.MenuItem.MeasureItem> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее идентификатор Windows для данного элемента меню.</summary>
        <value>Идентификатор Windows для данного элемента меню.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет слияние этого элемента <see cref="T:System.Windows.Forms.MenuItem" /> с другим элементом <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет слияние этого элемента <see cref="T:System.Windows.Forms.MenuItem" /> с другим элементом <see cref="T:System.Windows.Forms.MenuItem" /> и возвращает элемент <see cref="T:System.Windows.Forms.MenuItem" />, полученный в результате слияния.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий объединенный элемент меню.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этой версии <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, <xref:System.Windows.Forms.MenuItem> возвращается является копией текущего элемента меню, можно объединить с другим элементом меню, не затрагивая функциональные возможности текущего элемента. Эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> аналогично вызову метода <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> метод, который не содержит параметров.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Объект <see cref="T:System.Windows.Forms.MenuItem" />, задающий элемент меню, предназначенный для слияния с данным элементом.</param>
        <summary>Выполняет слияние другого элемента меню с данным элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы меню объединяются согласно значению элемента меню <xref:System.Windows.Forms.MenuItem.MergeType%2A> и <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> свойства. Эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> метод позволяет объединять два <xref:System.Windows.Forms.MenuItem> объектов (и их подменю) в единое меню. Слияние меню обрабатывается автоматически, когда для родительской формы многодокументного интерфейса (MDI), так и дочерний элемент меню. Можно использовать эту версию метода для объединения двух <xref:System.Windows.Forms.MenuItem> объектов (и их подменю) находится в <xref:System.Windows.Forms.MainMenu> элемента управления в единое меню в <xref:System.Windows.Forms.ContextMenu>. Например, можно вызвать эту версию <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> способ слияния пунктов меню файла и измените в единую <xref:System.Windows.Forms.MenuItem> добавляемый и отображаемые <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 В следующем примере кода используется эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> метод, чтобы создать копию <xref:System.Windows.Forms.MenuItem> и объединить его с другим. Объединенный <xref:System.Windows.Forms.MenuItem> добавляется <xref:System.Windows.Forms.ContextMenu> элемента управления. В этом примере требуется, что существуют два элемента меню `menuItem1` и `menuItem2` , содержащих элементы вложенного меню в них и <xref:System.Windows.Forms.ContextMenu> с именем `contextMenu1` для отображения элементов меню. `menuItem1` и `menuItem2` другое меню элементов, содержащихся в них. После вызова <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> создается объединенное меню.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее относительное положение данного элемента меню при его слиянии с другим элементом.</summary>
        <value>Начинающийся с нуля индекс, представляющий позицию порядка слияния для данного элемента меню. Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок объединения элемента меню указывает относительное положение, которое будет занимать данный элемент, если структура меню, которое <xref:System.Windows.Forms.MenuItem> содержится в слиянии с другим.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> свойства для управления отображением меню после слияния. Это полный пример, готовый для выполнения после его добавления в проект.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее поведение данного элемента меню при слиянии его меню с другим меню.</summary>
        <value>Значение <see cref="T:System.Windows.Forms.MenuMerge" />, показывающее тип слияния данного элемента меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип слияния меню указывает поведение элемента меню, когда он находится в том же порядке слияния выполняется слияние другого элемента меню. Слияние меню можно использовать для создания объединенного меню на основе двух или более существующих меню.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> с <xref:System.Windows.Forms.MenuItem.MergeType%2A> и <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> , чтобы пункт меню добавляется к позиции первого объединенное меню.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Присваиваемое значение не относится к значениям <see cref="T:System.Windows.Forms.MenuMerge" />.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее назначенный символ, связанный с данным элементом меню.</summary>
        <value>Назначенный символ, сопоставленный с данным элементом меню. Возвращает символ NUL (код ASCII 0), если в тексте <see cref="T:System.Windows.Forms.MenuItem" /> не задан назначенный символ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначенный символ является первым символом после знак амперсанда (&) в тексте <xref:System.Windows.Forms.MenuItem>. Это свойство не будет возвращать мнемонический, если два символа амперсанда размещаются вместе, так как амперсанды используются для отображения амперсанда в тексте <xref:System.Windows.Forms.MenuItem> вместо определения мнемонический символ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Click> событию для выполнения задач при <xref:System.Windows.Forms.MenuItem> нажатии. В примере создается <xref:System.Windows.Forms.MainMenu> вызывается `mainMenu1` и складывает два <xref:System.Windows.Forms.MenuItem> объектов, `topMenuItem` (`File`) и `menuItem1` (`Open`). Затем подключается `Click` событие `menuItem1_Click` обработчик событий. Когда пользователь щелкает `Open` пункта меню, <xref:System.Windows.Forms.OpenFileDialog> инициализируется и отображается. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> в производном классе, не забудьте вызвать базовый класс <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.DrawItemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> в производном классе, не забудьте вызвать базовый класс <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> метод.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> в производном классе, не забудьте вызвать базовый класс <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> метод.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объекты, которые обеспечивают поддержку для вырезания, копирования и удаления, выполняемых включены перед отображением меню, они отображаются в. В примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, имеет фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> объекты создаются именованные `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> в производном классе, не забудьте вызвать базовый класс <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Select" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Select> событие <xref:System.Windows.Forms.MenuItem> для назначения текст справки для <xref:System.Windows.Forms.StatusBarPanel> из <xref:System.Windows.Forms.StatusBar> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> объектов с именем `menuOpen`, `menuSave`, и `menuExit` добавляются <xref:System.Windows.Forms.MainMenu> управления на форме. В этом примере также требуется <xref:System.Windows.Forms.StatusBar> управления с именем `statusBar1` был добавлен в форму. <xref:System.Windows.Forms.StatusBar> Элемент управления должен содержать <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> в производном классе, не забудьте вызвать базовый класс <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, будет элемент меню рисоваться с помощью передаваемого кода или средствами Windows.</summary>
        <value>Значение <see langword="true" />, если элемент меню рисуется в программном коде, и значение <see langword="false" />, если элемент меню рисуется средствами Windows. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойству `true`, вам нужно обрабатывать все изображение элемента меню. Эту возможность можно использовать для создания собственных стилей отображения меню.  
  
   
  
## Examples  
 В следующем примере кода показано меню с элементом-владельцем меню. Этот пример набора <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойство и использует `AddHandler` инструкции и `AddressOf` оператор, чтобы назначить делегата для обработки <xref:System.Windows.Forms.MenuItem.DrawItem> событий. Чтобы запустить пример, вставьте его в форме, которая импортирует <xref:System>, <xref:System.Windows.Forms>, и <xref:System.Drawing> пространства имен. Вызовите `InitializeMenu` из конструктора формы или `Load` метод.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее меню, содержащее данный элемент меню.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Menu" />, представляющий меню, содержащее данный элемент меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для получения <xref:System.Windows.Forms.Menu> объекта для подменю. Можно привести <xref:System.Windows.Forms.Menu> объект, возвращаемый этим свойством, чтобы <xref:System.Windows.Forms.MenuItem> для операций.  
  
   
  
## Examples  
 В этом примере создания главного меню и элемент меню верхнего уровня, `menuItem1` (`File`). Можно также создать два пункта меню, `menuItem2` (`New`) и `menuItem3` (`Open`) и добавить их в список элементов меню из `menuItem1`. Затем проверьте ли `menuItem3` есть родительский элемент меню, которое имеет значение true и отображать сведения об этом родительском меню в окне сообщения. В этом примере требуется, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает событие <see cref="E:System.Windows.Forms.Control.Click" />, имитирующее щелчок мышью для элемента <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этом меню можно использовать для активации элемента меню с помощью кода без передачи каких-либо сведений. Например, если вы хотите активировать элемент меню на основе действия, происходящего в приложении, можно вызвать <xref:System.Windows.Forms.MenuItem.PerformClick%2A> метод для этого <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 В этом примере вы программными средствами пункта меню с помощью `PerformClick` метод. Во-первых, создается основное меню (`mainMenu1`) и добавьте в него два пункты меню, `menuItem1` (`File`) и `menuItem2` (`Edit`). Можно также использовать <xref:System.Windows.Forms.MenuItem.Click> событий для отправки данных в обработчик событий, при выборе пункта меню. После этого использовать `PerformClick` способ щелкните `File` пункта меню. При запуске приложения, `File` активируется пункта меню, и появится сообщение, содержащее текст «файл при выборе меню». отображается на экране. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Select" /> для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет вызывать <xref:System.Windows.Forms.MenuItem.Select> событий без передачи каких-либо сведений в обработчик событий.  
  
   
  
## Examples  
 В этом примере, программный Выбор пункта меню с помощью `PerformSelect` метод. Во-первых, создается основное меню (`mainMenu1`) и добавьте в него два пункты меню, `menuItem1` (`File`) и `menuItem2` (`Edit`). Можно также использовать <xref:System.Windows.Forms.MenuItem.Select> событий для отправки данных в обработчик событий, при выборе пункта меню. После этого использовать `PerformSelect` метод, чтобы выбрать `File` пункта меню. При запуске приложения, `File` выбран пункт меню, и появится сообщение, содержащее текст «файл меню выбран». отображается на экране. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед отображением списка элементов меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает только в том случае, когда в пункте меню есть вложенное меню элементов для отображения. Этот обработчик событий можно использовать для добавления, удаления, включить, отключить, установите или снимите флажок пунктов меню, на основе состояния приложения перед их отображением. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объекты, которые обеспечивают поддержку для вырезания, копирования и удаления, выполняемых включены перед отображением меню, они отображаются в. В примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, имеет фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> объекты создаются именованные `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, будет ли в случае выбора элемента <see cref="T:System.Windows.Forms.MenuItem" /> выводиться переключатель, а не флажок.</summary>
        <value>Значение <see langword="true" />, если вместо флажка будет использоваться переключатель, и значение <see langword="false" />, если в случае выбора элемента меню будет отображаться стандартный флажок. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Флажки не обязательно подразумевают взаимно исключают друг друга состояние для группы элементов меню. Это свойство можно использовать, чтобы уведомить пользователя, что флажок элемента меню являются взаимно исключающими.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство для изменения состояния приложения. В примере группу пунктов меню, при условии, что используются для указания цвета для текста в <xref:System.Windows.Forms.TextBox> элемента управления. В примере используется обработчик событий, которые предоставляются <xref:System.Windows.Forms.MenuItem.Click> событий трех пунктов. Каждый пункт меню задает цвет, `menuItemRed`, `menuItemGreen`, или `menuItemBlue`. Обработчик событий определяет, какой пункт меню выбран, устанавливает флажок для выбранного пункта меню и изменяет цвет текста в формате <xref:System.Windows.Forms.TextBox> управления с именем `textBox1`. В примере также используется <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> свойство, чтобы продемонстрировать, как флажок «переключатель» используется для отображения элементов меню, которые являются взаимоисключающими. В этом примере требуется, <xref:System.Drawing?displayProperty=nameWithType> пространство имен был добавлен в форму, содержащую этот код.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь наводит указатель мыши на элемент меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие обычно возникает, когда пользователь наводит указатель мыши на элемент меню. Это событие может возникнуть также в тех случаях, когда пользователь выделяет элемент меню с помощью клавиатуры, прокрутите до пункта меню с помощью клавиш со стрелками. Это событие можно использовать для отображения строки с подробной справки, относящейся к данной команды меню в строке состояния приложения. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство для <xref:System.Windows.Forms.MenuItem> содержит элементы, это событие не возникает. Это событие не вызывается для родительских элементов меню.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Select> событие <xref:System.Windows.Forms.MenuItem> для назначения текст справки для <xref:System.Windows.Forms.StatusBarPanel> из <xref:System.Windows.Forms.StatusBar> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> объектов с именем `menuOpen`, `menuSave`, и `menuExit` добавляются <xref:System.Windows.Forms.MainMenu> управления на форме. В этом примере также требуется <xref:System.Windows.Forms.StatusBar> управления с именем `statusBar1` был добавлен в форму. <xref:System.Windows.Forms.StatusBar> Элемент управления должен содержать <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее сочетание клавиш для данного элемента меню.</summary>
        <value>Одно из значений <see cref="T:System.Windows.Forms.Shortcut" />. Значение по умолчанию — <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сочетания клавиш позволяют пользователям активировать часто используемые элементы в систему меню, а также возможность доступ с клавиатуры в приложение для пользователей, которым не имеют доступа к мыши или другого устройства указатель.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает видимой пункта меню и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана то есть с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Присваиваемое значение не относится к значениям <see cref="T:System.Windows.Forms.Shortcut" />.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли сочетание клавиш для данного элемента меню, отображаться рядом с текстом подписи для этого элемента.</summary>
        <value>Значение <see langword="true" />, если сочетание клавиш отображается рядом с надписью элемента меню, и значение <see langword="false" />, если сочетание клавиш не отображается. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для предоставления возможности для пользователей скрыть ярлыки из меню для экономии места или скрыть сочетания клавиш будут отображаться.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает видимой пункта меню и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана то есть с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее подпись данного элемента меню.</summary>
        <value>Текст подписи данного элемента меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню, можно также указать ключ доступа, поместив символ «&» перед символом для использования в качестве ключа доступа. Например чтобы указать «F» в «Файл» как ключ доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для обеспечения меню с помощью клавиатуры.  
  
 Установка этого свойства в "`-`" вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает видимой пункта меню и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана то есть с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую объект <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Строка, представляющая текущий объект <see cref="T:System.Windows.Forms.MenuItem" />. Строка содержит тип и свойство <see cref="P:System.Windows.Forms.MenuItem.Text" /> элемента управления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли видимым данный элемент меню.</summary>
        <value>Значение <see langword="true" />, если данный элемент меню будет виден в меню. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для изменения структуры меню без необходимости объединения или отключения меню. Например, если вы хотите скрыть часть функциональности из меню в приложении, можно скрыть их от пользователя, установив это свойство `false`.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает видимой пункта меню и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана то есть с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>