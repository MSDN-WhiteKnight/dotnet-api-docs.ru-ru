<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76d4d835f6dce4521d61c90bd9496531e320c717" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58701900" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кодировку символов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. В отличие от этого декодирование — это процесс преобразования последовательность закодированных байтов в набор символов Юникода. Сведения о Юникоде преобразование форматов (форматах UTF) и другие кодировки, поддерживаемые <xref:System.Text.Encoding>, см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Обратите внимание, что <xref:System.Text.Encoding> предназначен для работы с символами Юникода, а не произвольных двоичных данных, таких как массивы байтов. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, например uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Платформа .NET предоставляет следующие реализации <xref:System.Text.Encoding> класс для поддержки текущей кодировки Юникод и другие кодировки:  
  
-   <xref:System.Text.ASCIIEncoding> Кодирует символы Юникода как один 7-разрядных символов ASCII. В этом кодировка поддерживает только значения символов от U + 0000 и U + 007F. Кодовая страница 20127. Также доступно в центре <xref:System.Text.Encoding.ASCII%2A> свойство.  
  
-   <xref:System.Text.UTF7Encoding> Кодирует символы Юникода, используя кодировку UTF-7. Эта кодировка поддерживает все символы Юникода. Кодовая страница 65000. Также доступно в центре <xref:System.Text.Encoding.UTF7%2A> свойство.  
  
-   <xref:System.Text.UTF8Encoding> Кодирует символы Юникода, используя кодировку UTF-8. Эта кодировка поддерживает все символы Юникода. Кодовая страница 65001. Также доступно в центре <xref:System.Text.Encoding.UTF8%2A> свойство.  
  
-   <xref:System.Text.UnicodeEncoding> Кодирует символы Юникода, используя кодировку UTF-16. Поддерживаются оба порядка мало обратный порядок байтов и больших порядком байтов. Также доступно в центре <xref:System.Text.Encoding.Unicode%2A> свойство и <xref:System.Text.Encoding.BigEndianUnicode%2A> свойство.  
  
-   <xref:System.Text.UTF32Encoding> Кодирует символы Юникода, используя кодировку UTF-32. Мало порядок байтов (кодовая страница 12000) и с обратным порядком байтов (кодовая страница 12001) байтов поддерживаются порядка. Также доступно в центре <xref:System.Text.Encoding.UTF32%2A> свойство.  
  
 <xref:System.Text.Encoding> Класс в основном предназначен для преобразования между разными кодировками и Юникодом. Часто один из производных классов Юникод является правильным выбором для вашего приложения.  
  
 Используйте <xref:System.Text.Encoding.GetEncoding%2A> метод, чтобы получить другие кодировки и вызовите <xref:System.Text.Encoding.GetEncodings%2A> метод для получения списка всех кодировок.  
  
 В следующей таблице перечислены кодировках, поддерживаемых .NET Framework и .NET Core. В ней перечислены каждой кодировки номер кодовой страницы и значения кодировки <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> и <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> свойства. Флажок в **поддержки .NET Framework** и **поддержки .NET Core** столбцов показывает, что кодовая страница поддерживается такой реализацией .NET вне зависимости от базовой платформы. Для .NET Framework доступность других кодировок, перечисленные в таблице, зависит от операционной системы. Для .NET Core, другие кодировки доступны с помощью <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> класса или путем создания производного класса от <xref:System.Text.EncodingProvider?displayProperty=nameWithType> класса.  

> [!NOTE]
> Кодовые страницы, <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> свойство соответствует международному стандарту не обязательно соответствуют полностью с помощью этого стандарта. 

|Кодовая страница|name|Отображаемое имя|Поддержка .NET framework| Поддержка .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (США Канада)|||  
|437|IBM437|OEM-USA|||  
|500|IBM500|IBM EBCDIC (международная)|||  
|708|ASMO-708|Арабская (ASMO 708)|||  
|720|DOS-720|Арабская (DOS)|||  
|737|ibm737|Řečtina (DOS)|||  
|775|ibm775|Балтийская (DOS)|||  
|850|ibm850|Западно-европейская (DOS)|||  
|852|ibm852|Центрально-европейская (DOS)|||  
|855|IBM855|OEM-кириллица|||  
|857|ibm857|Turečtina (DOS)|||  
|858|IBM00858|OEM-многоязычная латиница I|||  
|860|IBM860|Portugalština (DOS)|||  
|861|ibm861|Islandština (DOS)|||  
|862|DOS-862|Hebrejština (DOS)|||  
|863|IBM863|Французская канадская (DOS)|||  
|864|IBM864|Арабский (864)|||  
|865|IBM865|Скандинавская (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Греческая, современная (DOS)|||  
|870|IBM870|IBM EBCDIC (многоязыкового латиница-2)|||  
|874|Windows-874|Тайский (Windows)|||  
|875|cp875|IBM EBCDIC (греческая, Совр.)|||  
|932|shift_jis|Japonština (Shift-JIS)|||  
|936|GB2312|Китайский, упрощенное письмо (GB2312)|✓||  
|949|ks_c_5601-1987|Корейский|||  
|950|Big5|Китайская традиционная (Big5)|||  
|1026|IBM1026|IBM EBCDIC (Turečtina-Latin 5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (США Канада Европа)|||  
|1141|IBM01141|IBM EBCDIC (Německo Euro)|||  
|1142|IBM01142|IBM EBCDIC (Дания Норвегия Европа)|||  
|1143|IBM01143|IBM EBCDIC (Финляндия Швеция Европа)|||  
|1144|IBM01144|IBM EBCDIC (Италия Европа)|||  
|1145|IBM01145|IBM EBCDIC (Španělsko Euro)|||  
|1146|IBM01146|IBM EBCDIC (Великобритания Европа)|||  
|1147|IBM01147|IBM EBCDIC (Francie Euro)|||  
|1148|IBM01148|IBM EBCDIC (международная Европа)|||  
|1149|IBM01149|IBM EBCDIC (Island Euro)|||  
|1200|UTF-16|Юникод|✓|✓|  
|1201|unicodeFFFE|Юникод (Big endian)|✓|✓|  
|1250|Windows-1250|Центрально-европейская (Windows)|||  
|1251|Windows 1251|Кириллица (Windows)|||  
|1252|Windows-1252|Западно-европейская (Windows)|✓||  
|1253|Windows-1253|Греческий (Windows)|||  
|1254|Windows-1254|Турецкий (Windows)|||  
|1255|Windows-1255|Иврит (Windows)|||  
|1256|Windows-1256|Арабский (Windows)|||  
|1257|Windows 1257|Балтийская (Windows)|||  
|1258|Windows-1258|Вьетнамский (Windows)|||  
|1361|Джохаб|Korejština (Johab)|||  
|10000|Macintosh|Западно-европейская (Mac)|||  
|10001|x — mac — японский|Japonština (Mac)|||  
|10002|x-mac-chinesetrad|Китайская, традиционное письмо (Mac)|||  
|10003|x — mac — корейский|Корейская (Mac)|✓||  
|10004|x-mac — арабский|Arabština (Mac)|||  
|10005|x-mac иврит|Hebrejština (Mac)|||  
|10006|x-mac греческая|Řečtina (Mac)|||  
|10007|x-mac кириллица|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|Китайский, упрощенное письмо (Mac)|✓||  
|10010|x-mac румынский|Rumunština (Mac)|||  
|10017|x-mac украинский|Ukrajinština (Mac)|||  
|10021|x-mac тайская|Thajština (Mac)|||  
|10029|x-mac-ce|Центрально-европейская (Mac)|||  
|10079|x-mac исландская|Islandština (Mac)|||  
|10081|x-mac — турецкий|Turečtina (Mac)|||  
|10082|x — mac Хорватский|Хорватский (Mac)|||  
|12000|UTF-32|Юникод (UTF-32)|✓|✓|  
|12001|utf-32BE|Юникод (UTF-32 Big endian)|✓|✓|  
|20000|x китайский CNS|Китайская, традиционное письмо (CNS)|||  
|20001|x-cp20001|TCA Taiwan|||  
|20002|Китайский x-Eten|Китайский традиционный (письмо Eten)|||  
|20003|x-cp20003|Тайвань IBM5550|||  
|20004|x-cp20004|Тайвань телетекста|||  
|20005|x-cp20005|Tchaj-WAN|||  
|20105|x-IA5|Западно-европейская (IA5)|||  
|20106|x — IA5 — немецкий|Němčina (IA5)|||  
|20107|x-IA5 — шведский|Шведская (IA5)|||  
|20108|x-IA5 — норвежский|Norština (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Германия)|||  
|20277|IBM277|IBM EBCDIC (Дания Норвегия)|||  
|20278|IBM278|IBM EBCDIC (Финляндия Швеция)|||  
|20280|IBM280|IBM EBCDIC (Италия)|||  
|20284|IBM284|IBM EBCDIC (Španělsko)|||  
|20285|IBM285|IBM EBCDIC (ВЕЛИКОБРИТАНИЯ)|||  
|20290|IBM290|IBM EBCDIC (Japonsko-katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (арабская)|||  
|20423|IBM423|IBM EBCDIC (Řečtina)|||  
|20424|IBM424|IBM EBCDIC (Hebrejština)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (корейская, расширенное письмо)|||  
|20838|Тайский IBM|IBM EBCDIC (Thajština)|||  
|20866|KOI8-r|Кириллица (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Islandština)|||  
|20880|IBM880|IBM EBCDIC (кириллица, русский)|||  
|20905|IBM905|IBM EBCDIC (Turečtina)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Японская (JIS 0208-1990 и 0212-1990)|||  
|20936|x-cp20936|Китайский, упрощенное письмо (GB2312-80)|✓||  
|20949|x-cp20949|Корейская, вансун|✓||  
|21025|cp1025|IBM EBCDIC (кириллица, сербский, болгарский)|||  
|21866|KOI8-u|Кириллица (КОИ8 U)|||  
|28591|ISO-8859-1|Западно-европейская (ISO)|✓|✓|  
|28592|ISO-8859-2|Центрально-европейская (ISO)|||  
|28593|ISO-8859-3|Латиница-3 (ISO)|||  
|28594|ISO-8859-4|Балтийская (ISO)|||  
|28595|ISO-8859-5|Cyrilice (ISO)|||  
|28596|ISO-8859-6|Arabština (ISO)|||  
|28597|ISO-8859-7|Řečtina (ISO)|||  
|28598|ISO-8859-8|Иврит (ISO-Visual)|✓||  
|28599|ISO-8859-9|Turečtina (ISO)|||  
|28603|ISO-8859-13|Estonština (ISO)|||  
|28605|ISO-8859-15|Латиница 9 (ISO)|||  
|29001|x-Europa|Европа|||  
|38598|ISO-8859-8-i|Иврит (ISO-Logical)|✓||  
|50220|ISO-2022-jp|Японская (JIS)|✓||  
|50221|csISO2022JP|Японская (JIS-Povolen 1 bajt Kana)|✓||  
|50222|ISO-2022-jp|Японская (JIS-Povolen 1 bajt Kana - поэтому / SI)|✓||  
|50225|ISO-2022-kr|Корейская (ISO)|✓||  
|50227|x-cp50227|Китайский, упрощенное письмо (ISO-2022)|✓||  
|51932|euc-jp|Japonština (EUC)|✓||  
|51936|EUC-CN|Китайский, упрощенное письмо (EUC)|✓||  
|51949|EUC-kr|Korejština (EUC)|✓||  
|52936|Гц gb-2312|Китайский, упрощенное письмо (HZ)|✓||  
|54936|GB18030|Китайская упрощенная (GB18030)|✓||  
|57002|x-iscii-de|ISCII девангари|✓||  
|57003|x-iscii-be|ISCII Бенгальский|✓||  
|57004|x-iscii-ta|ISCII-Tamilština|✓||  
|57005|x-iscii-te|ISCII-Telugština|✓||  
|57006|x-iscii-as|ISCII ассамская|✓||  
|57007|или x iscii|ISCII-Urijština|✓||  
|57008|iscii-x ка|ISCII-Kannadština|✓||  
|57009|iscii-x-ma|ISCII Малайалам|✓||  
|57010|iscii-x-gu|ISCII Гухарати|✓||  
|57011|x-iscii-pa|ISCII Пунджаби|✓||  
|65000|utf-7|Юникод (UTF-7)|✓|✓|  
|65001|utf-8|Юникод (UTF-8)|✓|✓|  
  
 В следующем примере вызывается <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> и <xref:System.Text.Encoding.GetEncoding%28System.String%29> методы получения греческий (Windows) кода страницы кодировки. Он сравнивает <xref:System.Text.Encoding> объектов, возвращенных вызовы методов, чтобы показать, что они равны, и затем отображает карты кодовая точка Юникода и значение соответствующей кодовой страницы для каждого символа в греческого алфавита.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 UTF-16 и UTF-32 кодировщикам, которые можно использовать обратный порядок байтов (самый старший байт первого) или прямой порядок байтов (младший байт первый). Например прописная латинская буква (U + 0041) сериализуется как следующим образом (в шестнадцатеричном формате):  
  
-   UTF-16 обратный порядок байтов: 00 41  
  
-   Прямой порядок байтов UTF-16: 41 00  
  
-   UTF-32 обратный порядок байтов: 00 00 00 41  
  
-   Прямой порядок байтов UTF-32: 41 00 00 00  
  
 Он обычно более эффективен для хранения символов Юникода, с помощью собственного порядка байтов. Например лучше использовать прямой порядок байтов на платформах с прямым порядком, таких как компьютеры Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Метод получает массив байтов, который включает в себя отметки порядка байтов (BOM). Если этот массив байтов, отмеченную в поток с кодировкой, декодер для идентификации используемый формат кодирования.  
  
 Дополнительные сведения о порядке байтов и отметки порядка байтов, см. в разделе стандарта Юникод на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Обратите внимание, что классы кодировок допускают ошибки:  
  
-   Без предупреждения изменять для «?» символов.  
  
-   Используйте символ «best fit».  
  
-   Изменить на поведение конкретного приложения с помощью <xref:System.Text.EncoderFallback> и <xref:System.Text.DecoderFallback> классы с замещающий символ U + FFFD Юникода.  
  
 Должен создавать исключение в случае любой ошибки потока данных. Приложение использует флаг «throwonerror», если это применимо, или использует <xref:System.Text.EncoderExceptionFallback> и <xref:System.Text.DecoderExceptionFallback> классы. Наиболее подходящая fallback часто не рекомендуется, поскольку он может привести к потере данных или путаницу и выполняется медленнее, чем обычная замена символов. Для кодировки ANSI рекомендуется применять эту стратегию по умолчанию.  
  
   
  
## Examples  
 Следующий пример преобразует строку из одной кодировки в другую.  
  
> [!NOTE]
>  Массив byte [] является единственным типом в этом примере, который содержит закодированные данные. Типы .NET Char и String, сами Юникода, поэтому <xref:System.Text.Encoding.GetChars%2A> вызов декодирует данные в формат Юникод.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы переопределяют этот конструктор.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы предпочтительной кодировки.  
  
-или- 
0, если требуется использовать кодировку по умолчанию.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы переопределяют этот конструктор.  
  
 Создать как этот конструктор производного класса <xref:System.Text.Encoding> объект, который использует резервную стратегию наилучшего для кодирования и декодирования операции. Как <xref:System.Text.Encoding.DecoderFallback%2A> и <xref:System.Text.Encoding.EncoderFallback%2A> свойства доступны только для чтения и не может быть изменен. Для управления резервной стратегии для класса, производного от <xref:System.Text.Encoding>, вызовите <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы кодировки.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице, с использованием указанных стратегий резервирования кодировщика и декодера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор является `protected`; производные классы переопределяют его.  
  
 Вызовите этот конструктор производного класса для управления в резервном кодирования и декодирования стратегии. <xref:System.Text.Encoding> Конструкторов классов создать только для чтения объектам кодировок, которые не позволяют кодировщика или резерва декодера, устанавливаемое после создания объекта.  
  
 Если параметр `encoderFallback` или `decoderFallback` имеет значение null, наилучшего используется в качестве соответствующего резервной стратегии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для набора символов ASCII (7-разрядных).</summary>
        <value>Кодировка набора символов ASCII (7-разрядных).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы ASCII ограничены наименьшее 128 символов Юникода, от U + 0000 до U + 007F.  
  
 При выборе кодировки ASCII для вашего приложения, учитывайте следующее:  
  
-   Кодировка ASCII обычно подходит для протоколов, требующих ASCII.  
  
-   Если вам требуется 8-разрядная кодировка (которую иногда ошибочно называют «ASCII»), кодировка UTF-8 предпочтительнее ASCII кодировка. Наличие символов 0-7F результаты идентичны, но использование UTF-8 позволяет избежать потери данных благодаря возможности представления всех символов Юникода, которые можно представить. Обратите внимание, что кодировка ASCII 8-й бит неоднозначность, можно разрешить вредоносное использование, но кодировку UTF-8 устраняет неоднозначность о 8-й бит.  
  
-   В версиях .NET Framework версии 2.0 платформы .NET Framework разрешен спуфинг, игнорируя 8-й бит. Начиная с .NET Framework 2.0, отличные от ASCII кодовые точки переключиться во время декодирования.  
  
 <xref:System.Text.ASCIIEncoding> Возвращаемый этим свойством объект может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать с вопросительным знаком ("?») символ. Вместо этого можно вызвать <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> метод для создания экземпляра <xref:System.Text.ASCIIEncoding> которого резервный метод, либо объект <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано влияние кодировки ASCII на символы, которые находятся за пределами диапазона ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с обратным порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-16 с обратным порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Возвращаемый этим свойством объект может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать с вопросительным знаком ("?») символ. Вместо этого можно вызвать <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктор для создания экземпляра с обратным порядком байтов <xref:System.Text.UnicodeEncoding> которого резервный метод, либо объект <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Возвращенный <xref:System.Text.UnicodeEncoding> объект имеет <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, и <xref:System.Text.Encoding.WebName%2A> свойства, позволяющие найти имя «unicodeFFFE». Несмотря на то, что порядка следования обратным порядком байтов в кодировке UTF-16 — шестнадцатеричное число FEFF, имя «unicodeFFFE» был выбран, так как метка порядка байтов отображается как шестнадцатеричное число FFFE на прямым порядком байтов компьютерах Windows.  
  
   
  
## Examples  
 В следующем примере считываются в текстовый файл с кодировкой UTF-16, с помощью обратный порядок байтов.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами текста сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами текста сообщения почтового агента.  
  
-или- 
Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вам нужна кодировка для текста имя, необходимо вызвать <xref:System.Text.Encoding.GetEncoding%2A> с <xref:System.Text.Encoding.BodyName%2A> свойство. Этот метод часто извлекает другую кодировку из тестовой кодировки, которой он вызывается. Обычно только почтовые приложения необходимо получить такое кодирование; Большинство других приложений, которые необходимо описать кодировку следует использовать его <xref:System.Text.Encoding.WebName%2A>.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойство соответствует международный стандарт, определяющий эту кодировку. Это не значит, что реализация соответствует в полном объеме с этого стандарта.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но не выполняет сравнение на ее основе.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создается неполная копия текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <returns>Копия текущего объекта <see cref="T:System.Text.Encoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клон доступен для записи даже в том случае, если исходный <xref:System.Text.Encoding> объект доступен только для чтения. Таким образом можно изменить свойства копии.  
  
 Неполная копия объекта является копией только данного объекта. Если объект содержит ссылки на другие объекты, неполная копия не приводит к созданию копии объектов, который указывает ссылка. Он ссылается на исходные объекты вместо этого. Напротив глубокую копию объекта создает копию объекта и копию всего содержимого, прямо или косвенно ссылается этот объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но не выполняет сравнение на ее основе.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует массив байтов из одной кодировки в другую.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Формат кодировки параметра <paramref name="bytes" />.</param>
        <param name="dstEncoding">Целевой формат кодировки.</param>
        <param name="bytes">Преобразуемые байты.</param>
        <summary>Преобразует весь массив байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результаты преобразования <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример преобразует строку в кодировке Юникод в строку в формате ASCII. Так как объект кодировки ASCII, возвращаемый методом <xref:System.Text.Encoding.ASCII%2A> свойство использует резервную стратегию замены и Pi символ не является частью набора символов ASCII, Pi символ заменяется вопросительным знаком, как видно в результатах показано в примере.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="dstEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Кодировка исходного массива, <paramref name="bytes" />.</param>
        <param name="dstEncoding">Кодировка выходного массива.</param>
        <param name="bytes">Преобразуемый массив байтов.</param>
        <param name="index">Индекс первого элемента преобразуемого массива байтов <paramref name="bytes" />.</param>
        <param name="count">Число байтов, которые требуется преобразовать.</param>
        <summary>Преобразует диапазон байтов в массиве байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результат преобразования диапазона байтов из массива <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="dstEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> и <paramref name="count" /> не определяют допустимый диапазон в массиве байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.DecoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект декодера для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Представляет обработчик ошибок, который вызывается при закодированную последовательность байтов не может быть декодирована в символ. Поддерживается любой из следующие типы обработчиков:  
  
-   Наилучшее резервному обработчику, который заменяет байтов, которые не может быть декодирована с каким либо знаком подходящие замены.  
  
-   Замена резервному обработчику, который заменяет байтов, которые не удается декодировать некоторые произвольные замещающий символ. .NET включает в себя один резервному обработчику замены <xref:System.Text.DecoderFallback>, который по умолчанию заменяет байтов, которые не может быть декодирована с вопросительным знаком ("?») символ.  
  
-   Резервный обработчик исключений, который создает исключение, когда байтов не может быть декодирована. .NET включает в себя один резервный обработчик исключений, <xref:System.Text.DecoderExceptionFallback>, какие вызывает <xref:System.Text.DecoderFallbackException> при байтов не может быть декодирована.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В операции задания значением является <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает кодировку по умолчанию для данной реализации .NET.</summary>
        <value>Кодировка по умолчанию для данной реализации .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Разные компьютеры могут использовать различные кодировки по умолчанию, и кодировку по умолчанию можно изменить на одном компьютере. Если вы используете <xref:System.Text.Encoding.Default%2A> кодировку для кодирования и декодирования данных потоковый между компьютерами или получены в разное время на одном компьютере может преобразовать эти данные неправильно. Кроме того, кодировка возвращаемые <xref:System.Text.Encoding.Default%2A> свойство использует резервную стратегию наилучшего для сопоставления неподдерживаемые символы и символы, которые поддерживаются с помощью кодовой страницы. По этим причинам не рекомендуется использовать кодировку по умолчанию. Чтобы обеспечить правильное декодирование закодированных байтов, следует использовать кодировку Юникод, такие как <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>. Чтобы убедиться, что тот же формат используется для кодирования и декодирования можно также использовать протокол более высокого уровня.  

### <a name="the-default-property-in-the-net-framework"></a>Свойство по умолчанию в .NET Framework

В .NET Framework на рабочем столе Windows <xref:System.Text.Encoding.Default%2A> свойство всегда возвращает активную кодовую страницу системы и создает <xref:System.Text.Encoding> объекта, который соответствует к нему. Текущая кодовая страница может быть кодовая страница ANSI, включая кодировки ASCII и дополнительные символы, которые различаются по кодовой странице. Так как все <xref:System.Text.Encoding.Default%2A> кодировки, кодовые страницы ANSI, потеря данных, рассмотрите возможность использования <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> вместо кодировки. UTF-8 идентична часто в U + 00 диапазона U + 7F, но позволяет кодировать символы вне диапазона ASCII, без потери.

## <a name="the-default-property-on-net-core"></a>Свойство по умолчанию в .NET Core

В .NET Core <xref:System.Text.Encoding.Default%2A> свойство всегда возвращает <xref:System.Text.UTF8Encoding>. UTF-8 поддерживается во всех операционных системах (Windows, Linux и Max OS X) на котором выполняются приложения .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.EncoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект кодировщика для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Представляет обработчик ошибок, который вызывается, когда символ не может быть преобразован в закодированную последовательность байтов. Поддерживается любой из следующие типы обработчиков:  
  
-   Наилучшее резервному обработчику, который заменяет символы, которые не может быть закодирован с каким либо знаком подходящие замены.  
  
-   Замена резервному обработчику, который заменяет символы, которые не удается закодировать некоторые произвольные замещающий символ. .NET включает в себя один резервному обработчику замены <xref:System.Text.EncoderFallback>, который по умолчанию заменяет символы, которые не удается закодировать знак вопроса ("?») символ.  
  
-   Резервный обработчик исключений, который создает исключение, если символы не может быть закодирован. .NET включает в себя один резервный обработчик исключений, <xref:System.Text.EncoderExceptionFallback>, какие вызывает <xref:System.Text.EncoderFallbackException> при символов не может быть декодирована.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В операции задания значением является <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание текущей кодировки, которое может быть прочитано пользователем.</summary>
        <value>Описание текущего объекта <see cref="T:System.Text.Encoding" />, которое может быть прочитано пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Свойство предназначено для отображения. Чтобы найти имя, которое может быть передан <xref:System.Text.Encoding.GetEncoding%2A> используйте <xref:System.Text.Encoding.WebName%2A> свойство.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но не выполняет сравнение на ее основе.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, равен ли указанный объект <see cref="T:System.Object" /> текущему экземпляру.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="value" /> является экземпляром <see cref="T:System.Text.Encoding" />, равным текущему экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два экземпляра <xref:System.Text.Encoding> считаются равными, если они соответствуют ту же кодовую страницу и их `EncoderFallback` и `DecoderFallback` объекты равны. В частности, все производные кодовые страницы имеют кодовую страницу 0 и их резервные варианты обычно `null` (`Nothing` в Visual Basic .NET). Таким образом они считаются равными. Одним из недостатков является то, что при <xref:System.Text.Encoding.Equals%2A> используется для заполнения хэш-таблицу, все производные кодировки считаются равными и попадают в тот же слот хэш-таблице.  
  
   
  
## Examples  
 Следующий пример возвращает два экземпляра одной и той же кодировку (по одному по кодовой странице), а другой по имени и проверяют их равенство.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании всех символов из заданного массива символов.</summary>
        <returns>Количество байтов, полученных при кодировании всех символов из указанного массива символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученных байтов, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, следует использовать строки версии <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <summary>При переопределении в производном классе вычисляет число байтов, полученных при кодировании символов в заданной строке.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученных байтов, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, строковую версию <xref:System.Text.Encoding.GetBytes%2A> рекомендуется.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, кодирует символы и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов, начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, который <xref:System.Text.Encoding.GetBytes%2A> требуется для хранения полученных байтов, следует вызывать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые рекомендации по использованию этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%2A> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для сохранения полученных байтов, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется.  
  
-   Если приложение обрабатывает входные строки, строковую версию <xref:System.Text.Encoding.GetBytes%2A> рекомендуется.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования трех символов из массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, необходимо вызвать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метод.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы заданной строки в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, кодирует символы и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования трех символов из массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>При переопределении в производном классе кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются, начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, который <xref:System.Text.Encoding.GetBytes%2A> требуется для сохранения полученных байтов, вызвать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения полученных байтов, следует вызывать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования трех символов из массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
-или- 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из заданной строки в заданный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения полученных байтов, следует вызывать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Метод определяет, сколько байтов привести кодировании набора символов Юникода и <xref:System.Text.Encoding.GetBytes%2A> метод выполняет фактическое кодирование. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> метод, который обрабатывает несколько преобразований на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться закодировать множество входных символов в кодовую страницу и обработка символов, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> объект используется. (Например, последовательность символов, которая включает в себя суррогатные пары может заканчиваться старшим символом-заместителем. <xref:System.Text.Encoder> Запомнит старший символ-заместитель, таким образом, чтобы ее можно использовать совместно с младшим символом-заместителем в начале следующего вызова. <xref:System.Text.Encoding> Невозможно использовать для поддержания состояния, поэтому будет отправлен символ <xref:System.Text.EncoderFallback>.)  
  
-   Если приложение обрабатывает входные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами с помощью <xref:System.Text.Encoder> объекта или вставить в существующих буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> версию, которая поддерживает массивы байтов является лучшим выбором.  
  
-   Рассмотрите возможность использования <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetByteCount%2A>. Метод преобразования преобразует можно столько данных и создания исключения, если выходной буфер слишком мал. Для непрерывного кодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования строки или диапазона в строке, кодирует символы и отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
-или- 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании всех байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> метод. Чтобы вычислить максимальный размер массива, следует использовать <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> метод. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает строки, следует использовать <xref:System.Text.Encoding.GetString%2A> метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка кодируется в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов, начало которой задается указателем байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, который <xref:System.Text.Encoding.GetChars%2A> требуется для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример преобразует строку из одной кодировки в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере строка кодируется в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> поскольку <xref:System.Text.Encoding> ожидает дискретных преобразования, хотя <xref:System.Text.Decoder> предназначен для нескольких этапов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольных двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать протокол, например uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, так как последовательности байтов может быть прервана, при обработке в пакетах. (Например, один может оказаться часть последовательности shift ISO-2022 <xref:System.Text.Encoding.GetChars%2A> вызова и по-прежнему в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать резервный вариант для этих неполной последовательности, но <xref:System.Text.Decoder> запомнит эти последовательности для следующего звонка.)  
  
-   Если приложение обрабатывает строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка кодируется в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> поскольку <xref:System.Text.Encoding> ожидает дискретных преобразования, хотя <xref:System.Text.Decoder> предназначен для нескольких этапов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольных двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать протокол, например uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, так как последовательности байтов может быть прервана, при обработке в пакетах. (Например, один может оказаться часть последовательности shift ISO-2022 <xref:System.Text.Encoding.GetChars%2A> вызова и по-прежнему в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать резервный вариант для этих неполной последовательности, но <xref:System.Text.Decoder> запомнит эти последовательности для следующего звонка.)  
  
-   Если приложение обрабатывает строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка кодируется в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов, которая начинается с заданного указателя байта, в набор символов, которые сохраняются, начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления массиве точный размер, который <xref:System.Text.Encoding.GetChars%2A> требуется для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> поскольку <xref:System.Text.Encoding> ожидает дискретных преобразования, хотя <xref:System.Text.Decoder> предназначен для нескольких этапов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольных двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать протокол, например uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, так как последовательности байтов может быть прервана, при обработке в пакетах. (Например, один может оказаться часть последовательности shift ISO-2022 <xref:System.Text.Encoding.GetChars%2A> вызова и по-прежнему в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать резервный вариант для этих неполной последовательности, но <xref:System.Text.Decoder> запомнит эти последовательности для следующего звонка.)  
  
-   Если приложение обрабатывает строки выходных данных, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.  
  
-или- 
 <paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > возвращает символы из входной последовательности байтов. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> поскольку <xref:System.Text.Encoding> ожидает дискретных преобразования, хотя <xref:System.Text.Decoder> предназначен для несколько проходов на один входящий поток.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** этот метод предназначен для работы с символами Юникода, а не на произвольных двоичных данных, таких как массивы байтов. Если вам нужно закодировать произвольные двоичные данные в текст, следует использовать протокол, например uuencode, который реализуется методами, такими как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Метод определяет, сколько символов привести декодировании последовательности байтов и <xref:System.Text.Encoding.GetChars%2A> метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Метод ожидает дискретных преобразований, отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> метод, который обрабатывает несколько проходов на один входящий поток.  
  
 Несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A> поддерживаются. Ниже приведены некоторые вопросы программирования для использования этих методов.  
  
-   Приложение может потребоваться декодировать множество входных байтов из кодовой страницы и обработать эти байты, с помощью нескольких вызовов. В этом случае, возможно, необходимо поддерживать состояние между вызовами, так как последовательности байтов может быть прервана, при обработке в пакетах. (Например, один может оказаться часть последовательности shift ISO-2022 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > вызова и по-прежнему в начале следующего [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > вызова. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > будет вызывать резервный вариант для этих неполной последовательности, но <xref:System.Text.Decoder> запомнит эти последовательности для следующего звонка.)  
  
-   Если приложение обрабатывает строки выходных данных, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Так как этот метод должен проверить длину строки и выделить буфер, это немного медленнее, но полученный в результате <xref:System.String> типа является предпочтительным.  
  
-   Версия байтов <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> позволяет некоторые быстрые способы, особенно при работе с несколькими вызовами в больших буферов. Имейте в виду, что эта версия метода небезопасна, так как указатели являются обязательными.  
  
-   Если приложение необходимо преобразовать большой объем данных, его следует использовать в выходной буфер. В этом случае [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > версии, что поддержка выходных символов буферы отлично подходит.  
  
-   Рассмотрите возможность использования <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> вместо метода <xref:System.Text.Encoding.GetCharCount%2A>. Метод преобразования преобразует можно столько данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока, этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример преобразует строку из одной кодировки в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере строка кодируется в массив байтов и затем Декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.  
  
-или- 
 <paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
-или- 
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает декодер, который преобразует последовательность байтов в последовательность символов.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий закодированную последовательность байтов в последовательность символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки байтов в последовательные блоки символов в так же, как <xref:System.Text.Encoding.GetChars%2A> метод этого класса. Тем не менее <xref:System.Text.Decoder> хранит сведения о состоянии между вызовами, что позволяет правильно декодировать последовательность байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет конечные байты в конце блоки данных и использует конечные байты при следующей операции декодирования. Таким образом <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных вместо поток полного набора данных.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию возвращает <see cref="T:System.Text.Decoder" /> , который вызывает <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> и <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> методы текущего объекта <see cref="T:System.Text.Encoding" />. Необходимо переопределить этот метод для возврата <see cref="T:System.Text.Decoder" /> , хранит свое состояние между вызовами.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает кодировщик, который преобразует последовательность символов Юникода в закодированную последовательность байтов.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в закодированную последовательность байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Метод преобразует последовательные блоки символов в последовательные блоки байтов в так же, как <xref:System.Text.Encoding.GetBytes%2A> метод этого класса. Тем не менее <xref:System.Text.Encoder> хранит сведения о состоянии между вызовами, что позволяет правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> Также сохраняет замыкающие символы в конце блоки данных и использует замыкающие символы при выполнении следующей операции кодирования. Например блок данных может заканчиваться непарные заместителем и сопоставления меньшим заменяющим значением может быть в следующем блоке данных. Таким образом <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операции с файлами, так как эти операции часто работают с блоками данных вместо поток полного набора данных.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию возвращает <see cref="T:System.Text.Encoder" /> , который вызывает <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> и <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> методы текущего объекта <see cref="T:System.Text.Encoding" />. Необходимо переопределить этот метод для возврата <see cref="T:System.Text.Encoder" /> , хранит свое состояние между вызовами.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает кодировку для указанной кодовой страницы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
-или- 
0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервному обработчику зависит тип кодировки `codepage`. Если `codepage` кода страницы или двухбайтовый символ кодировки (DBCS), используется стратегия наилучшего соответствия резервному обработчику. В противном случае используется резервному обработчику замены. Эти обработчики резервный может не подойти для вашего приложения. Чтобы указать резервному обработчику, используемые кодировку, заданную `codepage`, можно вызвать <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> перегрузки.  
  
 В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, изначально поддерживаемых .NET Core. В обоих реализациях .NET, можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод для получения массива <xref:System.Text.EncodingInfo> объектов, содержащий сведения о все доступные кодировки. 

 В дополнение к кодировки, скомпилированных в собственном коде, доступных в .NET Core или по своей природе, поддерживаются в версии конкретной платформы .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными благодаря регистрации <xref:System.Text.EncodingProvider> объекта. Если же кодировка был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последний зарегистрирован.  

Можно также указать значение 0 для `codepage` аргумент. Его точное поведение зависит от того, ли любой кодировки предоставляются путем регистрации <xref:System.Text.EncodingProvider> объекта:

- Если один или несколько поставщиков кодирования зарегистрировано, он возвращает кодировку последнего зарегистрированного поставщика, который выбрал вернуть кодировку при <xref:System.Text.Encoding.GetEncoding%2A> методу передается `codepage` аргумент 0.     

- На платформе .NET Framework, если кодировка не зарегистрирован поставщик, если <xref:System.Text.CodePagesEncodingProvider> — это зарегистрированный поставщик кодировки, или нет зарегистрированного поставщика кодирования `codepage` значение 0, он возвращает активную кодовую страницу операционной системы. Чтобы определить активную кодовую страницу в системах Windows, вызовите Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) функции из .NET Framework на рабочем столе Windows.

- В .NET Core, если не был зарегистрирован поставщик кодировки, или если нет зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращается <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Некоторые неподдерживаемые кодовых страниц, причина <xref:System.ArgumentException> исключение, тогда как другие приводят к <xref:System.NotSupportedException>. Таким образом, код должен перехватывать все исключения, приведенные в раздел "исключения".  
  
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приводит к повреждению данных. По этой причине активную кодовую страницу является кодовая страница ANSI, кодирования и декодирования данных, используя кодовую страницу по умолчанию возвращенные `Encoding.GetEncoding(0)` не рекомендуется. Для получения согласованных результатов следует использовать кодировку Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретной кодовой странице.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Конструкторы производных классов следует использовать для получения экземпляра с различными параметрами. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который позволяет включить обнаружение ошибок.  

   
  
## Examples  
 Следующий пример возвращает два экземпляра одной и той же кодировку (по одной кодовой страницей), а другой по имени и проверяют их равенство.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы.</summary>
        <returns>Кодировка, связанная с указанной кодовой страницей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервному обработчику зависит тип кодировки `name`. Если `name` кода страницы или двухбайтовый символ кодировки (DBCS), используется стратегия наилучшего соответствия резервному обработчику. В противном случае используется резервному обработчику замены. Эти обработчики резервный может не подойти для вашего приложения. Чтобы указать резервному обработчику, используемые кодировку, заданную `name`, можно вызвать <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> перегрузки.  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, изначально поддерживаемых .NET Core. В обоих реализациях .NET, можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод для получения массива <xref:System.Text.EncodingInfo> объектов, содержащий сведения о все доступные кодировки. 

 В дополнение к кодировки, скомпилированных в собственном коде, доступных в .NET Core или по своей природе, поддерживаются в версии конкретной платформы .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными благодаря регистрации <xref:System.Text.EncodingProvider> объекта. Если же кодировка был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последний зарегистрирован.  
   
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах, или можно изменить для одного компьютера, что приводит к повреждению данных. Для получения согласованных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Конструкторы производных классов следует использовать для получения экземпляра с различными параметрами. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который позволяет включить обнаружение ошибок.  
  
## Examples  
 Следующий пример возвращает два экземпляра одной и той же кодировку (по одной кодовой страницей), а другой по имени и проверяют их равенство.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> не является допустимым именем кодовой страницы.  
  
-или- 
Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
-или- 
0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Некоторые неподдерживаемую кодовую страниц вызывает исключение <xref:System.ArgumentException> исключение, тогда как другие приводят к <xref:System.NotSupportedException>. Таким образом, код должен перехватывать все исключения, приведенные в раздел "исключения".  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, изначально поддерживаемых .NET Core. В обоих реализациях .NET, можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод для получения массива <xref:System.Text.EncodingInfo> объектов, содержащий сведения о все доступные кодировки. 

 В дополнение к кодировки, скомпилированных в собственном коде, доступных в .NET Core или по своей природе, поддерживаются в версии конкретной платформы .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными благодаря регистрации <xref:System.Text.EncodingProvider> объекта. Если же кодировка был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последний зарегистрирован.  

Можно также указать значение 0 для `codepage` аргумент. Его точное поведение зависит от того, ли любой кодировки предоставляются путем регистрации <xref:System.Text.EncodingProvider> объекта:

- Если один или несколько поставщиков кодирования зарегистрировано, он возвращает кодировку последнего зарегистрированного поставщика, который выбрал вернуть кодировку при <xref:System.Text.Encoding.GetEncoding%2A> методу передается `codepage` аргумент 0.     

- На платформе .NET Framework, если кодировка не зарегистрирован поставщик, если <xref:System.Text.CodePagesEncodingProvider> — это зарегистрированный поставщик кодировки, или нет зарегистрированного поставщика кодирования `codepage` значение 0, он возвращает активную кодовую страницу.

- В .NET Core, если не был зарегистрирован поставщик кодировки, или если нет зарегистрированный поставщик кодировки обрабатывает `codepage` значение 0, возвращается <xref:System.Text.UTF8Encoding> кодирования.

> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приводит к повреждению данных. По этой причине активную кодовую страницу является кодовая страница ANSI, кодирования и декодирования данных, используя кодовую страницу по умолчанию возвращенные `Encoding.GetEncoding(0)` не рекомендуется. Для получения согласованных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, вместо конкретной кодовой странице. 
  
 Чтобы получить кодировку, связанную с активную кодовую страницу, можно указать значение 0 для `codepage` аргумент или, если код выполняется на платформе .NET Framework, на рабочем столе Windows, получения значения <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> свойство. Чтобы определить текущий активную кодовую страницу, вызовите Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) функции из .NET Framework на рабочем столе Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Конструкторы производных классов следует использовать для получения экземпляра с различными параметрами. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который позволяет включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод зависит от базовой платформы для поддержки большинства кодовых страниц. Тем не менее платформа .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, изначально поддерживаемых .NET Core. В обоих реализациях .NET, можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод для получения массива <xref:System.Text.EncodingInfo> объектов, содержащий сведения о все доступные кодировки. 

 В дополнение к кодировки, скомпилированных в собственном коде, доступных в .NET Core или по своей природе, поддерживаются в версии конкретной платформы .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными благодаря регистрации <xref:System.Text.EncodingProvider> объекта. Если же кодировка был зарегистрирован с помощью нескольких <xref:System.Text.EncodingProvider> объектов, этот метод возвращает последний зарегистрирован.  
  
> [!NOTE]
>  Кодовые страницы ANSI могут быть разными на разных компьютерах и можно изменить на одном компьютере, что приводит к повреждению данных. Для получения согласованных результатов следует использовать кодировку Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретной кодовой странице.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию. Конструкторы производных классов следует использовать для получения экземпляра с различными параметрами. Например <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, который позволяет включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> не является допустимым именем кодовой страницы.  
  
-или- 
Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив, содержащий все кодировки.</summary>
        <returns>Массив, содержащий все кодировки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает список поддерживаемых кодировок, однозначно определяются по кодовой странице. Таблица со списком поддерживаемых кодировок, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу.  
  
> [!NOTE]
>  Список поддерживаемых кодировок, возвращаемых <xref:System.Text.Encoding.GetEncodings%2A> метода не включает любые дополнительные кодировки, доступны по любому <xref:System.Text.EncodingProvider> реализаций, которые были зарегистрированы путем вызова <xref:System.Text.Encoding.RegisterProvider%2A> метод.  
  
 На платформе .NET Framework кодировки 50220 и 50222 будут связаны с именем «iso-2022-jp», но они не совпадают. Кодировка 50220 Преобразует знаки катаканы половинной ширины полноширинные символы катакана, тогда как кодирование 50222 использует последовательность shift in/shift out для кодирования символов катакана половинной ширины. Отображаемое имя для кодировки 50222 «японский (JIS-Povolen 1 bajt Kana - поэтому / SI)» чтобы отличить его от кодирования 50220, имеющая отображаемое имя «Японская (JIS)».  
  
 Если будет запрошено кодирования имя «iso-2022-jp», .NET Framework возвращает кодировку 50220. Тем не менее кодировку, которая подходит для вашего приложения зависит от предпочтительного способа обработки знаки катаканы половинной ширины.  
  
 Чтобы получить конкретную кодировку, следует использовать <xref:System.Text.Encoding.GetEncoding%2A> метод.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> Иногда используется для предоставления пользователю список кодировок в файле **Сохранить как** диалоговое окно. Однако множество кодировок Юникод, либо неполными и перевод много символов для «?», или иметь немного по-разному на разных платформах. Рекомендуется использовать значение по умолчанию UTF-8 или UTF-16.  
  
   
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество байтов, полученных при кодировании заданного количества символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount` Параметр фактически задает количество <xref:System.Char> объекты, представляющие символы Юникода для кодирования, так как .NET внутренним образом использует UTF-16 для представления символов Юникода. Следовательно, большинство символов Юникода может быть представлена одним <xref:System.Char> объект, но знак Юникода, представленный суррогатную пару, например, требуются две <xref:System.Char> объектов.  
  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetBytes%2A> для хранения полученных байтов, следует использовать <xref:System.Text.Encoding.GetByteCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. <xref:System.Text.Encoding.GetByteCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Получает номер худшего случая, включая худшем случае для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если вы выбрали переход на резервный ресурс со строкой потенциально большого объема, <xref:System.Text.Encoding.GetMaxByteCount%2A> извлекает большие значения, особенно в случаях, где худшем случае для кодирования, включает в себя Переключение режимов для каждого символа. Например это может происходить по ISO-2022-JP. Дополнительные сведения см. в записи блога "[в Encoding.GetMaxByteCount() и Encoding.GetMaxCharCount()?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 В большинстве случаев этот метод извлекает приемлемые значения для коротких строк. Для больших строк возможно, выбирать между использованием очень больших буферов и перехват ошибок в тех редких случаях, когда более рациональной буфер слишком мал. Можно также рассмотреть возможность использования другого подхода <xref:System.Text.Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 При использовании <xref:System.Text.Encoding.GetMaxByteCount%2A>, необходимо выделить в выходной буфер, в зависимости от максимального размера входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Encoding.Convert%2A> метод.  
  
 Обратите внимание, что <xref:System.Text.Encoding.GetMaxByteCount%2A> учитывает потенциальные оставшиеся суррогаты из предыдущей операции декодера. Из-за декодера передав значение 1 в метод извлекает 2 для однобайтовой кодировки, например ASCII. Следует использовать <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> свойства, если эта информация необходима.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно совпадает со значением `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать отсутствие исключений переполнения буфера, если буферы имеют размер в соответствии с результатами вычисления этот метод.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество символов, полученных при декодировании заданного количества байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для вычисления размера точное массива, необходимого <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать <xref:System.Text.Encoding.GetCharCount%2A> метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. <xref:System.Text.Encoding.GetCharCount%2A> Метод обычно позволяет выделения меньше памяти, хотя <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Получает номер худшего случая, включая худшем случае для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если вы выбрали переход на резервный ресурс со строкой потенциально большого объема, <xref:System.Text.Encoding.GetMaxCharCount%2A> извлекает большие значения.  
  
 В большинстве случаев этот метод извлекает адекватные числа для коротких строк. Для больших строк возможно, выбирать между использованием очень больших буферов и перехват ошибок в тех редких случаях, что более рациональной буфер слишком мал. Можно также рассмотреть возможность использования другого подхода <xref:System.Text.Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> не имеет отношения к <xref:System.Text.Encoding.GetBytes%2A>. Если требуется подобная функция, для использования с <xref:System.Text.Encoding.GetBytes%2A>, следует использовать <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 При использовании <xref:System.Text.Encoding.GetMaxCharCount%2A>, необходимо выделить в выходной буфер, в зависимости от максимального размера входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> метод.  
  
 Обратите внимание, что <xref:System.Text.Encoding.GetMaxCharCount%2A> рассматривает Наихудший случай оставшиеся байты в предыдущей операции кодировщика. Для большинства кодовых страниц передавая значение 0 в этот метод извлекает значения больше или равно 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно совпадает со значением `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 В следующем примере строка кодируется в массив байтов и затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать отсутствие исключений переполнения буфера, если буферы имеют размер в соответствии с результатами вычисления этот метод.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает последовательность байтов, задающую используемую кодировку.</summary>
        <returns>Массив байтов, в котором содержится последовательность байтов, задающая используемую кодировку.  
  
-или- 
Массив байтов нулевой длины, если преамбула не требуется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости <xref:System.Text.Encoding> предоставляет заголовок, который представляет собой массив байтов, которые может иметь префикс в последовательность байтов, полученных в результате кодирования. Если преамбула содержит метку порядка байтов (в формате Юникод, кодовая точка U + FEFF), он позволяет определить порядок байтов и формат преобразования или UTF декодеру.  
  
 Отметки порядка байтов (BOM) Юникода сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   UTF-8: EF BB BF  
  
-   UTF-16 обратный порядок байтов: FE FF  
  
-   Прямой порядок байтов UTF-16: FF FE  
  
-   UTF-32 обратный порядок байтов: 00 00 FE FF  
  
-   Прямой порядок байтов UTF-32: FF FE 00 00  
  
 Спецификации, следует использовать, поскольку она обеспечивает почти точную идентификацию кодировки для файлов, в противном случае теряют ссылку на <xref:System.Text.Encoding> объекта, например, тег или неправильно отмечен веб-данных или случайное текстовые файлы, сохраненные, когда организация не иметь расставленными или другие данные. Часто проблемы в работе пользователей избавить согласованных и правильных тегов в данных, желательно в UTF-8 или UTF-16.  
  
 Стандарты, которые предоставляют тип кодировки отчасти избыточна метки порядка БАЙТОВ. Тем не менее он может использоваться для помочь серверу отправлять правильный заголовок кодировки. Кроме того он может использоваться как переход на резервный ресурс в случае кодировку, в противном случае потери.  
  
 Есть некоторые недостатки использования метки порядка БАЙТОВ. Например сложно выбрать способы ограничения полей базы данных, используйте метки порядка БАЙТОВ. Объединение файлов может стать проблемой также, например, когда файлы будут объединены таким образом, что необязательный символ может оказаться в центре данных. Несмотря на некоторые недостатки тем не менее, использование спецификации настоятельно рекомендуется.  
  
 Дополнительные сведения о порядке байтов и отметки порядка байтов, см. в разделе стандарта Юникод на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Чтобы обеспечить правильное декодирование закодированных байтов, необходимо использовать перед закодированных байтов с начальной части. Однако большинство кодировок преамбула не предоставляется. Чтобы обеспечить правильное декодирование закодированных байтов, следует использовать кодировку Юникод, то есть <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, или <xref:System.Text.UTF32Encoding>, с начальной части.  
  
   
  
## Examples  
 В следующем примере определяется порядок байтов кодировки на основе преамбулы.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> метод производные производные класса.  
  
 См. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методы и рекомендации.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метод для какого-либо <xref:System.Text.Encoding> реализация зависит от резервной стратегии, определенным для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. в разделе «Выбор резервной стратегии» [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) раздела.  
  
   
  
## Examples  
 Следующий пример считывает строку в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объекта. Для файлов размером менее 2048 байтов, он считывает содержимое всего файла в массив байтов и вызовы <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> метод, чтобы выполнить декодирование. Для более крупных файлов, он считывает 2048 байтов за раз в массив байтов, вызовы <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить число символов, содержащихся в массиве, а затем вызывает <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы выполнить декодирование.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 В примере используется следующий текст, который следует сохранить в файл в кодировке UTF-8, с именем Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на массив байтов.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует указанное количество байтов начиная с указанного адреса в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Метод предназначен для оптимизации производительности, когда у вас есть собственный указатель в массив байтов. Вместо создания управляемого массива байтов и затем его вместо этого можно вызвать этот метод не требуется создавать все промежуточные объекты.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> метод производные производные класса.  
  
 См. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методы и рекомендации.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метод для какого-либо <xref:System.Text.Encoding> реализация зависит от резервной стратегии, определенным для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. в разделе «Выбор резервной стратегии» [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) раздела.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> является пустым указателем</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных слишком велико, что ему следует разделить на небольшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 См. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочном разделе для обсуждения декодирования методы и рекомендации.  
  
   
  
## Examples  
 Следующий пример считывает строку в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объекта. Для файлов размером менее 2048 байтов, он считывает содержимое всего файла в массив байтов и вызовы <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод, чтобы выполнить декодирование. Для более крупных файлов, он считывает 2048 байтов за раз в массив байтов, вызовы <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить число символов, содержащихся в массиве, а затем вызывает <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы выполнить декодирование.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 В примере используется следующий текст, который следует сохранить в файл в кодировке UTF-8, с именем Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами заголовка сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами заголовка сообщения почтового агента.  
  
-или- 
Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вам нужна кодировка для имени заголовка, необходимо вызвать <xref:System.Text.Encoding.GetEncoding%2A> метод с <xref:System.Text.Encoding.HeaderName%2A> свойство. Этот метод часто извлекает другую кодировку из тестовой кодировки, которой он вызывается. Обычно только почтовые приложения нужно получить такое кодирование.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойство соответствует международный стандарт, определяющий эту кодировку. Это не значит, что реализация соответствует в полном объеме с этого стандарта.  
  
 Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> возвращает имя, используемое для описания кодировку. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая может работать лучше для приложения электронной почты, например. Тем не менее не рекомендуется использовать свойство для задания кодировки.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но не выполняет сравнение на ее основе.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормированной.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием формы нормализации по умолчанию.</summary>
        <returns><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормирован; в противоположном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы нормализации по умолчанию является <xref:System.Text.NormalizationForm.FormC>, с использованием полной канонической декомпозиции, по возможности следует замена последовательностей их первичными составляющими.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form">Одно из значений <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>При переопределении в производном классе получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием заданной по умолчанию формы нормализации.</summary>
        <returns><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормализуется с использованием заданного значения <see cref="T:System.Text.NormalizationForm" />; в противоположном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы нормализации по умолчанию является <xref:System.Text.NormalizationForm.FormC>, с использованием полной канонической декомпозиции, по возможности следует замена последовательностей их первичными составляющими.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для отображения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для сохранения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для отображения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами электронной почты и новостей для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для сохранения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами почты и новостей для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, является ли текущая кодировка доступной только для чтения.</summary>
        <value>Значение <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> доступен только для чтения, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, используются ли в текущей кодировке однобайтовые кодовые точки.</summary>
        <value><see langword="true" />, если в текущем объекте <see cref="T:System.Text.Encoding" /> используются однобайтовые кодовые точки; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для однобайтовой кодировки, например, <xref:System.Text.ASCIIEncoding>, это свойство получает `true`.  
  
> [!CAUTION]
>  Следует соблюдать осторожность в назначение со значением для <xref:System.Text.Encoding.IsSingleByte%2A>. Предполагается, что как кодировки продолжится по-прежнему могут быть некорректными. Например, Windows-1252 имеет значение `true` для <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, но Encoding.GetMaxByteCount(1) возвращает 2. Это потому, что метод учитывает потенциальные оставшиеся суррогаты из предыдущей операции декодера.  
  
   
  
## Examples  
 В следующем примере проверяется значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Подкласс класса <see cref="T:System.Text.EncodingProvider" />, который предоставляет доступ к дополнительным кодировкам символов.</param>
        <summary>Регистрирует поставщик кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A> Метод позволяет зарегистрировать класс, производный от <xref:System.Text.EncodingProvider> что делает кодировки доступные на платформе, в противном случае их не поддерживает. Зарегистрированный поставщик кодировки, кодировки, которые он поддерживает можно получить путем вызова любого <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> перегрузки. При наличии нескольких поставщиков кодирования, <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> метод пытается извлечь с заданной кодировкой от каждого поставщика, начиная с наиболее недавно зарегистрированный.

Регистрация поставщика кодировки с помощью <xref:System.Text.Encoding.RegisterProvider%2A> метод также изменяет поведение [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) и [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) методы при передаче аргумента `0`:

- Если зарегистрированный поставщик <xref:System.Text.CodePagesEncodingProvider>, метод возвращает кодировку, соответствующую активную кодовую страницу системы при работе в операционной системе Windows.

- Пользовательский поставщик кодировки можно выбрать, какую кодировку, возвращаемое, если любой из этих <xref:System.Text.Encoding.GetEncoding%2A> перегрузок метода передается аргумент `0`. Поставщик можно также возвращает кодировку, задав <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> возвращаемого значения метода `null`. 
  
Начиная с .NET Framework 4.6, .NET Framework включает один поставщик кодировки, <xref:System.Text.CodePagesEncodingProvider>, это делает доступные кодировки, которые присутствуют в полной версии платформы .NET Framework, но не доступны в универсальной платформы Windows. По умолчанию универсальная платформа Windows поддерживает только кодировки Юникод, ASCII и кодовой страницы 28591.  
  
 Если один и тот же поставщик кодировки используется в нескольких вызовах <xref:System.Text.Encoding.RegisterProvider%2A> поставщик регистрирует метод, только первый вызов метода. Последующие вызовы учитываются.  
  
 Если <xref:System.Text.Encoding.RegisterProvider%2A> метод вызывается для регистрации нескольких поставщиков, которые обрабатывают ту же кодировку, последний зарегистрированный поставщик используется для всех операциях кодирования и декодирования. Все ранее зарегистрированных поставщиков учитываются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с прямым порядком байтов.</summary>
        <value>Кодировка для формата UTF-16 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о кодировках, поддерживаемых .NET и обсуждение какие Юникод, кодировка, используемая, см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Возвращаемый этим свойством объект может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать с вопросительным знаком ("?») символ. Вместо этого можно вызвать <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктора для создания обратным порядком байтов <xref:System.Text.UnicodeEncoding> которого резервный метод, либо объект <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-32 с прямым порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-32 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Возвращаемый этим свойством объект может иметь необходимого поведения для вашего приложения. Он использует резервную стратегию замены для каждой строки, он не может закодировать и каждый байт, он не может декодировать замените замещающий символ Юникода (U + FFFE). Вместо этого можно вызвать <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктора для создания <xref:System.Text.UTF32Encoding> которого резервный метод, либо объект <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Описание прямой порядок байтов, см. в разделе <xref:System.Text.Encoding> разделе, посвященном классу.  
  
 Сведения о кодировках, поддерживаемых .NET и обсуждение какие Юникод, кодировка, используемая, см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-7.</summary>
        <value>Кодировка для формата UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В основном в средах, которые Исторически ограниченные 7 разрядов, таких как NNTP и некоторые приложения электронной почты используется кодировка UTF-7. Из-за проблем с надежности и безопасности не следует использовать кодировку UTF7 в 8-разрядных сред где кодировку UTF-8 можно использовать вместо этого.  
  
   
  
## Examples  
 Следующий пример определяет число байтов, необходимых для кодирования массива символов и кодирует символы отображаются полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-8.</summary>
        <value>Кодировка для формата UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает <xref:System.Text.UTF8Encoding> объекта, кодирует (кодировки UTF-16) символов Юникода в последовательность байтов от одной до четырех на один знак, и который декодирует массива байтов в кодировке UTF-8, Юникод (кодировки UTF-16). Сведения о кодировках символов, поддерживаемых .NET и обсуждение какие Юникод, кодировка, используемая, см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Возвращаемый этим свойством объект может иметь необходимого поведения для вашего приложения.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, который предоставляет метку порядка байтов (BOM) Юникода. Для создания экземпляра, также UTF8 кодирование, которое не имеет метки порядка БАЙТОВ, вызвать любой перегрузки <xref:System.Text.UTF8Encoding.%23ctor%2A> конструктор.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, который использует резервную стратегию замены для замены каждой строки, он не может закодировать и каждый байт, он не может декодировать с вопросительным знаком ("?») символ. Вместо этого можно вызвать <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> конструктора для создания <xref:System.Text.UTF8Encoding> которого резервный метод, либо объект <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 В следующем примере определяется массив, состоящий из следующих символов:  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА Z (U + 007A)  
  
-   ЛАТИНИЦА МАЛОГО LETTER (U + 0061)  
  
-   ОБЪЕДИНЕНИЕ БРЕВЕ; (U + 0306)  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА AE С ОСТРОЙ (U + 01FD)  
  
-   БЕТА-ВЕРСИИ ГРЕЧЕСКУЮ БУКВУ (U + 03B2)  
  
-   Суррогатная пара (U + D800 U + DD54), являющийся GREEK ACROPHONIC ATTIC один ТЫСЯЧ STATERS (U + 10154).  
  
 Он отображает блоков кода UTF-16 для каждого символа и определяет количество байтов, необходимых кодировщиком UTF-8 для кодирования массива символов. Затем кодирует символы и отображается в кодировке UTF-8 байтов.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Основные сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает для текущей кодировки имя, зарегистрированное в IANA (Internet Assigned Numbers Authority).</summary>
        <value>Имя IANA для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> Свойства совпадает со значением <xref:System.Text.EncodingInfo.Name%2A> свойство.  
  
 Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> возвращает имя регистрации IANA для данной кодировки. Когда он имеет значение стандартное имя, кодировку реализация может не соответствовать в полном объеме для этого стандарта. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая лучше заголовки электронной почты. Однако большинство приложений следует использовать <xref:System.Text.Encoding.WebName%2A> вместо этого.  
  
 Дополнительные сведения о IANA см. в статье [www.iana.org](https://www.iana.org/).  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> Совпадает со значением <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> возвращаемый <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Некоторые веб-имена являются дубликатами; см. в разделе "Примечания" для <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> Дополнительные сведения.  
  
   
  
## Examples  
 В следующем примере <xref:System.Text.Encoding.WebName%2A> в заголовок HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки, имеющие одно или несколько имен, которые отличаются от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Он отображает <xref:System.Text.Encoding.EncodingName%2A> , но не выполняет сравнение на ее основе.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает кодовую страницу операционной системы Windows, наиболее точно соответствующую текущей кодировке.</summary>
        <value>Кодовая страница операционной системы Windows, наиболее точно соответствующая текущему объекту <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для обеспечения совместимости с Windows MultiLanguage (MLang) API, например, при определении семейств шрифтов. Для глобализации с помощью одного из кодировки Юникод рекомендуется вместо этого. Также рекомендуется использовать <xref:System.Text.Encoding.WebName%2A> вместо <xref:System.Text.Encoding.WindowsCodePage%2A> определить кодовую страницу.  
  
   
  
## Examples  
 В следующем примере определяется кодовой странице Windows, наиболее точно соответствующий каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>