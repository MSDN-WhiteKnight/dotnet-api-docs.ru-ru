<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa8f739063475b844ca1c37c795d7728c6ae75a7" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53390057" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет базовый класс производного пользовательского типа, отслеживающего изменения в состоянии данных, от которых зависит элемент кэша.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Класс используется как базовый класс для классов производном монитора, которые предназначены специально для реализации конкретного кэша. Объект <xref:System.Runtime.Caching.ChangeMonitor> экземпляр отслеживает изменения в состояние данных, который зависит от элемента кэша. Например элемент может быть сущностью данных или файлов, кэшируются, содержимое. При обновлении сущности данных или файлов необходимо также изменить связанную запись кэша. Общие элементы, которые могут контролироваться включают сущностей данных (например, поля базы данных, значения, строки или таблицы), другая запись кэша и файлы и атрибуты файла.  
  
 Изменение зависимости — изменение в состоянии зависимости. В обычной реализации кэша после <xref:System.Runtime.Caching.ChangeMonitor> экземпляр уведомляет о том, что изменилась зависимость кэша, кэш выполняет необходимое действие, например аннулирование вставленной записи кэша.  
  
 Производные <xref:System.Runtime.Caching.ChangeMonitor> классы могут быть настроены для наблюдения за изменениями зависимостей для конкретных различных хранилищ данных. Например существуют реализации кэша для файловой системы, физической памяти или базы данных. <xref:System.Runtime.Caching.ChangeMonitor> Класс проверяет изменения, происходящие вне кэша и оповещает кэша, которые произошли изменения.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Включает следующие классы, производные от <xref:System.Runtime.Caching.ChangeMonitor> класса:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Каждый из этих классов работает с различными типами зависимостей. Например, производном <xref:System.Runtime.Caching.FileChangeMonitor> класс отслеживает изменения в кэш для данных файловой системы (файлы и папки), который зависит от элемента кэша.  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides"><para>При создании пользовательской реализации кэша или производного типа, монитора изменений должно следовать определенным правилам. В следующем списке перечислены эти рекомендации. Дополнительные сведения см. в документации для отдельных методов или свойств.  
  
-Конструктор производного класса необходимо задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> свойство, начать мониторинг, а также вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод перед возвращением метода. Если конструктор обнаруживает ошибку во время конструкции, а также необходимо иметь для освобождения ресурсов, конструктор может вызывать только <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегружать после <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызывается метод, так как <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызовет перегрузку <see cref="T:System.InvalidOperationException" /> исключение, если инициализация не завершена.  
  
— Если внесения изменений в данных, который отслеживается до инициализации завершения, необходимо вызвать конструктор <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед вызовом <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод.  
  
-После производный <see cref="T:System.Runtime.Caching.ChangeMonitor" /> создается экземпляр типа, необходимо вставить в пользовательский монитор <see cref="T:System.Runtime.Caching.ObjectCache" /> реализации. Или если вы закончили с помощью монитора изменений, вызовите <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод.  
  
-После <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр вставляется в <see cref="T:System.Runtime.Caching.ObjectCache" /> реализации <see cref="T:System.Runtime.Caching.ObjectCache" /> экземпляра требуется, что монитор изменений будет удален. Даже в том случае, если курсор является недопустимым и приводит к возникновению исключения <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна вызывать <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки.  
  
-После вставки монитор производном изменений в кэше, <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, передавая <see cref="T:System.Runtime.Caching.OnChangedCallback" /> объекта. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Метод может вызываться только один раз. Если уже произошло изменение зависимостей, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляра будет немедленно вызван при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. В противном случае <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляра будет вызываться только один раз. Один раз вызов происходит либо при <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> вызывается метод, так как <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр обнаружено изменение, или когда <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод <see cref="T:System.Runtime.Caching.ChangeMonitor" />, что произойдет раньше.  
  
- <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Экземпляра, предоставляемый <see cref="T:System.Runtime.Caching.ObjectCache" /> реализации следует удалить связанную запись кэша и укажите причину, используя <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> перечисления.  
  
-A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра можно вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод либо перед реализацией кэша вызвал <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод или после. Если <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод был вызван перед <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> называется базой <see cref="T:System.Runtime.Caching.ChangeMonitor" /> реализации уведомит кэша, что это произошло и инициирует обратный вызов передается <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> немедленно в том случае, когда <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. Любые данные о состоянии, передается <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод сохраняется монитор изменений, а впоследствии передается <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается метод.  
  
— Монитор изменений необходимо реализовать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод. Дополнительные сведения см. в документации метода <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Перегрузку метода должен вызываться для удаления <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра. Далее приведены правила для вызова Dispose. 
-Перед вставкой элемента в кэше, он отвечает за вызывающий объект для удаления <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра.  
  
— Один раз для элемента кэша и <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляры, связанные с ним, передаются в кэш, средство реализации кэша необходимо убедиться в том, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, даже если вставка завершается ошибкой.  
  
-После элемента и связанный с ним <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляры передаются в кэш, вызывающий объект не должен удалить зависимость, так как при <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, вызов обрабатывается так, как если бы зависимость изменилась. В результате <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> автоматически вызывается метод.  
  
-Учетом этих правил, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод должен вызываться в одном из следующих способов: 
-Необходимо вызвать users <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузку метода, если они не вставки в кэш экземпляра производного монитора изменений.  
  
— Если реализация пытается вставить экземпляра монитора изменений в кэше объектов, но Вставка завершается неудачно, реализация кэша отвечает за вызов метода <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки. При попытке вставки приводит к исключению, реализация кэша необходимо уничтожить все связанные зависимости.  
  
— Если запись кэша удаляется, реализация кэша должна также удалить зависимости.  
  
-Внутренней реализации <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> автоматически вызывает метод <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод после он вызывает обратный вызов, который зарегистрирован при помощи <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Этот автоматический вызов к методу dispose, во время запуска событий возникает только при инициализации <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляр ранее был завершен.  
  
</para></block>  
  
 При вызове конструктора монитор производном изменений <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод, если состояние монитора изменений уже был изменен (то есть состояние, отслеживаемое уже измененные при конструктор был по-прежнему активен) то <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> будет метод автоматически удалите монитора изменений.  
  
- <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> Свойству <see langword="true" /> после <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> экземпляром производного монитора изменений, независимо от того, вызывается метод <see cref="T:System.Runtime.Caching.OnChangedCallback" /> он задан с помощью вызова <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод или нет.</para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">Кэширование ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Этот конструктор вызывается конструкторами в производных классах для инициализации базового класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Класс имеет конструктор по умолчанию. Тем не менее, наследуют от базового <xref:System.Runtime.Caching.ChangeMonitor> класса и определение пользовательского отслеживания изменений поведения, должны выполнять инициализацию в конструкторе. Дополнительные сведения см. примечания для разработчиков производных классов раздела.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Конструктор производного класса необходимо задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> свойство, начать мониторинг, а также вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> класса перед возвращением. При изменении зависимости до инициализации завершен (например, если ключ зависимые кэша не найден в кэше), необходимо вызвать конструктор <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед вызовом <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод. В этом случае можно вызвать конструктор <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только после того, как <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызывается метод, так как <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод вызывает исключение, если инициализация не завершена.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод используется для освобождения <xref:System.Runtime.Caching.ChangeMonitor> экземпляра и связанных ресурсов. Открытый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод вызывается для координации процесса реализации с событиями жизненного цикла ключа монитора изменений производных классов (например, инициализация), а также для освобождения <xref:System.Runtime.Caching.ChangeMonitor> экземпляра, чтобы экземпляр мог быть удален сборщиком мусора. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод реализуется классами производного монитора изменения для реализации своих управляемых и неуправляемых ресурсов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метода производного класса только один раз, при первом вызове. Последующие вызовы <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод не оказывают влияния. После вызова метода <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> свойству `true`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Перегрузка должна вызываться для удаления <xref:System.Runtime.Caching.ChangeMonitor> экземпляра. Ниже приведены правила для вызова метода dispose.  
  
-   Перед вставкой элемента в кэше, он отвечает за вызывающего избавиться от <xref:System.Runtime.Caching.ChangeMonitor> экземпляра.  
  
-   Один раз для элемента кэша и <xref:System.Runtime.Caching.ChangeMonitor> экземпляры, связанные с ним передаются в кэш, реализующий объект кэша, который необходимо убедиться в том, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывается, даже если вставка завершается ошибкой.  
  
-   После элемента и связанный с ним <xref:System.Runtime.Caching.ChangeMonitor> экземпляры передаются в кэш, вызывающий объект не должен удалить зависимость, так как при <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывается метод, вызов обрабатывается так, как если бы зависимость изменилась. В результате <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> автоматически вызывается метод.  
  
-   Учитывая эти правила, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод должен вызываться в одном из следующих способов:  
  
    -   Пользователям необходимо вызвать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> перегрузку метода, если они не вставки в кэш экземпляра производного монитора изменений.  
  
    -   Реализация кэша отвечает за вызов метода <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> перегружать, если реализация пытается вставить экземпляра монитора изменений в кэше объектов, но Вставка завершается неудачно. При попытке вставки приводит к исключению, реализация кэша должна освободить все связанные зависимости.  
  
    -   Если запись кэша удаляется, реализация кэша должна также удалить зависимость.  
  
 Внутренняя реализация <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> автоматически вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод после он вызывает обратный вызов, который зарегистрирован при помощи <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод.  
  
> [!NOTE]
>  Это автоматическое dispose, во время запуска событий возникает только при инициализации <xref:System.Runtime.Caching.ChangeMonitor> экземпляра содержанием.  
  
 При вызове конструктора монитор производном изменений <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метод, если состояние монитора изменений уже был изменен (то есть состояние, которое отслеживается уже изменен при конструктор был по-прежнему активен) затем <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> будет метод автоматически dispose монитора изменений.  
  
> [!NOTE]
>  Пользователям не следует вызывать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод. Тем не менее нельзя запретить пользователям в результате вызова метода. Таким образом, если это так, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод. В этом случае записи кэша уведомляется, как если бы зависимость изменилась.  
  
 Чтобы предотвратить переопределение производных классов <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод, метод не является явной реализацией интерфейса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Инициализация не завершена в производном классе монитора изменений, который вызвал базовый метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" />, чтобы освободить управляемые и неуправляемые ресурсы и любые ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />; значение <see langword="false" />, чтобы освободить только неуправляемые ресурсы. Если передается значение <see langword="false" />, метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> вызывается потоком <see langword="finalizer" />, а любые внешние управляемые ссылки в большинстве случаев становятся недействительными, так как они уже были очищены сборщиком мусора.</param>
        <summary>Освобождает все управляемые и неуправляемые ресурсы и все ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Эту перегрузку необходимо реализовывать в производных классах, контролирующих изменения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `disposing` значение `true`, удаляются все управляемые и неуправляемые ресурсы, а все ссылки на этот объект освобождается таким образом, чтобы экземпляр производного монитора изменений может быть удален сборщиком мусора. Гарантируется, что базовый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод будет вызывать реализованный интерфейс <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод только один раз.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Монитор изменений необходимо реализовать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> перегрузки, чтобы освободить все управляемые и неуправляемые ресурсы при значение <paramref name="disposing" /> является <see langword="true" />. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Перегрузки метода, который имеет <paramref name="disposing" /> значение <see langword="true" /> вызывается только один раз, а именно, при удалении экземпляра в первый раз. Монитор изменений не должны вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> непосредственно перегрузить. Монитор производном изменений можно вызвать открытый без параметров <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод в базовом <see cref="T:System.Runtime.Caching.ChangeMonitor" /> класса.  
  
Кроме того монитор изменений можно реализовать в методе завершения. В этом случае можно вызвать метод завершения <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод и передать его <paramref name="disposing" /> значение <see langword="false" />. Тем не менее это обычно не требуется. Мониторинг изменений зависимостей обычно выполняется службой, которая содержит ссылку на экземпляр монитора изменений. Ссылка не позволяет экземпляру сборщику мусора и таким образом делает метод завершения ненужные. Чтобы избежать утечки памяти, при изменении зависимости, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод удаляет экземпляр монитора изменений (если инициализация не завершена).</para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что состояние, отслеживаемое классом <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось.</summary>
        <value>Значение <see langword="true" />, если состояние отслеживаемое экземпляром <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно проверить значение этого свойства в производном <xref:System.Runtime.Caching.ChangeMonitor> класса, чтобы увидеть, был ли изменен зависимость.  
  
 Значение присваивается `true` при изменении зависимостей (то есть, в том случае, когда <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод). После <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> был вызван для производного класса, значение <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство будет иметь `true`, независимо от того, следует ли <xref:System.Runtime.Caching.OnChangedCallback> экземпляр получил уведомление с помощью вызова <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод.  
  
> [!NOTE]
>  Чтобы узнать, вызывающие объекты <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство, чтобы увидеть, был ли изменен зависимость. Тем не менее, в среде с несколькими потоками проще и более простым в обслуживании подход — вставить данные в реализации кэша без проверки <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство. Реализации кэша необходимо проверить <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство для вас и не должно выполнения инструкции insert или операция задания, если один или несколько связанных зависимостей уже были изменены.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструктора производных классов и указывает на завершение инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если зависимость изменится до завершения установки в производном классе, необходимо вызвать конструктор производного класса <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод.  
  
 Когда <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод, <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойству автоматически присваивается `true` по монитора изменений. Таким образом, когда монитор изменений конструктор вызывает метод <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метод, автоматически вызывает базовый класс <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод. При завершении инициализации, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод автоматически удаляет экземпляр производного монитора изменений.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Конструктор производного класса необходимо вызвать базовый <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метода до завершения работы конструктор возвращает. Конструктор производного класса может вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только после того, как <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызывается, поскольку <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод вызывает исключение, если инициализация не завершена.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что производный экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" /> удален.</summary>
        <value>Значение <see langword="true" />, если экземпляр удален; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство имеет значение `true` после базовый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызовы методов <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод в производном классе, чтобы удалять его.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Ссылка на метод, вызываемый при изменении зависимости.</param>
        <summary>Вызывается средствами реализации кэша для регистрации обратного вызова и уведомления экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" /> об изменении зависимости с использованием делегата <see cref="T:System.Runtime.Caching.OnChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации кэша используйте этот метод для привязки к монитору изменений. Если можно связать одно или несколько мониторов изменений с элемента кэша, то можно передать <xref:System.Runtime.Caching.CacheItemPolicy> экземпляр с заполненным свойством мониторов изменений для элемента кэша. Реализация кэша мониторов изменений поддерживает отвечает за перебор <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> свойство и регистрация <xref:System.Runtime.Caching.OnChangedCallback> делегатов с каждым изменить монитор, которые будут найдены.  
  
 Так как <xref:System.Runtime.Caching.OnChangedCallback> делегат включает необязательный параметр состояния, конкретная реализация монитора изменений можно передать необязательные сведения о состоянии. Реализация кэша определяет, следует ли выполнить явную зависимость от типа состояния, который передает монитор пользовательских изменений как часть обратного вызова.  
  
> [!NOTE]
>  API расширяемости базовый кэша не имеет требования явных зависимостей типа состояния.  
  
 Реализация <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод автоматически определяет ли состояние монитора уже изменен во время <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> вызывается метод. Если <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство `true`, а затем автоматически вызывает метод <xref:System.Runtime.Caching.OnChangedCallback> обработчик событий, который был зарегистрирован, с помощью <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод. Это происходит, так как это возможно, что с момента реализация кэша создает монитор изменений, реализация кэша возвращает монитор и связывает сам до, времени базовой отслеживаемых состояние изменилось. Если уже изменения состояния выберите объект, который передается <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод `null`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Метод может вызываться только один раз и приведет к возникновению исключения при последующих вызовах.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод обратного вызова уже вызван.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="onChangedCallback" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>1.  Необходимо вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод, чтобы получать уведомления о любых изменениях зависимостей. Если уже произошло изменение зависимостей, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляра будет выполнен при вызове <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызывается. В противном случае <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляра вызывается один раз либо если <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> был вызван или когда <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывается метод, что произойдет раньше. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Экземпляра, предоставляемых реализацией кэша следует удалить запись кэша и при их запросе вызывающим кэша, вызывать важное изменение или событие обновления обратно в исходный вызывающий объект кэша.  
  
2.  Реализация кэша объектов необходимо удалить запись кэша, связанный с изменением зависимостей.</para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Данные для события изменения. Это значение может быть равно <see langword="null" />.</param>
        <summary>Вызывается производными классами для создания события при изменении зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается при изменении зависимости. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Удаления экземпляра монитора изменений, однако реализации происходит только в том случае, если функция обратного вызова уже не был вызван также вызывается метод.  
  
 Если <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод был вызван перед <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метод вызывается, данные о состоянии из вызова <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод сохраняется реализацией кэша. Кроме того, обратный вызов, который <xref:System.Runtime.Caching.OnChangedCallback> метод вызывается сразу же при <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Идентификатор экземпляра монитора изменений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Значение свойства обычно состоит из зависимостей имен строковых данных, уникальным образом идентификаторов данных, который находится под наблюдением <xref:System.Runtime.Caching.ChangeMonitor> экземпляра. Значение <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> свойство содержит строку. Значение строки используется для назначения уникальный идентификатор <xref:System.Runtime.Caching.ChangeMonitor> экземпляра.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Переопределяя свойство, можно определить индивидуальную реализацию для строковое значение свойства, чтобы назначить его уникальный идентификатор.</para></block>
        <block subset="none" type="overrides"><para>В производных классах необходимо задать значение свойства в конструкторе.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>