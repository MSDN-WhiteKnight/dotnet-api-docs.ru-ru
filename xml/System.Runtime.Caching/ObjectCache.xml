<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="59fa32fc7e57fc1209e20ba0f2ff6e59a2225a77" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55349870" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет кэш объекта и предоставляет базовые методы и свойства для осуществления доступа к кэшу объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Тип является типом первичного кэша объектов в памяти. Чтобы разработать пользовательскую реализацию кэша, вы наследуете от <xref:System.Runtime.Caching.ObjectCache> класса.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.ObjectCache> Класс впервые появился начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Встроенная <xref:System.Runtime.Caching.MemoryCache> класс является производным от <xref:System.Runtime.Caching.ObjectCache> класса. <xref:System.Runtime.Caching.MemoryCache> Класс является реализацией кэша только конкретный объект в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] , производный от <xref:System.Runtime.Caching.ObjectCache> класса.  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides"><para>Так как <see cref="T:System.Runtime.Caching.ObjectCache" /> тип представляет только общие функции кэша, не требуется для как <see cref="T:System.Runtime.Caching.ObjectCache" /> необходимо создать экземпляр и получить экземпляр. Кроме того, нет необходимости, конкретные реализации <see cref="T:System.Runtime.Caching.ObjectCache" /> класс должен быть одноэлементных экземпляров.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> не является одноэлементным множеством, но необходимо создать только в одном несколько или потенциально только <see cref="T:System.Runtime.Caching.MemoryCache" /> экземпляра и код, который кэширует элементы следует использовать эти экземпляры.  
  
</para></block>  
  
 При наследовании от <see cref="T:System.Runtime.Caching.ObjectCache" /> класса, необходимо переопределить его методы.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш без обязательного возврата существующей записи кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода попробуйте вставить запись в кэш, без перезаписи или удаления существующей записи кэша, имеющий тот же ключ. Запись кэша может быть типизированным <xref:System.Runtime.Caching.CacheItem> или универсальный объект.  
  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Перегрузок метода и <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузок метода имеют одно существенное различие. Когда эти методы вставляют запись кэша, если соответствующая запись находится в кэше, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки метода возвращают существующая запись кэша, но <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузок метода — нет. Наличие этих разных перегрузок метода позволяет вызывающим объектам оптимизировать свой код, в зависимости от того, требуется ли существующая запись кэша. В распределенных кэшах, возвращает существующее значение с помощью <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> возможно дороже, чем возвращает логическое значение, используя метод <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе пытается вставить запись в кэш как экземпляр <see cref="T:System.Runtime.Caching.CacheItem" /> и добавляет сведения о том, как следует удалить эту запись.</summary>
        <returns>Значение <see langword="true" />, если вставка выполнена успешно, или <see langword="false" />, если в кэше уже имеется запись с таким же ключом, как у <paramref name="item" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша. Этот параметр обязательно указывается при вызове метода <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе используется для вставки записи в кэш, без перезаписи существующей в кэше записи.</summary>
        <returns>Значение <see langword="true" />, если вставка выполнена успешно, или <see langword="false" />, если в кэше уже имеется запись с таким же ключом, как у <paramref name="key" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о способе удаления записи.</summary>
        <returns>Значение <see langword="true" />, если вставка производится успешно, или <see langword="false" />, если в кэше уже есть запись с таким же ключом, как у <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузок метода являются виртуальными (а не в абстрактных) на <xref:System.Runtime.Caching.ObjectCache> класса, так как <xref:System.Runtime.Caching.ObjectCache.Add%2A> внутренне вызывает метод <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Это уменьшает количество перегрузок метода, которые должна предоставить реализация кэша. Реализация кэша не требуется специальное поведение при <xref:System.Runtime.Caching.ObjectCache.Add%2A> метод, он может просто реализовать <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузок метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе пытается вставить запись в кэш и возвращает существующую запись кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Перегрузок метода вставить запись в кэш. Если запись кэша с соответствующим ключом уже существует, они возвращают существующую запись. Запись кэша может быть <xref:System.Runtime.Caching.CacheItem> или универсальный объект.  
  
 Есть одно различие между <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки и <xref:System.Runtime.Caching.ObjectCache.Add%2A> перегрузки. Эти перегруженные методы попытке вставить запись, при обнаружении существующей записи, что ключ, сопоставляющий существующего вставил запись кэша, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки возвращают существующая запись кэша. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузки — нет.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет заданный объект <see cref="T:System.Runtime.Caching.CacheItem" /> в кэш и задает сведения о способе удаления записи.</summary>
        <returns>Если существует запись кэша с таким же ключом, указанная запись кэша; в противном случае — значение <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, используя ключ, объект для записи кэша, абсолютное значение срока действия и (необязательно) область кэша для добавления.</summary>
        <returns>Заданное значение записи кэша, если существует запись кэша с таким же ключом; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> перегруженный метод не возвращает значение объекта, <xref:System.Runtime.Caching.CacheItem> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, задавая ключ и значение для записи кэша и сведения о способе удаления этой записи.</summary>
        <returns>Заданное значение записи кэша, если существует запись кэша с таким же ключом; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Метод возвращает значение объекта, не <xref:System.Runtime.Caching.CacheItem> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которой может быть найден кэш, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе проверяет, существует ли такая запись в кэше.</summary>
        <returns>Значение <see langword="true" />, если в кэше содержится запись с таким же ключом, как <paramref name="key" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Уникальные идентификаторы записей кэша, которые необходимо отслеживать.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которой могут существовать ключи кэша в параметре <paramref name="keys" />, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе создает объект <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />, который может активировать события в ответ на изменения указанных записей кэша.</summary>
        <returns>Монитор изменений, следящий за записями в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда производный <xref:System.Runtime.Caching.ObjectCache> класс переопределяет базовый <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> необходимо создать метод, реализация кэша <xref:System.Runtime.Caching.CacheEntryChangeMonitor> объекта. Этот монитор специализированные изменений извещает вызывающие операторы о при внесении изменений в записи кэша, которые указаны в `keys` параметра. Например, если Отслеживаемый объект в `keys` параметра обновляется или удаляется из кэша, монитор изменений, созданные с помощью данного метода инициирует событие.  
  
 Если реализация кэша поддерживает именованные области кэша, как можно указать строковое значение `regionName` параметра. В противном случае — значение по умолчанию `null`.  
  
> [!NOTE]
>  Не все реализации кэша поддерживают мониторы изменений записей кэша. Чтобы определить, поддерживает ли собственную реализацию кэша <xref:System.Runtime.Caching.CacheEntryChangeMonitor> объектов, см. в документации для реализации конкретного кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание функций, предоставляемых реализацией кэша.</summary>
        <value>Битовое сочетание флагов, которое указывает возможности реализации кэша по умолчанию.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает из кэша указанную запись кэша в виде объекта.</summary>
        <returns>Запись кэша, определяемая ключом <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую был добавлен кэш, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию равняется <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает из кэша указанную запись кэша в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Запись кэша, определяемая ключом <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода существует, так как некоторые реализации кэша может увеличить <xref:System.Runtime.Caching.CacheItem> класса. В этом случае <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> перегруженный метод не обязательно возвращает все сведения о кэшированных данных. Тем не менее <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> перегрузка метода позволяет пользовательских реализаций кэша вернуть больше, чем просто значение кэша.  
  
 <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Метод аналогичен <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> метода, за исключением случаев, <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> метод возвращает записи кэша как <xref:System.Runtime.Caching.CacheItem> экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный параметр. Именованная область кэша, для которой необходимо вычислить количество записей кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает общее число записей в кэше.</summary>
        <returns>Число записей в кэше. Если значение <paramref name="regionName" /> не равно <see langword="null" />, это число обозначает количество записей в указанной области кэша.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает перечислитель, который может использоваться для перебора записей кэша в коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к записям кэша в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации кэша можно переопределить и расширить этот метод для предоставления пользовательских средств итерации по коллекции записей кэша.  
  
> [!NOTE]
>  Возврат перечислителя обычно является операцией дороже, чем возврат всей записи кэша.  
  
 Этот метод вызывается явные реализации интерфейса, <xref:System.Runtime.Caching.ObjectCache> класс имеет для <xref:System.Collections.IEnumerable.GetEnumerator%2A> и <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> методы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает набор записей кэша.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую были добавлены одна или несколько записей кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает набор записей кэша, соответствующих указанным ключам.</summary>
        <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> Перегрузка метода является оптимизация производительности для распределенных кэшей, которые поддерживают получение нескольких записей кэша из кэша во время вызова одной сети.  
  
 Несмотря на то, что вызывающий объект можно передать один или несколько ключей, в метод, нет никакой гарантии, что все ключи представляют записей в кэше. Таким образом возвращенном словаре может содержать меньше элементов, чем количество ключей, которые были переданы в метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую были добавлены одна или несколько записей кэша, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию равняется <see langword="null" />.</param>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
        <summary>Получает набор записей кэша, соответствующих указанным ключам.</summary>
        <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> Перегрузку метода аналогичен <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузку метода, но позволяет передать именованной области с помощью синтаксиса необязательный параметр, поддерживаемый управляемых языков вроде C#.  
  
 Этот метод является виртуальным методом, так как <xref:System.Runtime.Caching.ObjectCache> класс предоставляет реализацию по умолчанию, который передает `params` массив <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на управляемую среду размещения, доступную реализациям <see cref="T:System.Runtime.Caching.ObjectCache" /> и способную предоставить определенные узлом службы реализациям <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Ссылка на управляемую среду размещения, содержащую средства выявления кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Host%2A> Свойство предназначено для использования с [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] размещаются сред и реализациями кэша, которые реализуют поведение, которое зависит от платформы .NET Framework среды.  
  
 В следующей таблице перечислены набор служб среды узла, могут быть доступны в управляемой среде размещения, и, что <xref:System.Runtime.Caching.ObjectCache> реализации посредством <xref:System.Runtime.Caching.ObjectCache.Host%2A> свойство:  
  
|Служба|Описание|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Позволяет предоставлять идентификаторы доменов приложений, которые могут понадобиться реализацией кэша для функции, такие как идентификация счетчиков производительности среды размещения.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Позволяет предоставить пользовательские изменения файла система уведомлений, вместо использования, указанному в средах размещения [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Позволяет реализации кэша отчета потреблении памяти кэша хост-среды. Это позволяет централизованно управлять потреблением памяти через несколько реализаций кэша средам размещения.|  
  
> [!NOTE]
>  Вызывающие объекты, значения этого свойства требуется неограниченные разрешения безопасности доступа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присваиваемое свойству, равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка присвоить значение свойству более одного раза.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">для полного доверия для всех методов доступа этого свойства. Это свойство не может использоваться частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что запись кэша не имеет абсолютного срока действия.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запись кэша, который вставляется в кэш с <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> значение поля задайте как никогда не истечет срок действия на основе абсолютный точки во времени. Тем не менее запись кэша с помощью этого параметра может быть удалена из кэша по другим причинам, который определяется конкретной реализацией кэша, таких как вытеснение события монитора изменений, из-за нехватки памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша в кэше.</param>
        <summary>Получает или задает индексатор по умолчанию для класса <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Ключ, служащий индексатором для экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод доступа set этого свойства действует аналогично <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> метод. На внутреннем уровне реализация кэша может задать абсолютный срок действия указанного значения для <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> метод. Тем не менее это поведение является в конечном счете зависит от реализации кэша.  
  
 Поведение метода доступа get, например вызов <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> и использованием `null` регионов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя конкретного экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Имя конкретного экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые реализации кэша может поддерживать несколько экземпляров кэша, на котором выполняется в одном приложении. Это свойство позволяет кэшу получить имя для идентификации конкретного экземпляра кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что запись кэша не имеет скользящего срока действия.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Срок действия, основанный на длительность или определенный интервал времени, также называется скользящий срок действия. Как правило это реализация кэша, которая исключает элементы, которые основаны на скользящий срок действия будет удалить элемент, не осуществлялся в указанном окне времени.  
  
 Запись кэша, который вставляется в кэш с <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> поле значение, заданное как значение срока действия никогда не должна быть удалена из-за отсутствия активности в скользящего временного окна. Тем не менее элемент кэша может быть исключен, если у него есть абсолютный срок действия или в случае возникновения любого другого события, подвергшиеся удалению в связи, такие изменения монитора или нехватка памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе удаляет запись из кэша.</summary>
        <returns>Объект, представляющий значение удаленной записи кэша, заданной данным ключом, или значение <see langword="null" />, если заданная запись не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы Переопределите этот метод в пользовательскую реализацию кэша, если имеется запись кэша в кэше, соответствующий `key`, должно возвращаться значение удаленного элемента. Если ничего не был удален из кэша, метод должен вернуть `null`.  
  
> [!NOTE]
>  Некоторые реализации распределенный кэш не могут поддерживать возможность возвращать значение, которое было удалено из кэша. Возможно, реализация кэша поддерживает возвращение значения удаленного элемента кэша. Также возможно маршалинг объекта в качестве возвращаемого значения слишком дорого. В таких случаях реализации кэша могут возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно поведение <xref:System.Runtime.Caching.ObjectCache.Set%2A> перегрузки методов представляет собой операцию вставки или обновления. Запись является либо вставляется как новая запись, если указанная запись не существует, или записи кэша обновляется новым значением, если он уже существует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый элемент кэша.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem" /> и задает сведения о способе удаления записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ для `item` не существует, `item` вставляется в качестве новой записи кэша. Если элемент с ключом, соответствующим `item` существует, значение из `item` позволяет обновить или заменить значение существующей записи кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о сроке действия на основе диапазона времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент, соответствующий `key` не существует в кэше, `value` и `key` используются для вставки в виде новой записи кэша. Если элемент с ключом, соответствующим `item` существует, обновляется или путем перезаписи с помощью записи кэша `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегруженная версия метода позволяет предоставлять больше информации удаления или истечения срока действия, чем те, которые доступны в абсолютный срок действия на основе времени.  
  
 Если элемент, соответствующий `key` не существует в кэше, `value` и `key` используются для вставки в виде новой записи кэша. Если элемент с ключом, соответствующим `item` существует, обновляется или путем перезаписи с помощью записи кэша `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Поддерживает перебор по строго типизированной коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к записям кэша в кэше.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Поддерживает выполнение итерации по универсальной коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к элементам кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только в том случае, если производный <xref:System.Runtime.Caching.ObjectCache> экземпляр приводится к <xref:System.Collections.IEnumerable> интерфейс.  
  
 Разработчики могут использовать этот метод для выполнения итерации по универсальной коллекции записей кэша.  
  
 Это значение по умолчанию <xref:System.Collections.IEnumerable.GetEnumerator%2A> реализация, которая вызывает <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>