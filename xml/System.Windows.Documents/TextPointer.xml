<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ef1fa4261a591f0ee0dbabc844bc1a0c4f26492" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227755" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет положение в <see cref="T:System.Windows.Documents.FlowDocument" /> или <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> Класс представлены следующие термины:  
  
-   Поместите - по своей природе, <xref:System.Windows.Documents.TextPointer> всегда указывает *позиции* в содержимом.  Подобные положения находятся либо между символами в содержимом или потока содержимого, что элемент теги, которые определяют структуру для содержимого.  
  
-   Текущее положение — поскольку <xref:System.Windows.Documents.TextPointer> всегда указывает на позицию и так как многие операции, которые могут выполняться с помощью <xref:System.Windows.Documents.TextPointer> относительны позиции, в настоящее время, на которые указывают <xref:System.Windows.Documents.TextPointer>, смысл просто см. положение, определяемое <xref:System.Windows.Documents.TextPointer> как *текущей позиции*.  
  
-   Позиция вставки — *позицию вставки* является позицией, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки — где угодно в содержимом, где можно расположить курсор.  Пример допустимого <xref:System.Windows.Documents.TextPointer> , не является положением вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающий тег выше и открывающий тег следующего абзаца).  
  
-   Символ - в рамках <xref:System.Windows.Documents.TextPointer> операции, включающие символы, следующие считается *символ*:  
  
    -   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
    -   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
    -   Каждый 16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
-   Контейнер текста - A *контейнера текста* элемент, который образует конечную границу для имеющегося содержимого потока; в позиции, указанной проверкой <xref:System.Windows.Documents.TextPointer> всегда попадает в текстовом контейнере.  В настоящее время текстовый контейнер должен быть либо <xref:System.Windows.Documents.FlowDocument> или <xref:System.Windows.Controls.TextBlock>.  В целом, операции между <xref:System.Windows.Documents.TextPointer> экземпляров в разных текстовых контейнеров не поддерживаются.  
  
-   Документ - содержимое в текстовом контейнере называется *документа*, как в <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> метод и <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> и <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> свойства.  
  
 <xref:System.Windows.Documents.TextPointer> Класс предназначен для упрощения обхода и обработки содержимого, представленного [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] элементы растягиваемого содержимого; как правило, такие элементы являются производными от <xref:System.Windows.Documents.TextElement>.  Некоторые операции, <xref:System.Windows.Documents.TextPointer> облегчает включают следующее:  
  
-   Выполняют порядковое сравнение текущей позиции со второй указанной позиции.  См. в разделе <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод.  
  
-   Определите тип содержимого, примыкающего к текущей позиции в указанном направлении.  См. в разделе <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод и <xref:System.Windows.Documents.TextPointerContext> перечисления.  
  
-   Получить <xref:System.Windows.Documents.TextElement> , определяющий область или Примыкает к текущей позиции.  См. в разделе <xref:System.Windows.Documents.Paragraph> и <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> метод.  
  
-   Получение контейнера текста, определяющий область текущего документа.  См. свойство <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Получите указанное количество символов перед или после текущей позиции.  См. в разделе <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод.  
  
-   Вставьте строку символов в текущей позиции.  См. в разделе <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> метод.  
  
-   Поиск границ строки в содержимом.  См. в разделе <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> метод и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> свойство.  
  
-   Преобразование между <xref:System.Windows.Documents.TextPointer> позиции и знака смещения в содержимое.  См. в разделе <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> методы.  
  
-   Проверка visual нажатия путем преобразования между <xref:System.Windows.Documents.TextPointer> позиции и <xref:System.Windows.Point> представляющий относительные координаты.  
  
-   Поиск ближайшего положения вставки и проверьте, является ли текущее положение является положением вставки.  См. в разделе <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> и <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> методы и <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> свойство.  
  
 Положение и <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> обозначается <xref:System.Windows.Documents.TextPointer> объекта являются неизменяемыми.  Если редактируется или изменения позиции, указанной проверкой содержимого <xref:System.Windows.Documents.TextPointer> остается неизменным по отношению к окружающим его текстом; скорее смещение, с самого начала содержимого соответствующим образом корректируется, чтобы отразить новое относительное положение в содержимое.  Например <xref:System.Windows.Documents.TextPointer> , указывающий положение в начале данного абзаца продолжает указывать на начало данного абзаца, даже в том случае, если содержимое вставляется или удаляется до или после абзаца.  
  
 <xref:System.Windows.Documents.TextPointer> Класс не предоставляет все открытые конструкторы.  Экземпляр <xref:System.Windows.Documents.TextPointer> создается с помощью свойств или методов других объектов (включая другие <xref:System.Windows.Documents.TextPointer> объекты). В следующем списке приведены несколько примеров методов и свойств, которые создают и возвращают <xref:System.Windows.Documents.TextPointer>.  Этот список не является исчерпывающим.  
  
-   Из <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> и <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Из <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, и <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Из <xref:System.Windows.Controls.TextBlock> (текстового контейнера): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, и <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Из <xref:System.Windows.Documents.FlowDocument> (текстового контейнера): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, и <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Из существующего <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Windows.Documents.TextPointer> для поиска положения только внутри первого <xref:System.Windows.Documents.Run> элемента в контейнере заданным текстом.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 В следующем примере реализуется алгоритм упрощенный поиск с помощью <xref:System.Windows.Documents.TextPointer> средства.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Выполнение порядкового сравнения между положениями, указанными текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>-1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует <paramref name="position" />; 0 если расположения те же; +1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение -1 указывает, что указанное положение в текущем <xref:System.Windows.Documents.TextPointer> предшествует позиции, заданной параметром `position`.  Значение 0 указывает, что указанные положения равны.  Значение положительное + 1 указывает, что указанное положение в текущем <xref:System.Windows.Documents.TextPointer> следует за позицией, заданной параметром `position`.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода.  В примере <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод используется в сочетании с <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextElement> пуст.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число символов, подлежащих удалению, начиная с текущего положения. Укажите положительное значение, чтобы удалить символы, следующие за текущим положением; укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению.</param>
        <summary>Удаление указанного числа символов, начиная с положения, указанного текущим <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Число фактически удаленных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Укажите положительное значение, чтобы удалить символы, следующие за текущей позиции (как в <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению (как в <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Число фактически удаленных символов может быть меньше, чем указанное `count`.  Это происходит в случаях, где `count` указывает больше знаков, чем существует для удаления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается в положении, для которого текст не разрешен.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Для возвращенного <xref:System.Windows.Documents.TextPointer> всегда представляет собой текстовый контейнер (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте позицию, возвращаемого данным свойством, в качестве базового положения, из которого необходимо применить смещения в другое место.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> И <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> методы предоставляют способ преобразования между положениями и позиции смещения.  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Для возвращенного <xref:System.Windows.Documents.TextPointer> всегда представляет собой текстовый контейнер (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск примыкающих элементов.</param>
        <summary>Возвращение элемента, если таковой имеется, который граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Примыкающий элемент в указанном <paramref name="direction" /> или <see langword="null" />, если не существует примыкающих элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемый элемент обычно является <xref:System.Windows.Documents.TextElement>.  Объект <xref:System.Windows.UIElement> могут быть возвращены при <xref:System.Windows.Documents.TextPointer> указывает на позицию внутри <xref:System.Windows.Documents.BlockUIContainer> элемент или <xref:System.Windows.Documents.InlineUIContainer> элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, задающее логическое направление, в котором осуществляется поиск ограничивающего прямоугольника содержимого.</param>
        <summary>Возвращение ограничивающего прямоугольника (<see cref="T:System.Windows.Rect" />) для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Ограничивающий прямоугольник для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном направлении или <see cref="P:System.Windows.Rect.Empty" />, если текущая допустимая информация о структуре недоступна.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> границы не учитываются содержимого в рамках этого метода.  Если <xref:System.Windows.Documents.TextPointer> располагается перед <xref:System.Windows.Documents.TextElement> edge, возвращаемое значение — это ограничивающий прямоугольник для следующей отличных<xref:System.Windows.Documents.TextElement> содержимого в указанном направлении.  Если отсутствует в указанном направлении, нулевой ширины <xref:System.Windows.Rect> возвращается с высотой, совпадающей с высотой любого предыдущих содержимого.  
  
 Операция, выполняемая этого метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операцией.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск ближайшего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки — где угодно в содержимом, где можно расположить курсор.  Пример допустимого <xref:System.Windows.Documents.TextPointer> , не является положением вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающий тег выше и открывающий тег следующего абзаца).  
  
 Если <xref:System.Windows.Documents.TextPointer> уже указывает на допустимое положение вставки, но закрывающий тег для последовательности форматирования пустым, непосредственно следующий за этой позиции в заданном направлении, то <xref:System.Windows.Documents.TextPointer> возвращает этот метод корректируется для вставки положение сразу после закрытия последовательности форматирования. Например, рассмотрим последовательность разметки `<Bold>a</Bold>b`. Обратите внимание, что две позиции вставки между буквами `a` и `b` -одна, которая предшествует закрывающий `Bold` тег и один — сразу после закрытия `Bold` тега. Если <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> вызывается для <xref:System.Windows.Documents.TextPointer> на позицию непосредственно за буквой `a` и до закрытия `Bold` тег и с `direction` из <xref:System.Windows.Documents.LogicalDirection.Forward>, возвращенный <xref:System.Windows.Documents.TextPointer> корректируется для Позиция непосредственно перед буквой `b`, после закрывающего `Bold` тега. Аналогичные корректировки выполняются для открывающих тегов форматирования при работе в противоположном логическом направлении. Этот метод предназначен для предоставления средства для устранения неоднозначности между позициями вставки в подобных случаях.  
  
 Этот метод также может использоваться при выборе точки вставки, если участвует последовательность структурных тегов. Например, если с позиции между закрытия и открытия тегов абзаца, параметр направления может использоваться для выберите ближайший курсор в начало следующего абзаца (путем указания <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) или в конце предыдущего абзаца ( путем указания <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Если курсор уже находится в позиции курсора, и нет соседних форматирования тегов в указанном `direction`, возвращенный <xref:System.Windows.Documents.TextPointer> указывает на той же позиции, что и у вызывающего <xref:System.Windows.Documents.TextPointer>.  
  
 Возможно, что нет допустимое положение вставки существует относительно позиции, на которые указывают <xref:System.Windows.Documents.TextPointer>.  Это может произойти, если структурно неполные, как в пустую таблицу или список содержимого по ссылке.  В таком случае этот метод возвращает <xref:System.Windows.Documents.TextPointer> к той же позиции, что <xref:System.Windows.Documents.TextPointer> из которого вызывался данный метод.  Этот метод всегда возвращает допустимый <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 В этом примере показано, как использовать <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextElement> пуст печати содержимого.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или <see langword="null" />, если указанная строка выходит за пределы диапазона или не может быть обнаружена иным способом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками в строке направление, заданное параметром <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> выбран в качестве относительного начальную строку.  
  
 Операция, выполняемая этого метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операцией.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> на наличие допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <param name="actualCount">При возврате данный метод включает фактическое число маркеров начала строки, которые были пропущены при определении строки, для которой возвращается начальное положение.  Данное значение может оказаться меньше <paramref name="count" />, если начало или конец содержимого обнаружен до того, как указанное число строк было пропущено. Этот параметр передается неинициализированным.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />, и создание отчета о числе пропущенных строк.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или на начало строки, ближайшей к указанной строке, если указанная строка находится вне диапазона.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками в строке направление, заданное параметром <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> было выбрано свойство как относительный начальную строку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего символа.</param>
        <summary>Возвращение указателя к следующему символу в указанном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к следующему символу в требуемом направлении или <see langword="null" />, если текущий<see cref="T:System.Windows.Documents.TextPointer" /> граничит с началом или концом содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любое из следующих считается символа:  
  
-   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
 Если к следующему символу категории <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, или <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (, который идентифицируется <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод), то <xref:System.Windows.Documents.TextPointer> возвращает этот метод перемещается вперед ровно один символ из текущей позиции.  
  
 Если отнесенным к следующему символу <xref:System.Windows.Documents.TextPointerContext.Text>, то <xref:System.Windows.Documents.TextPointer> возвращает этот метод является превышающими текст к следующему символу нетекстовых (то есть следующей позиции <xref:System.Windows.Documents.TextPointerContext> не <xref:System.Windows.Documents.TextPointerContext.Text>).  Символ точное число пересекаемых можно вычислить заранее путем вызова <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> метод.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода.  В примере используется <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> в сочетании с <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод для перехода и извлеките символов в указанном <xref:System.Windows.Documents.TextElement>.  
  
 Хотя приведенный пример можно использовать для извлечения [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] структуры для содержимого заданного <xref:System.Windows.Documents.TextElement>, он предназначен только для иллюстративных целей и не следует использовать в рабочем коде.  См. в разделе <xref:System.Xml> пространство имен для широкий набор типов, предназначенных для работы с и обработки XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к следующему положению вставки в указанном логическом направлении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, который определяет следующее положение вставки в запрошенном направлении или <see langword="null" />, если невозможно найти следующее положение вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Позицию вставки* является позицией, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки — где угодно в содержимом, где можно расположить курсор.  Пример допустимого <xref:System.Windows.Documents.TextPointer> , не является положением вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающий тег выше и открывающий тег следующего абзаца).  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> метод для обхода границы элемента содержимого, чтобы подсчитать количество <xref:System.Windows.Documents.Paragraph> элементы имеются между двумя заданными <xref:System.Windows.Documents.TextPointer> экземпляров.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" />, который задает положение, до которо٠надо найти расстояние (в символах).</param>
        <summary>Возвращение числа символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Относительное число символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и <paramref name="position" />.  Отрицательное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за положением, заданным <paramref name="position" />, 0 означает, что положения равны, а положительное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует положению, указанному <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любое из следующих считается символа:  
  
-   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> способ поиска смещений для двух <xref:System.Windows.Documents.TextPointer> экземпляров, а затем использует эти сведения для сохранения и восстановления в разделе <xref:System.Windows.Controls.RichTextBox>.  Предполагается, что содержимое <xref:System.Windows.Controls.RichTextBox> не изменились между версией выбора сохранения и восстановления выбора.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором необходимо определить категорию примыкающего содержимого.</param>
        <summary>Возвращение индикатора категории для содержимого, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Одно из значений <see cref="T:System.Windows.Documents.TextPointerContext" />, которое определяет категорию примыкающего содержимого в указанном логическом направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ниже приведен пример использования этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод, чтобы реализовать алгоритм для расчета баланса открывающих и закрывающих тегов элементов между двумя заданными <xref:System.Windows.Documents.TextPointer> позиций.  Каждый открывающий тег элемента считается равно + 1, а для каждого закрывающий тег элемента считается как -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала содержимого.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смещение отрицательное, положение рассчитывается в логическом направлении, противоположном заданному свойством <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определенное заданным смещением, или <see langword="null" />, если невозможно найти соответствующее положение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любое из следующих считается символа:  
  
-   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> метод для реализации пары методов, один для вычисления смещения в указанную позицию относительно любого размещения абзацев, а другой — для возврата <xref:System.Windows.Documents.TextPointer> заданное смещение в указанный абзац.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смешение отрицательное, возвращенный <see cref="T:System.Windows.Documents.TextPointer" /> предшествует текущему <see cref="T:System.Windows.Documents.TextPointer" />; в противном случае, он идет следом.</param>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление возвращенного <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />, а также в указанном направлении.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определяемое заданным смещением, или <see langword="null" />, если смещение выходит за рамки содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любое из следующих считается символа:  
  
-   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение текста, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и возвращение любого примыкающего текста.</param>
        <summary>Возвращение строки, содержащей любой текст, примыкающий к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Строка, содержащая любой примыкающий текст в указанном логическом направлении, или <see cref="F:System.String.Empty" />, если не найдено примыкающего текста.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа, отличное от <xref:System.Windows.Documents.TextPointerContext.Text> Примыкает к текущему <xref:System.Windows.Documents.TextPointer> в указанном направлении.  Аналогичным образом текст, возвращается только до достижения следующим нетекстовым символом.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода. В примере используется <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод для реализации извлечения простого текста.  Метод возвращает объединение строк весь текст между двумя заданными <xref:System.Windows.Documents.TextPointer> экземпляров.  
  
 Хотя приведенный пример можно использовать для извлечения любой текст между двумя <xref:System.Windows.Documents.TextPointer> экземпляров, он предназначен только для иллюстративных целей и не следует использовать в рабочем коде.  Вместо этого следует использовать свойство <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и копирование любого примыкающего текста.</param>
        <param name="textBuffer">Буфер, в который копируется текст.</param>
        <param name="startIndex">Индекс в <paramref name="textBuffer" />, с которого начинается запись копируемого текста.</param>
        <param name="count">Максимальное число символов для копирования.</param>
        <summary>Копирование в указанном направлении заданного максимального числа символов из примыкающего текста в массив символов, предоставленный вызывающим.</summary>
        <returns>Число фактически скопированных символов в <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа, отличное от <xref:System.Windows.Documents.TextPointerContext.Text> Примыкает к текущему <xref:System.Windows.Documents.TextPointer> в указанном направлении.  Аналогичным образом текст, возвращается только до достижения следующим нетекстовым символом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" /> меньше 0 или больше <see cref="P:System.Array.Length" /> свойства <paramref name="textBuffer" />.  
  
-или- 
 <paramref name="count" /> меньше 0 или больше оставшегося пространства в <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> минус <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется подсчет числа символов.</param>
        <summary>Возвращение числа знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом в указанном логическом направлении.</summary>
        <returns>Число знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом.  Данное число может быть равно 0, если примыкающего текста нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Любое из следующих считается символа:  
  
-   Открывающего или закрывающего тега для <xref:System.Windows.Documents.TextElement> элемент.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такие <xref:System.Windows.UIElement> всегда считается как один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символа внутри текстового <xref:System.Windows.Documents.Run> элемент.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, имеется ли для текстового контейнера, связанного с текущим положением, допустимый (современным) макет.</summary>
        <value><see langword="true" />, если макет является текущим и допустимым; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости, операций, зависящих от допустимого макета (таких как <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> метод, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> метод, и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> свойство) пытаться автоматически повторно создать допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операцией.  Это свойство используется для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва строки в текущем положении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" />, располагающийся сразу за элементом <see cref="T:System.Windows.Documents.LineBreak" />, вставленным данным методом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва абзаца в текущем положении.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> к началу (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) нового абзаца.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод вызывается, когда текущая позиция находится внутри существующего <xref:System.Windows.Documents.Paragraph> элемент, существующий абзац и любое содержимое, он содержит разбиваются на два абзаца в текущей позиции.  Если этот метод вызывается, когда текущая позиция не находится внутри существующего абзаца, вставляется новый, пустой абзац.  Если этот метод вызывается с позиции не подходит для разделения или вставки абзаца (например, в том случае, если текущая позиция находится внутри элемента <xref:System.Windows.Documents.Hyperlink> элемент), создается исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Данный метод вызывается для положения, которое невозможно разделить для размещения нового абзаца, как в области <see cref="T:System.Windows.Documents.Hyperlink" /> или <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Текст для вставки.</param>
        <summary>Вставка указанного текста в текст <see cref="T:System.Windows.Documents.Run" /> в текущее положение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> не охватываются <xref:System.Windows.Documents.Run> элемент, <xref:System.Windows.Documents.Run> вставляется вместе с `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущее положение находится за пределами элемента <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="textData" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, является ли положение вставки текущим положением.</summary>
        <value><see langword="true" />, если текущее положение является положением вставки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки — где угодно в содержимом, где можно расположить курсор.  Пример допустимого <xref:System.Windows.Documents.TextPointer> , не является положением вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающий тег выше и открывающий тег следующего абзаца).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, находится ли текущее положение в начале строки.</summary>
        <value><see langword="true" />, если текущее положение находится в начале строки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками в строке направление, заданное параметром <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> было выбрано свойство как относительный начальную строку.  
  
 Операция, выполняемая это свойство зависит от допустимого макета.  При необходимости этот метод пытается автоматически повторно создать допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операцией.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition"><see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Определение, находится ли указанное положение в том же текстовом контейнере, что и текущее положение.</summary>
        <returns><see langword="true" />, если <paramref name="textPosition" /> указывает положение, которое располагается в том же текстовом контейнере, что и текущее положение; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большинство операций, включающих несколько <xref:System.Windows.Documents.TextPointer> экземпляров допустимы только в случае, если экземпляры указывают позиций, которые находятся в одной и той же области видимости контейнера текста.  Например <xref:System.Windows.Documents.TextPointer.CompareTo%2A> и <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> методы нельзя использовать с <xref:System.Windows.Documents.TextPointer> позицию за пределами текстового контейнера, связанного с текущим положением.  Этот метод позволяет убедитесь, что указанный <xref:System.Windows.Documents.TextPointer> совместима с текущей позиции для таких операций.  
  
   
  
## Examples  
 Ниже приведен пример использования этого метода.  В примере используется <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextPointer> располагается между двумя для других из заданными <xref:System.Windows.Documents.TextPointer> экземпляров в ситуации, когда нет никакой гарантии, что всех трех позиций принадлежат том же текстовом контейнере.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="textPosition" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического направления, связанного с текущим положением, которое используется для снятия неоднозначности в отношении содержимого, связанного с текущим положением.</summary>
        <value>Значение <see cref="T:System.Windows.Documents.LogicalDirection" />, которое связано с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В качестве примера использования этого свойства <xref:System.Windows.Documents.LogicalDirection> из <xref:System.Windows.Documents.TextPointer> возвращаемые проверкой нажатия дает нажатия, между двумя символами текста. Указывает логическое направление, какой из двух символов, фактически был нажат - влево или вправо.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение абзаца, в области которого находится текущее положение, если таковой имеется.</summary>
        <value><see cref="T:System.Windows.Documents.Paragraph" /> , Определяющий область текущей позиции, или <see langword="null" /> Если такого абзаца не существует.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического родительского элемента, задающего область для текущего положения.</summary>
        <value>Логический родительский элемент, задающий область для текущего положения.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Данный тип или элемент поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <returns>Строка, представляющая объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>